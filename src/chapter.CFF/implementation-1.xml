<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section role="implementation">
      <title>Implementation</title>
      <para>Of course, we have a class to represent a CFF Table
          structure:</para>
      <code-fragment package="com.adobe.aots.CommonType" class="CFF"><code-title>CFF class</code-title>
  package com.adobe.aots.CommonType;

  import com.adobe.aots.util.ContentHandlerPlus;

  public class CFF extends Table {
    <code-include linkend="cff.members"/>
    <code-include linkend="cff.methods"/>

    public CFF () {
      super (Tag.CFF, null);
    }

    public CFF (Font font) {
      super (Tag.CFF, font);
    }
  }
</code-fragment>
      <para>A CFF table is really a container for a CFF FontSet.</para>
      <code-fragment id="cff.members"><code-title>CFF members</code-title>
  protected boolean dataIsRight = false;
  protected boolean fontsetIsRight = false;

  protected CFFFontSet fontset;
</code-fragment>
      <para>This CFF FontSet must contain a single CFF Font.
          Consequently, many of the operations on a CFF tables are
          delegated to the first font of the CFF FontSet:</para>
      <code-fragment id="cff.methods">
  public void makeFontsetRight ()
      throws InvalidFontException {
    if (! fontsetIsRight) {
      fontset = new CFFFontSet ();
      fontset.fromBinary (data);
      fontsetIsRight = true; }
  }

  private void makeDataRight () {
    if (! dataIsRight) {
      data = fontset.toBinary (); }
  }

  public String getGlyphName (int gid) {
    try {
      makeFontsetRight ();  }
    catch (InvalidFontException e) {
      return "??"; }
    return fontset.getGlyphName (0, gid);
  }

  public String[] getGlyphName (int[] gids) {
    String[] names = new String [gids.length];
    for (int i = 0; i &lt; gids.length; i++) {
      names [i] = getGlyphName (gids [i]); }
    return names;
  }

  public String[] getGlyphNames () {
    String[] names = new String [font.maxp.getNumGlyphs ()];
    for (int i = 0; i &lt; names.length; i++) {
      names [i] = getGlyphName (i); }
    return names;
  }

  public int getGlyphID (String glyphname)
      throws InvalidFontException {
    makeFontsetRight ();
    return fontset.getGlyphID (0, glyphname);
  }

  public void getGlyphOutline (int gid, StringBuilder sb) {
    try {
      makeFontsetRight (); }
    catch (InvalidFontException e) {
      System.err.println ("??"); }
    fontset.getGlyphOutline (0, gid, sb);
  }

  public void getGlyphLinesAndCurves (int gid, StringBuilder sb) {
    try {
      makeFontsetRight (); }
    catch (InvalidFontException e) {
      System.err.println ("??"); }
    fontset.getGlyphLinesAndCurves (0, gid, sb);
  }

  public BoundingBox getContoursBoundingBox (int gid) {
    try {
      makeFontsetRight (); }
    catch (InvalidFontException e) {
      System.err.println ("??"); }
    return fontset.getContoursBoundingBox (0, gid);
  }

  public String getPostScriptName ()
      throws InvalidFontException {
    makeFontsetRight ();
    return fontset.getName (0);
  }

  public boolean isNameKeyed ()
      throws InvalidFontException {
    makeFontsetRight ();
    return fontset.isNameKeyed (0);
  }
</code-fragment>
      <para>Our <varname>CFFFontSet</varname> class does not see our
          <varname>data</varname> and in fact requires that the binary
          data be processed before other methods can be invoked. More
          details can be found in the Annotated CFF
          specification.</para>
      <code-fragment id="cff.methods"><code-title>Loading/Unloading a CFF</code-title>
  public int fromBinary (java.io.InputStream in, int length)
      throws java.io.IOException, InvalidFontException {
    super.fromBinary (in, length);
    dataIsRight = true;
    fontsetIsRight = false;
    return length;
  }

  public byte[] toBinary () {
    makeDataRight ();
    return data;
  }
</code-fragment>
      <code-fragment id="cff.methods"><code-title>??</code-title>
  public void toCID () throws InvalidFontException {
    makeFontsetRight ();
    fontset.toCID (0);
    dataIsRight = false;
  }
</code-fragment>
    </section>
  
