<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section id="chapter.EBLC">
  <title>EBLC - Embedded Bitmap Location Table</title>
  <!--======================================================================-->
  <section role="fragment">
    <title>Overview</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>Three tables are used to embed bitmaps in CommonType
          fonts. They are the <ottable>EBLC</ottable> table for embedded bitmap
          locators, the 'EBDT' table for embedded bitmap data, and the
          <ottable>EBSC</ottable> table for embedded bitmap scaling information.
          CommonType embedded bitmaps are called 'sbits' (for "scaler
          bitmaps"). A set of bitmaps for a face at a given size is
          called a strike.</para>
      <para>The <ottable>EBLC</ottable> table identifies the sizes and glyph ranges
          of the sbits, and keeps offsets to glyph bitmap data in
          indexSubTables. The 'EBDT' table then stores the glyph
          bitmap data, also in a number of different possible formats.
          Glyph metrics information may be stored in either the <ottable>EBLC</ottable>
          or 'EBDT' table, depending upon the indexSubTable and glyph
          bitmap formats. The <ottable>EBSC</ottable> table identifies sizes that will
          be handled by scaling up or scaling down other sbit
          sizes.</para>
      <para>The <ottable>EBLC</ottable> table uses the same format as Apple's AAT
          (Apple Advanced Typography) 'bloc' table.</para>
      <para>The <ottable>EBLC</ottable> table begins with a header containing the
          table version and number of strikes. An CommonType font may
          have one or more strikes embedded in the 'EBDT'
          table.</para>
      <otformat>
        <title>eblcHeader</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>FIXED</otfieldtype>
          <otfieldname>version</otfieldname>
          <otfielddesc>initially defined as 0x00020000</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>numSizes</otfieldname>
          <otfielddesc>Number of bitmapSizeTables</otfielddesc>
        </otfield>
      </otformat>
      <para>The eblcHeader is followed immediately by the
          bitmapSizeTable array(s). The numSizes in the eblcHeader
          indicates the number of bitmapSizeTables in the array. Each
          strike is defined by one bitmapSizeTable.</para>
      <otformat>
        <title>bitmapSizeTable</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>indexSubTableArrayOffset</otfieldname>
          <otfielddesc>offset to index subtable from beginning of
              EBLC.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>indexTablesSize</otfieldname>
          <otfielddesc>number of bytes in corresponding index
              subtables and array</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>numberOfIndexSubTables</otfieldname>
          <otfielddesc>an index subtable for each range or format
              change</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>12</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>colorRef</otfieldname>
          <otfielddesc>not used; set to 0.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>16</otfieldoffs>
          <otfieldtype>sbitLineMetrics</otfieldtype>
          <otfieldname>hori</otfieldname>
          <otfielddesc>line metrics for text rendered
              horizontally</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>28</otfieldoffs>
          <otfieldtype>sbitLineMetrics</otfieldtype>
          <otfieldname>vert</otfieldname>
          <otfielddesc>line metrics for text rendered
              vertically</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>40</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>startGlyphIndex</otfieldname>
          <otfielddesc>lowest glyph index for this
              size</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>42</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>endGlyphIndex</otfieldname>
          <otfielddesc>highest glyph index for this
              size</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>44</otfieldoffs>
          <otfieldtype>BYTE</otfieldtype>
          <otfieldname>ppemX</otfieldname>
          <otfielddesc>horizontal pixels per Em</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>45</otfieldoffs>
          <otfieldtype>BYTE</otfieldtype>
          <otfieldname>ppemY</otfieldname>
          <otfielddesc>vertical pixels per Em</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>46</otfieldoffs>
          <otfieldtype>BYTE</otfieldtype>
          <otfieldname>bitDepth</otfieldname>
          <otfielddesc>the Microsoft rasterizer v.1.7 or greater
              supports the following bitDepth values, as described
              below: 1, 2, 4, and 8.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>47</otfieldoffs>
          <otfieldtype>CHAR</otfieldtype>
          <otfieldname>flags</otfieldname>
          <otfielddesc>vertical or horizontal (see
              bitmapFlags)</otfielddesc>
        </otfield>
      </otformat>
      <para>The indexSubTableArrayOffset is the offset from the
          beginning of the <ottable>EBLC</ottable> table to the indexSubTableArray.
          Each strike has one of these arrays to support various
          formats and discontiguous ranges of bitmaps. The
          indexTablesSize is the total number of bytes in the
          indexSubTableArray and the associated indexSubTables. The
          numberOfIndexSubTables is a count of the indexSubTables for
          this strike.</para>
      <para>The horizontal and vertical line metrics contain the
          ascender, descender, linegap, and advance information for
          the strike. The line metrics format is described in the
          following table:</para>
      <table>
        <title>sbitLineMetrics</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>CHAR</entry>
              <entry>ascender</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>descender</entry>
            </row>
            <row>
              <entry>BYTE</entry>
              <entry>widthMax</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>caretSlopeNumerator</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>caretSlopeDenominator</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>caretOffset</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>minOriginSB</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>minAdvanceSB</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>maxBeforeBL</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>minAfterBL</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>pad1</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>pad2</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The caret slope determines the angle at which the caret
          is drawn, and the offset is the number of pixels (+ or -) to
          move the caret. This is a signed char since we are dealing
          with integer metrics. The minOriginSB, minAdvanceSB ,
          maxBeforeBL, and minAfterBL are described in the diagrams
          below. The main need for these numbers is for scalers that
          may need to pre-allocate memory and/or need more metric
          information to position glyphs. All of the line metrics are
          one byte in length. The line metrics are not used directly
          by the rasterizer, but are available to clients who want to
          parse the <ottable>EBLC</ottable> table.</para>
      <para>The startGlyphIndex and endGlyphIndex describe the
          minimum and maximum glyph codes in the strike, but a strike
          does not necessarily contain bitmaps for all glyph codes in
          this range. The indexSubTables determine which glyphs are
          actually present in the 'EBDT' table.</para>
      <para>The ppemX and ppemY fields describe the size of the
          strike in pixels per Em. The ppem measurement is equivalent
          to point size on a 72 dots per inch device. Typically, ppemX
          will be equal to ppemY for devices with 'square pixels'. To
          accommodate devices with rectangular pixels, and to allow
          for bitmaps with other aspect ratios, ppemX and ppemY may
          differ.</para>
      <para>The bitDepth field is used to specify the number of
          levels of gray used in the embedded bitmaps. The Microsoft
          rasterizer v.1.7 or greater support the following
          values.</para>
      <table>
        <title>bitDepth</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Value</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>1</entry>
              <entry>black/white</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>4 levels of gray</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>16 levels of gray</entry>
            </row>
            <row>
              <entry>8</entry>
              <entry>256 levels of gray</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The 'flags' byte contains two bits to indicate the
          direction of small glyph metrics: horizontal or vertical.
          The remaining bits are reserved.</para>
      <table>
        <title>Bitmap Flags</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Type</entry>
              <entry>Name</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>CHAR</entry>
              <entry>0x01</entry>
              <entry>Horizontal</entry>
            </row>
            <row>
              <entry>CHAR</entry>
              <entry>0x02</entry>
              <entry>Vertical</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The colorRef and bitDepth fields are reserved for future
          enhancements. For monochrome bitmaps they should have the
          values colorRef=0 and bitDepth=1.</para>
      <figure>
        <title>Horizontal text</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../../img00283.gif"/>
          </imageobject>
        </mediaobject>
      </figure>
      <figure>
        <title>Vertical text</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../../img00284.gif"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Associated with the image data for every glyph in a
          strike is a set of glyph metrics. These glyph metrics
          describe bounding box height and width, as well as side
          bearing and advance width information. The glyph metrics can
          be found in one of two places. For ranges of glyphs (not
          necessarily the whole strike) whose metrics may be different
          for each glyph, the glyph metrics are stored along with the
          glyph image data in the 'EBDT' table. Details of how this is
          done is described in the 'EBDT' section of this document.
          For ranges of glyphs whose metrics are identical for every
          glyph, we save significant space by storing a single copy of
          the glyph metrics in the indexSubTable in the <ottable>EBLC</ottable>.</para>
      <para>There are also two different formats for glyph metrics:
          big glyph metrics and small glyph metrics. Big glyph metrics
          define metrics information for both horizontal and vertical
          layouts. This is important in fonts (such as Kanji) where
          both types of layout may be used. Small glyph metrics define
          metrics information for one layout direction only. Which
          direction applies, horizontal or vertical, is determined by
          the 'flags' field in the bitmapSizeTable.</para>
      <table>
        <title>bigGlyphMetrics</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Offset</entry>
              <entry>Type</entry>
              <entry>Name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0</entry>
              <entry>BYTE</entry>
              <entry>height</entry>
            </row>
            <row>
              <entry>1</entry>
              <entry>BYTE</entry>
              <entry>width</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>CHAR</entry>
              <entry>horiBearingX</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>CHAR</entry>
              <entry>horiBearingY</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>BYTE</entry>
              <entry>horiAdvance</entry>
            </row>
            <row>
              <entry>5</entry>
              <entry>CHAR</entry>
              <entry>vertBearingX</entry>
            </row>
            <row>
              <entry>6</entry>
              <entry>CHAR</entry>
              <entry>vertBearingY</entry>
            </row>
            <row>
              <entry>7</entry>
              <entry>BYTE</entry>
              <entry>vertAdvance</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table>
        <title>smallGlyphMetrics</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Offset</entry>
              <entry>Type</entry>
              <entry>Name</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>0</entry>
              <entry>BYTE</entry>
              <entry>height</entry>
            </row>
            <row>
              <entry>1</entry>
              <entry>BYTE</entry>
              <entry>width</entry>
            </row>
            <row>
              <entry>2</entry>
              <entry>CHAR</entry>
              <entry>BearingX</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>CHAR</entry>
              <entry>BearingY</entry>
            </row>
            <row>
              <entry>4</entry>
              <entry>BYTE</entry>
              <entry>Advance</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The following diagram illustrates the meaning of the
          glyph metrics.</para>
      <informalfigure>
        <mediaobject>
          <imageobject>
            <imagedata fileref="../../img00285.gif"/>
          </imageobject>
        </mediaobject>
      </informalfigure>
      <para>The bitmapSizeTable for each strike contains the offset
          to an array of indexSubTableArray elements. Each element
          describes a glyph code range and an offset to the
          indexSubTable for that range. This allows a strike to
          contain multiple glyph code ranges and to be represented in
          multiple index formats if desirable.</para>
      <otformat>
        <title>indexSubTableArray</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>firstGlyphIndex</otfieldname>
          <otfielddesc>first glyph code of this range</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>lastGlyphIndex</otfieldname>
          <otfielddesc>last glyph code of this range
              (inclusive)</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>additionalOffsetToIndexSubtable</otfieldname>
          <otfielddesc>add to indexSubTableArrayOffset to get offset
              from beginning of <ottable>EBLC</ottable></otfielddesc>
        </otfield>
      </otformat>
      <para>After determining the strike, the rasterizer searches
          this array for the range containing the given glyph code.
          When the range is found, the additionalOffsetToIndexSubtable
          is added to the indexSubTableArrayOffset to get the offset
          of the indexSubTable in the <ottable>EBLC</ottable>.</para>
      <para>The first indexSubTableArray is located after the last
          bitmapSizeSubTable entry. Then the indexSubTables for the
          strike follow. Another indexSubTableArray (if more than one
          strike) and its indexSubTables are next. The <ottable>EBLC</ottable>
          continues with an array and indexSubTables for each
          strike.</para>
      <para>We now have the offset to the indexSubTable. All
          indexSubTable formats begin with an indexSubHeader which
          identifies the indexSubTable format, the format of the
          'EBDT' image data, and the offset from the beginning of the
          'EBDT' table to the beginning of the image data for this
          range.</para>
      <otformat>
        <title>indexSubHeader</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>indexFormat</otfieldname>
          <otfielddesc>format of this indexSubTable</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>imageFormat</otfieldname>
          <otfielddesc>format of 'EBDT' image data</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>imageDataOffset</otfieldname>
          <otfielddesc>offset to image data in 'EBDT'
              table</otfielddesc>
        </otfield>
      </otformat>
      <para>There are currently five different formats used for the
          indexSubTable, depending upon the size and type of bitmap
          data in the glyph code range. Apple 'bloc' tables support
          only formats 1 through 3.</para>
      <para>The choice of which indexSubTable format to use is up to
          the font manufacturer, but should be made with the aim of
          minimizing the size of the font file. Ranges of glyphs with
          variable metrics - that is, where glyphs may differ from
          each other in bounding box height, width, side bearings or
          advance - must use format 1, 3 or 4. Ranges of glyphs with
          constant metrics can save space by using format 2 or 5,
          which keep a single copy of the metrics information in the
          indexSubTable rather than a copy per glyph in the 'EBDT'
          table. In some monospaced fonts it makes sense to store
          extra white space around some of the glyphs to keep all
          metrics identical, thus permitting the use of format 2 or
          5.</para>
      <para>Structures for each indexSubTable format are listed
          below.</para>
      <otformat>
        <title>indexSubTable1: variable metrics glyphs with 4 byte
            offsets</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>indexSubHeader</otfieldtype>
          <otfieldname>header</otfieldname>
          <otfielddesc>header info</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>offsetArray []</otfieldname>
          <otfielddesc>offsetArray[glyphIndex] + imageDataOffset =
              glyphData sizeOfArray = (lastGlyph-firstGlyph+1)+1+1 pad
              if needed </otfielddesc>
        </otfield>
      </otformat>
      <otformat>
        <title>indexSubTable2: all glyphs have identical
            metrics</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>indexSubHeader</otfieldtype>
          <otfieldname>header</otfieldname>
          <otfielddesc>header info</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>imageSize</otfieldname>
          <otfielddesc>all the glyphs are of the same
              size</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>12</otfieldoffs>
          <otfieldtype>bigGlyphMetrics</otfieldtype>
          <otfieldname>bigMetrics</otfieldname>
          <otfielddesc>all glyphs have the same metrics; glyph data
              may be compressed, byte-aligned, or
              bit-aligned</otfielddesc>
        </otfield>
      </otformat>
      <otformat>
        <title>indexSubTable3: variable metrics glyphs with 2 byte
            offsets</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>indexSubHeader</otfieldtype>
          <otfieldname>header</otfieldname>
          <otfielddesc>header info</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>offsetArray []</otfieldname>
          <otfielddesc>offsetArray[glyphIndex] + imageDataOffset =
              glyphData sizeOfArray = (lastGlyph-firstGlyph+1)+1+1 pad
              if needed  </otfielddesc>
        </otfield>
      </otformat>
      <otformat>
        <title>indexSubTable4: variable metrics glyphs with sparse
            glyph codes</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>indexSubHeader</otfieldtype>
          <otfieldname>header</otfieldname>
          <otfielddesc>header info</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>numGlyphs</otfieldname>
          <otfielddesc>array length</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>12</otfieldoffs>
          <otfieldtype>codeOffsetPair</otfieldtype>
          <otfieldname>glyphArray []</otfieldname>
          <otfielddesc>one per glyph;
              sizeOfArray=numGlyphs+1</otfielddesc>
        </otfield>
      </otformat>
      <para>codeOffsetPair: used by indexSubTable4</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>glyphCode</otfieldname>
          <otfielddesc>code of glyph present</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>offset</otfieldname>
          <otfielddesc>location in EBDT</otfielddesc>
        </otfield>
      </otformat>
      <otformat>
        <title>indexSubTable5: constant metrics glyphs with sparse
            glyph codes</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>indexSubHeader</otfieldtype>
          <otfieldname>header</otfieldname>
          <otfielddesc>header info</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>imageSize</otfieldname>
          <otfielddesc>all glyphs have the same data
              size</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>10</otfieldoffs>
          <otfieldtype>bigGlyphMetrics</otfieldtype>
          <otfieldname>bigMetrics</otfieldname>
          <otfielddesc>all glyphs have the same
              metrics</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>18</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>numGlyphs</otfieldname>
          <otfielddesc>array length</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>22</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>glyphCodeArray []</otfieldname>
          <otfielddesc>one per glyph, sorted by glyph code;
              sizeOfArray=numGlyphs</otfielddesc>
        </otfield>
      </otformat>
      <para>The size of the 'EBDT' image data can be calculated from
          the indexSubTable information. For the constant metrics
          formats (2 and 5) the image data size is constant, and is
          given in the imageSize field. For the variable metrics
          formats (1, 3, and 4) image data must be stored contiguously
          and in glyph code order, so the image data size may be
          calculated by subtracting the offset for the current glyph
          from the offset of the next glyph. Because of this, it is
          necessary to store one extra element in the offsetArray
          pointing just past the end of the range's image data. This
          will allow the correct calculation of the image data size
          for the last glyph in the range.</para>
      <para>Contiguous, or nearly contiguous, ranges of glyph codes
          are handled best by formats 1, 2, and 3 which store an
          offset for every glyph code in the range. Very sparse ranges
          of glyph codes should use format 4 or 5 which explicitly
          call out the glyph codes represented in the range. A small
          number of missing glyphs can be efficiently represented in
          formats 1 or 3 by having the offset for the missing glyph be
          followed by the same offset for the next glyph, thus
          indicating a data size of zero.</para>
      <para>The only difference between formats 1 and 3 is the size
          of the offsetArray elements: format 1 uses ULONG's while
          format 3 uses USHORT's. Therefore format 1 can cover a
          greater range (&gt; 64k bytes) while format 3 saves more space
          in the <ottable>EBLC</ottable> table. Since the offsetArray elements are
          added to the imageDataOffset base address in the
          indexSubHeader, a very large set of glyph bitmap data could
          be addressed by splitting it into multiple ranges, each less
          than 64k bytes in size, allowing the use of the more
          efficient format 3.</para>
      <para>The <ottable>EBLC</ottable> table specification requires double word
          (ULONG) alignment for all subtables. This occurs naturally
          for indexSubTable formats 1, 2, and 4, but may not for
          formats 3 and 5, since they include arrays of type USHORT.
          When there is an odd number of elements in these arrays it
          is necessary to add an extra padding element to maintain
          proper alignment.</para>
    </section>
  </section>
</section>
