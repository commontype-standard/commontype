<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section role="compiler">
      <title>Compiler</title>
      <code-fragment id="lookuptable.methods">
  private Block contextLookupFormat2FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block&gt; blockCache,
					     Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;

    Element firstChild = (Element) subtable.getFirstChild ();
    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith ("coverage"))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    ClassdefTableBlock inputClassdef
        = classdefFromXML ((Element) subtable.getFirstChild (),
                           table, blockCache);
    subtable.removeChild (subtable.getFirstChild ());

    NodeList classPatterns = subtable.getChildNodes ();

    if (coverage == null) {
      System.err.println ("implicit coverage in contextSubstFormat2 not yet supported"); }


    me = new Block (8 + 2*inputClassdef.classCount,
                    2 + inputClassdef.classCount);
    me.setuint16 (0, 2);
    me.setOffset (2, coverage);
    me.setOffset (4, inputClassdef);
    me.setuint16 (6, inputClassdef.classCount);

    for (int c = 0; c &lt; inputClassdef.classCount; c++) {

      // count how many classPatterns start with class c
      int count = 0;
      for (int j = 0; j &lt; classPatterns.getLength (); j++) {
        Element classPattern = (Element) classPatterns.item (j);
        int[] classes = parseIntList (classPattern.getAttribute ("in"));
        if (classes [0] == c) {
          count++; }}

      if (count == 0) {
        me.setOffset (8 + 2*c, null); }

      else {
        Block subClassSet = new Block (2 + 2*count, count);
        me.setOffset (8 + 2*c, subClassSet);
        subClassSet.setuint16 (0, count);

        count = 0;
        for (int j = 0; j &lt; classPatterns.getLength (); j++) {
          Element classPattern = (Element) classPatterns.item (j);
          int[] classes = parseIntList (classPattern.getAttribute ("in"));
          if (classes [0] == c) {

            NodeList applies = classPattern.getChildNodes ();
            int applyCount = applies.getLength ();

            Block subClassRule = new Block (4 + 2 * (classes.length - 1)
                                            + 4 * applyCount,
                                            0);

            subClassSet.setOffset (2 + 2*(count++), subClassRule);
            subClassRule.setuint16 (0, classes.length);
            subClassRule.setuint16 (2, applyCount);
            for (int k = 1; k &lt; classes.length; k++) {
              subClassRule.setuint16 (4 + 2*(k-1), classes [k]); }

            subLookupsFromXML (applyCount, applies,
                              subClassRule, 4 + 2*(classes.length-1),
			      lookupIndices); }}}}

    return me;
  }
</code-fragment>
    </section>
    
