<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section role="compiler">
      <title>Compiler</title>
      <code-fragment id="lookuptable.methods">
  private Block chainingLookupFormat1FromXML (Element subtable, Element table,
                                              Map&lt;Element, Block&gt; blockCache,
                                              Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith ("coverage"))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    NodeList rules = subtable.getChildNodes ();
    int rulesCount = rules.getLength ();

    int [] firstGlyphs = new int [rulesCount];
    for (int i = 0; i &lt; rulesCount; i++) {
      Element rule = (Element) rules.item (i);
      firstGlyphs [i] = getGlyphs (rule.getAttribute ("in")) [0]; }

    if (coverage == null) {
      int [] coveredGlyphs = new int [rulesCount];
      int count = 0;
      for (int i = 0; i &lt; rulesCount; i++) {
        int glyph = firstGlyphs [i];
        boolean addIt = true;
        for (int j = 0; j &lt; count; j++) {
          if (glyph == coveredGlyphs [j]) {
            addIt = false;
            break; }}
        if (addIt) {
          coveredGlyphs [count++] = glyph; }}
      coverage = coverageFromGlyphs (coveredGlyphs, count); }

    me = new Block (6 + 2 * coverage.glyphs.length,
                    1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, coverage.glyphs.length);

    for (int g = 0; g &lt; coverage.glyphs.length; g++) {
      // count the number of subst that start with coverage.glyph [g]
      int nodeCount = 0;
      for (int j = 0; j &lt; rulesCount; j++) {
        if (firstGlyphs [j] == coverage.glyphs [g]) {
          nodeCount++; }}

      Block subRuleSetTable = new Block (2 + 2*nodeCount, nodeCount);
      subRuleSetTable.setuint16 (0, nodeCount);
      nodeCount = 0;
      me.setOffset (6 + 2*g, subRuleSetTable);

      for (int j = 0; j &lt; rulesCount; j++) {
        if (firstGlyphs [j] == coverage.glyphs [g]) {

          Element rule = (Element) rules.item (j);
          int [] backtrack = getGlyphs (rule.getAttribute ("back"));
          int [] in        = getGlyphs (rule.getAttribute ("in"));
          int [] lookahead = getGlyphs (rule.getAttribute ("ahead"));

          NodeList substs = rule.getChildNodes ();
          int substCount = substs.getLength ();

          Block subRuleTable = new Block (  2 + 2 * backtrack.length
                                          + 2 + 2 * (in.length - 1)
                                          + 2 + 2 * lookahead.length
                                          + 2 + 4 * substCount, 0);
          subRuleSetTable.setOffset (2 + 2* (nodeCount++),
                                          subRuleTable);
          int offset = 0;
          subRuleTable.setuint16 (offset, backtrack.length);
          offset += 2;
          for (int k = backtrack.length - 1; k &gt;= 0; k--) {
            subRuleTable.setGlyphID (offset, backtrack [k]);
            offset += 2; }
          subRuleTable.setuint16 (offset, in.length);
          offset += 2;
          for (int k = 1; k &lt; in.length; k++) {
            subRuleTable.setGlyphID (offset, in [k]);
            offset += 2; }
          subRuleTable.setuint16 (offset, lookahead.length);
          offset += 2;
          for (int k = 0; k &lt; lookahead.length; k++) {
            subRuleTable.setGlyphID (offset, lookahead [k]);
            offset += 2; }
          subRuleTable.setuint16 (offset, substCount);
          offset += 2;

	  offset += subLookupsFromXML (substCount, substs, subRuleTable, offset,
				      lookupIndices); }}}

    return me;
  }
</code-fragment>
    </section>
    
