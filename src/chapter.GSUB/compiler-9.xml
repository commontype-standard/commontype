<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section role="compiler">
      <title>Compiler</title>
      <code-fragment id="lookuptable.methods">
  private Block contextLookupFormat1FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block&gt; blockCache,
					     Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith ("coverage"))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    NodeList rules = subtable.getChildNodes ();
    int rulesCount = rules.getLength ();

    int [][] in  = new int [rulesCount] [];

    for (int i = 0; i &lt; rulesCount; i++) {
      Element rule = (Element) rules.item (i);
      in [i] = getGlyphs (rule.getAttribute ("in")); }

    if (coverage == null) {
      int [] coveredGlyphs = new int [rulesCount];
      int count = 0;
      for (int i = 0; i &lt; rulesCount; i++) {
        int glyph = in [i][0];
        boolean addIt = true;
        for (int j = 0; j &lt; count; j++) {
          if (glyph == coveredGlyphs [j]) {
            addIt = false;
            break; }}
        if (addIt) {
          coveredGlyphs [count++] = glyph; }}
      coverage = coverageFromGlyphs (coveredGlyphs, count); }


    me = new Block (6 + 2 * coverage.glyphs.length,
                    1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, coverage.glyphs.length);

    for (int g = 0; g &lt; coverage.glyphs.length; g++) {
      // count the number of subst that start with coverage.glyphs [g]
      int nodeCount = 0;
      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {
          nodeCount++; }}

      Block subRuleSetTable = new Block (2 + 2*nodeCount, nodeCount);
      subRuleSetTable.setuint16 (0, nodeCount);
      nodeCount = 0;
      me.setOffset (6 + 2*g, subRuleSetTable);

      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {

          Element rule = (Element) rules.item (j);
          NodeList substs = rule.getChildNodes ();
          int substCount = substs.getLength ();

          Block subRuleTable = new Block (4 + 2 * (in[j].length - 1) +
                                          4 * substCount, 0);
          subRuleSetTable.setOffset (2 + 2*(nodeCount++), subRuleTable);
          subRuleTable.setuint16 (0, in[j].length);
          subRuleTable.setuint16 (2, substCount);

          for (int k = 1; k &lt; in[j].length; k++) {
            subRuleTable.setGlyphID (4 + 2*(k-1), in [j][k]); }

	  subLookupsFromXML (substCount, substs,
	                    subRuleTable, 4 + 2*(in[j].length-1),
			    lookupIndices); }}}

    return me;
  }
</code-fragment>
    </section>
    
