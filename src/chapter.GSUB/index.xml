<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section id="chapter.GSUB"  xmlns:web="http://aots.adobe.com/2001/web" xmlns:rng="http://relaxng.org/ns/structure/1.0" xmlns:ots="http://aots.adobe.com/2001/ots" xmlns:aots="http://aots.adobe.com/2001/aots">
    <title>GSUB - The Glyph Substitution Table</title>

    <!--======================================================================-->
    <section role="fragment">
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The Glyph Substitution table (<ottable>GSUB</ottable>)
          contains information for substituting glyphs to render the
          scripts and language systems supported in a font. Many
          language systems require glyph substitutes. For example, in
          the Arabic script, the glyph shape that depicts a particular
          character varies according to its position in a word or text
          string (see figure 1). In other language systems, glyph
          substitutes are aesthetic options for the user, such as the
          use of ligature glyphs in the English language (see Figure
          2)</para>

        <figure>
          <title>Figure 1: Isolated, initial, medial, and final forms
            of the Arabic character HAH</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../../fig3a.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <figure>
          <title>Figure 2. Two Latin glyphs and their associated
            ligature</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../../fig3b.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Many fonts use limited character encoding standards that
          map glyphs to characters one-to-one, assigning a glyph to
          each character code value in a font. Multiple character
          codes cannot be mapped to a single glyph, as needed for
          ligature glyphs, and multiple glyphs cannot be mapped to a
          single character code, as needed to decompose a ligature
          into its component glyphs.</para>

        <para>To supply glyph substitutes, font developers must assign
          different character codes to the glyphs, or they must create
          additional fonts or character sets. To access these glyphs,
          users must bear the burden of switching between character
          codes, character sets, or fonts.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>The term &quot;limited character encoding standards&quot; in the
          first sentence is somewhat misleading. Unicode for example
          can hardly be considered a &quot;limited&quot; standard. May a better
          formulation for the first sentence may be: &quot;Character
          standards typically encode characters but not glyphs; at the
          same time, fonts typically map from one character to one
          glyph.&quot;</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Substituting Glyphs with CommonType</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The CommonType <ottable>GSUB</ottable> table fully
          supports glyph substitution. To access glyph substitutes,
          <ottable>GSUB</ottable> maps from the glyph index or indices
          defined in a cmap table to the glyph index or indices of the
          glyph substitutes. For example, if a font has three
          alternative forms of an ampersand glyph, the cmap table
          associates the ampersand's character code with only one of
          these glyphs. In <ottable>GSUB</ottable>, the indices of the
          other ampersand glyphs are then referenced by this one
          index.</para>

        <para>The text-processing client uses the
          <ottable>GSUB</ottable> data to manage glyph substitution
          actions. <ottable>GSUB</ottable> identifies the glyphs that
          are input to and output from each glyph substitution action,
          specifies how and where the client uses glyph substitutes,
          and regulates the order of glyph substitution operations.
          Any number of substitutions can be defined for each script
          or language system represented in a font.</para>

        <para>The <ottable>GSUB</ottable> table supports six types of glyph
          substitutions that are widely used in international
          typography:</para>

        <itemizedlist>
          <listitem>
            <para>A <emphasis>single substitution</emphasis> replaces
              a single glyph with another single glyph. This is used
              to render positional glyph variants in Arabic and
              vertical text in the Far East (see Figure 3)</para>

            <figure>
              <title>Figure 3. Alternative forms of parentheses used
                when positioning Kanji vertically</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="../../fig3c.gif"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>

          <listitem>
            <para>A <emphasis>multiple substitution</emphasis>
              replaces a single glyph with more than one glyph. This
              is used to specify actions such as ligature
              decomposition (see Figure 4)</para>

            <figure>
              <title>Figure 4. Decomposing a Latin ligature glyph into
                its individual glyph components</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="../../fig3d.gif"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>

          <listitem>
            <para>An <emphasis>alternate substitution</emphasis>
              identifies functionally equivalent but different looking
              forms of a glyph. These glyphs are often referred to as
              aesthetic alternatives. For example, a font might have
              five different glyphs for the ampersand symbol, but one
              would have a default glyph index in the cmap table. The
              client could use the default glyph or substitute any of
              the four alternatives (see Figure 5)</para>

            <figure>
              <title>Figure 5. Alternative ampersand glyphs in a
                font</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="../../fig3e.gif"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>

          <listitem>
            <para>A <emphasis>ligature substitution</emphasis>
              replaces several glyph indices with a single glyph
              index, as when an Arabic ligature glyph replaces a
              string of separate glyphs (see Figure 6). When a string
              of glyphs can be replaced with a single ligature glyph,
              the first glyph is substituted with the ligature. The
              remaining glyphs in the string are deleted, this
              includes those glyphs that are skipped as a result of
              lookup flags.</para>

            <figure>
              <title>Figure 6. Three Arabic glyphs and their
                associated ligature glyph</title>
              <mediaobject>
                <imageobject>
                  <imagedata fileref="../../fig3f.gif"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>

          <listitem>
            <para><emphasis>Contextual substitution</emphasis>, the
              most powerful type, describes glyph substitutions in
              context – that is, a substitution of one or more glyphs
              within a certain pattern of glyphs. Each substitution
              describes one or more input glyph sequences and one or
              more substitutions to be performed on that sequence.
              Contextual substitutions can be applied to specific
              glyph sequences, glyph classes, or sets of
              glyphs.</para>
          </listitem>

          <listitem>
            <para><emphasis>Chaining contextual
                substitution</emphasis>, extends the capabilities of
              contextual substitution. With this, one or more
              substitutions can be performed on one or more glyphs
              within a pattern of glyphs (input sequence), by chaining
              the input sequence to a 'backtrack' and/or 'lookahead'
              sequence. Each such substitution can be applied in three
              formats to handle glyphs, glyph classes or glyph sets in
              the input sequence. Each of these formats can describe
              one or more of the backtrack, input and lookahead
              sequences.</para>
          </listitem>

	  <listitem>
	    <para><emphasis>Reverse Chaining contextual single
		substitution</emphasis>, allows one glyph to be
		substituted with another by chaining input glyph to a
		backtrack and/or lookahead sequence. The
		difference between this and other lookup types is that
		processing of input glyph sequence goes from end to
		start.</para>
	  </listitem>
        </itemizedlist>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>The model presented in the first paragraph is too
          restrictive; it suggests that only glyphs which are the
          target of cmap tables can be substituted. The proposed
          change is replace the second sentence by: &quot;After characters
          have been mapped to glyphs through the cmap table, the glyph
          run are modified using data in the GSUB table.&quot;</para>

        <para>After the list of supported glyph substitutions, it may
          be worth adding a paragraph: &quot;A seventh type of glyph
          substitution (<emphasis>extension substitution</emphasis>)
          does not increase the functionality but is sometimes
          necessary for large GSUB tables.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Table Organization</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The <ottable>GSUB</ottable> table begins with a header
          that defines offsets to a ScriptList, a FeatureList, and a
          LookupList (see Figure 3g):</para>

        <itemizedlist>
          <listitem>
            <para>The ScriptList identifies all the scripts and
              language systems in the font that use glyph
              substitutes.</para>
          </listitem>
          <listitem>
            <para>The FeatureList defines all the glyph substitution
              features required to render these scripts and language
              systems.</para>
          </listitem>
          <listitem>
            <para>The LookupList contains all the lookup data needed
              to implement each glyph substitution feature.</para>
          </listitem>
        </itemizedlist>

        <para>For a detailed discussion of ScriptLists, FeatureLists,
          and LookupLists, see the chapter Common Table Formats</para>

        <figure>
          <title>Figure 7. High-level organization of <ottable>GSUB</ottable>
          table</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../../fig3g.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>This organization helps text-processing clients to
          easily locate the features and lookups that apply to a
          particular script or language system. To access <ottable>GSUB</ottable>
          information, clients should use the following
          procedure:</para>

        <orderedlist>
          <listitem>
            <para>Locate the current script in the
              <ottable>GSUB</ottable> ScriptList table.</para>
          </listitem>
          <listitem>
            <para>If the language system is known, search the script
              for the correct LangSys table; otherwise, use the
              script's default language system (DefaultLangSys
              table).</para>
          </listitem>
          <listitem>
            <para>The LangSys table provides index numbers into the
              <ottable>GSUB</ottable> FeatureList table to access a
              required feature and a number of additional
              features.</para>
          </listitem>
          <listitem>
            <para>Inspect the FeatureTag of each feature, and select
              the features to apply to an input glyph string. Each
              feature provides an array of index numbers into the
              <ottable>GSUB</ottable> LookupList table.</para>
          </listitem>
          <listitem>
            <para>Assemble all lookups from the set of chosen
              features, and apply the lookups in the order given in
              the LookupList table.</para>
          </listitem>
        </orderedlist>

        <para>Lookup data is defined in one or more subtables that
          define the specific conditions, type, and results of a
          substitution action used to implement a feature. All
          subtables in a lookup must be of the same LookupType, as
          listed in the LookupType Enumeration table:</para>

        <table>
          <title>LookupType Enumeration table for glyph
            substitution</title>

          <tgroup cols="3">
            <colspec colwidth="3pc"/>
            <colspec colwidth="11pc"/>
            <colspec colwidth="16pc"/>
            <thead>
              <row>
                <entry>Value</entry>
                <entry>Type</entry>
                <entry>Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>1</entry>
                <entry>Single</entry>
                <entry>Replace one glyph with one glyph </entry>
              </row>

              <row>
                <entry>2</entry>
                <entry>Multiple</entry>
                <entry>Replace one glyph with more than one
                  glyph</entry>
              </row>

              <row>
                <entry>3</entry>
                <entry>Alternate</entry>
                <entry>Replace one glyph with one of many
                  glyphs</entry>
              </row>

              <row>
                <entry>4</entry>
                <entry>Ligature</entry>
                <entry>Replace multiple glyphs with one glyph</entry>
              </row>

              <row>
                <entry>5</entry>
                <entry>Context</entry>
                <entry>Replace one or more glyphs in context</entry>
              </row>

              <row>
                <entry>6</entry>
                <entry>Chaining Context</entry>
                <entry>Replace one or more glyphs in chained
                  context</entry>
              </row>
              <row>
                <entry>7</entry>
                <entry>Extension Substitution</entry>
                <entry>Extension mechanism for other substitutions
                  (i.e. this excludes the Extension type substitution
                  itself)</entry>
              </row>
	      <row>
		<entry>8</entry>
		<entry>Reverse chaining context single</entry>
		<entry>Applied in reverse order, replace single glyph
		in chaining context</entry>
	      </row>
              <row>
                <entry>9+</entry>
                <entry>Reserved</entry>
                <entry>For future use</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <para>Each LookupType subtable has one or more formats. The
          &quot;best&quot; format depends on the type of substitution and the
          resulting storage efficiency. When glyph information is best
          presented in more than one format, a single lookup may
          define more than one subtable, as long as all the subtables
          are for the same LookupType. For example, within a given
          lookup, a glyph index array format may best represent one
          set of target glyphs, whereas a glyph index range format may
          be better for another set.</para>

        <para>A series of substitution operations on the same glyph or
          string requires multiple lookups, one for each separate
          action. Each lookup is given a different array number in the
          LookupList table and is applied in the LookupList
          order.</para>

        <para>During text processing, a client applies a lookup to
          each glyph in the string before moving to the next lookup. A
          lookup is finished for a glyph after the client locates the
          target glyph or glyph context and performs a substitution,
          if specified. To move to the &quot;next&quot; glyph, the client will
          typically skip all the glyphs that participated in the
          lookup operation: glyphs that were substituted as well as
          any other glyphs that formed a context for the
          operation.</para>

        <para>In the case of chained contextual lookups, glyphs
          comprising backtrack and lookahead sequences may participate
          in more than one context.</para>

        <para>The rest of this chapter describes the
          <ottable>GSUB</ottable> header and the subtables defined for
          each <ottable>GSUB</ottable> LookupType. Examples at the end
          of this page illustrate each of the five LookupTypes,
          including the three formats available for contextual
          substitutions.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>Last sentence: the occurrence of 'five' should be
          replaced by 'seven'.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>GSUB lookup types</code-title>
  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { &quot;1&quot; | &quot;singleSubst&quot; },
    element singleSubst { singleSubstTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { &quot;2&quot; | &quot;multipleSubst&quot; },
    element multipleSubst { multipleSubstTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { &quot;3&quot; | &quot;alternateSubst&quot; },
    element alternateSubst { alternateSubstTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { &quot;4&quot; | &quot;ligatureSubst&quot; },
    element ligatureSubst { ligatureSubstTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { &quot;5&quot; | &quot;contextual&quot; },
    element contextual { contextualTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { &quot;6&quot; | &quot;chainingContextual&quot; },
    element chainingContextual { chainingContextualTableOffset }*

  GSUBlookupTable |=
    lookupTableCommonAttributes,
    attribute type { &quot;7&quot; | &quot;extensionSubst&quot; },
    element extensionSubst { extensionTableOffset }*
</code-fragment>
      </section>

    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>GSUB header</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The <ottable>GSUB</ottable> table begins with a header
          that contains a version number for the table (Version) and
          offsets to a three tables: ScriptList, FeatureList, and
          LookupList. For descriptions of each of these tables, see
          the chapter, Common Table Formats. Example 1 at the end of
          this chapter shows a <ottable>GSUB</ottable> Header table
          definition.</para>

        <otformat>
          <title>GSUB Header</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Version</otfieldname>
            <otfielddesc>Version of the <ottable>GSUB</ottable>
              table – initially set to 0x00010000</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ScriptList</otfieldname>
            <otfielddesc>Offset to ScriptList table – from beginning of
              <ottable>GSUB</ottable> table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>FeatureList</otfieldname>
            <otfielddesc>Offset to FeatureList table – from beginning of
              <ottable>GSUB</ottable> table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LookupList</otfieldname>
            <otfielddesc>Offset to LookupList table – from beginning of
              <ottable>GSUB</ottable> table</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>There is a typo in the first sentence &quot;... to a three
          tables:...&quot;</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>GSUB table</code-title>
GSUB =
  element GSUB {
    attribute major { &quot;1&quot; },
    attribute minor { &quot;0&quot; },
    element scriptList { scriptListTableOffset },
    element featureList { featureListTableOffset },
    element lookupList { GSUBlookupListTableOffset },

    (  standaloneScriptListTable
     | standaloneScriptTable
     | standaloneLangSysTable
     | standaloneFeatureListTable
     | standaloneFeatureTable
     | standaloneGSUBLookupListTable
     | standaloneGSUBLookupTable
     | standaloneSingleSubstTable
     | standaloneMultipleSubstTable
     | standaloneAlternateSubstTable
     | standaloneLigatureSubstTable
     | standaloneContextualTable
     | standaloneChainingContextualTable
     | standaloneExtensionTable
     | standaloneCoverageTable
     | standaloneClassDefTable
     | standaloneDeviceTable)*
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="gsub.methods">
  public void fromXML (Element t)
      throws InvalidFontException, UnsupportedFontException {

    Map&lt;Element, Block&gt; blockCache = new HashMap&lt;Element, Block&gt; ();
    NodeList l = t.getChildNodes ();

    Block me = new Block (10, 3);
    me.setFixed (0, 1, 0);

    Map&lt;String, Integer&gt; lookupIndices = new HashMap&lt;String, Integer&gt; ();
    Block b1 = lookupListTableFromXML ((Element) l.item (2),
                                       t, blockCache,
                                       lookupIndices);

    Map&lt;String, Integer&gt; featureIndices = new HashMap&lt;String, Integer&gt; ();
    Block b2 = featureListTableFromXML ((Element) l.item (1),
                                        t, blockCache,
                                        lookupIndices, featureIndices);

    Block b3 = scriptListTableFromXML ((Element) l.item (0),
                                       t, blockCache,
                                       featureIndices);

    me.setOffset (4, b3);
    me.setOffset (6, b2);
    me.setOffset (8, b1);
    data = me.serialize ();
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="gsub.methods">
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException, InvalidFontException {

    int [] counts = new int [data.length];
    for (int i = 0; i &lt; counts.length; i++) {
      counts [i] = 0; }

    scriptListTableToXMLCount (getOffset (4), counts);
    featureListTableToXMLCount (getOffset (6), counts);
    lookupListTableToXMLCount (getOffset (8), counts);

    if (conf.pointers == DecompilerConfig.PointersAreShown.never) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 1; }}
    if (conf.pointers == DecompilerConfig.PointersAreShown.always) {
      for (int i = 0; i &lt; counts.length; i++) {
        counts [i] = 2; }}
    AttributesImpl at;

    int [] version = getTableVersion ();
    at = new AttributesImpl ();
    at.addAttribute (&quot;&quot;, &quot;major&quot;, &quot;major&quot;, &quot;CDATA&quot;, &quot;&quot; + version [0]);
    at.addAttribute (&quot;&quot;, &quot;minor&quot;, &quot;minor&quot;, &quot;CDATA&quot;, &quot;&quot; + version [1]);

    conf.ch.startElement (&quot;GSUB&quot;, at); {

      scriptListTableOffsetToXML (conf, getOffset (4), counts,
                                  &quot;scriptList&quot;, new AttributesImpl ());
      featureListTableOffsetToXML (conf, getOffset (6), counts,
                                   &quot;featureList&quot;, new AttributesImpl ());
      lookupListTableOffsetToXML (conf, getOffset (8), counts,
                                  &quot;lookupList&quot;, new AttributesImpl ());

      scriptListTableToXML (conf, getOffset (4), counts);
      featureListTableToXML (conf, getOffset (6), counts);
      lookupListTableToXML (conf, getOffset (8), counts);
      conf.ch.endElement (&quot;GSUB&quot;); }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>We have a class that represents a
          <ottable>GSUB</ottable> table and provides the appropriate
          operations.</para>

<code-fragment package="com.adobe.aots.CommonType" class="Gsub">
  <code-title>GSUB Class</code-title>
package com.adobe.aots.CommonType;

import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Gsub extends LookupTable {

  <code-include linkend="gsub_globals_1"/>

  public Gsub () {
    super (Tag.GSUB, null);
  }

  public Gsub (Font font) {
    super (Tag.GSUB, font);
  }

  public int[] getTableVersion () {
    return getFixed (0);
  }

  <code-include linkend="gsub.methods" title="GSUB methods"/>
}
</code-fragment>

        <para>The base class of Gsub defines a number of abstract
          methods to access the ScriptList, the FeatureList and the
          LookupList:</para>

<code-fragment id="gsub.methods">
  <code-title>Methods to find ScriptList, FeatureList and LookupList</code-title>
  int getScriptListOffset () {
    return getOffset (4);
  }

  int getFeatureListOffset () {
    return getOffset (6);
  }

  int getLookupListOffset () {
    return getOffset (8);
  }
</code-fragment>

        <para>The most basic operation is to apply a given lookup
          subtable to a given position in a glyph run. This method
          returns -1 if the subtable does not apply (i.e. its context
          pattern does not match the glyph run), or the position of
          first glyph following context pattern match.</para>

<code-fragment id="gsub.methods">
  <code-title>Method to apply a GSUB subtable to a glyph</code-title>
  public LookupResult applyLookupSubtable (int lookupIndex, int lookupType, int lookupFlag,
                                int stOffset, GlyphRun gr, int curGlyph)
    throws InvalidFontException {

    switch (lookupType) {
      case 1: { <code-include linkend="gsub_1"/> }
      case 2: { <code-include linkend="gsub_2"/> }
      case 3: { <code-include linkend="gsub_3"/> }
      case 4: { <code-include linkend="gsub_4"/> }
      case 5: { return applyContextualLookupSubtable
                    (lookupIndex, lookupType, lookupFlag,
		     stOffset, gr, curGlyph); }
      case 6: { return applyChainingContextualLookupSubtable
                    (lookupIndex, lookupType, lookupFlag,
		     stOffset, gr, curGlyph); }
      case 7: { return applyExtensionLookupSubtable
                    (lookupIndex, lookupType, lookupFlag,
		     stOffset, gr, curGlyph); }
      default: {
        throw new InvalidFontException (&quot;GSUB -&quot; + lookupType + &quot;-&quot;); }}
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Test Suite</title>


        <para>Our test framework for <ottable>GSUB</ottable>
          transformations is to apply a set of features to a glyphrun
          tagged with a script and a language.</para>

<code-fragment package="com.adobe.aots.CommonType" class="GsubTester">
  <code-title>GsubTest class</code-title>
  package com.adobe.aots.CommonType;

  <code-include linkend="test_imports"/>

  public class GsubTester {

    <code-include linkend="test_methods"/>

    public static void main (String[] args) {
      try {
        String testName = &quot;anonymousTest&quot;;
	URL fontURL = null;
	Font font = null;
	long script = Tag.string2tag (&quot;latn&quot;);
	long language = Tag.string2tag (&quot;DFLT&quot;);
	long[] features = null;
        int[] inputs = null;
	int[] expected = null;
	int traceDepth = 3;
	String svgTraceOutput = null;
	String textTraceOutput = null;

        for (int i = 0; i &lt; args.length; i++) {
          if (&quot;-testname&quot;.equals (args [i])) {
	    i++;
	    testName = args [i]; }

	  if (&quot;-font&quot;.equals (args [i])) {
	    i++;
	    fontURL = new File (args [i]).getAbsoluteFile ().toURL ();
	    font = new Font ();
	    font.fromBinary (fontURL); }

	  if (&quot;-script&quot;.equals (args [i])) {
	    i++;
	    script = Tag.string2tag (args [i]); }

	  if (&quot;-language&quot;.equals (args [i])) {
	    i++;
	    language = Tag.string2tag (args [i]); }

	  if (&quot;-features&quot;.equals (args [i])) {
	    i++;
	    features = Tag.string2tags (args [i]); }

	  if (&quot;-glyphs&quot;.equals (args [i])) {
	    i++;
	    inputs = parseIntList (args [i]); }

	  if (&quot;-expected&quot;.equals (args [i])) {
	    i++;
	    expected = parseIntList (args [i]); }

	  if (&quot;-tracedepth&quot;.equals (args [i])) {
	    i++;
	    traceDepth = Integer.parseInt (args [i]); }

	  if (&quot;-trace=svg&quot;.equals (args [i])) {
	    i++;
	    svgTraceOutput = args [i]; }

	  if (&quot;-trace=text&quot;.equals (args [i])) {
	    i++;
	    textTraceOutput = args [i]; }}

        LookupTableListener listener = null;
        if (svgTraceOutput != null) {
          SVGLookupTableListener l = new SVGLookupTableListener (traceDepth);
          java.io.PrintStream out
            = new java.io.PrintStream (new java.io.FileOutputStream (svgTraceOutput));
          l.init (font, fontURL, out, false, false);
          font.gsub.setLookupTableListener (l);
          listener = l; }
        else if (textTraceOutput != null) {
          LookupTableListener l = new TextLookupTableListener (traceDepth);
          java.io.PrintStream out
            = new java.io.PrintStream (new java.io.FileOutputStream (textTraceOutput));
          l.init (font, fontURL, out, false);
          font.gsub.setLookupTableListener (l);
          listener = l; }

        GlyphRunImpl gr = new GlyphRunImpl ();
        gr.glyphs = inputs;
        gr.totGlyphs = inputs.length;

        font.gsub.applyFeatures (script, language, features, gr);

        if (listener != null) {
          listener.shutdown (); }

        if (expected != null) {
          boolean pass = compareIntLists (expected, gr.glyphs, gr.glyphCount ()) ;
          if (pass == false) {
            System.err.print (&quot;Wanted: &quot;);
            for (int i = 0; i &lt; expected.length; i++) {
              System.err.print (&quot; &quot; + expected [i]); }
            System.err.println ();
            System.err.print (&quot;Actual: &quot;);
            for (int i = 0; i &lt; gr.glyphCount (); i++) {
              System.err.print (&quot; &quot; + gr.glyphs [i]); }
            System.err.println (); }

          reportStatus (testName, pass); }}

      catch (Exception e) {
        System.out.println (&quot;Exception: &quot; + e.getMessage ());
        e.printStackTrace (); }
    }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="validation">
        <title>Validation</title>

        <code-fragment id="gsub.methods">
          <code-title>GSUB Validation Method</code-title> public void
          validate () { }
        </code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Lookup Type 1: Single Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Single substitution (SingleSubst) subtables tell a
          client to replace a single glyph with another glyph. The
          subtables can be either of two formats. Both formats require
          two distinct sets of glyph indices: one that defines input
          glyphs (specified in the Coverage table), and one that
          defines the output glyphs. Format 1 requires less space than
          Format 2, but it is less flexible.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

	<para>None.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

	<para>Our generic format for single substitions describes the mapping one  substitution at a time.</para>

<code-fragment id="schema">
  <code-title>singleSubstTable</code-title>
  singleSubstTable |=
    attribute format { &quot;any&quot; },
    element subst {
      attribute in { text },
      attribute out { text }
    }*

  standaloneSingleSubstTable =
    element singleSubstTable { attribute id { text }, singleSubstTable }

  singleSubstTableOffset = attribute name { text } | singleSubstTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

        <para>A single substitution represented as a sequence of
        <sgmltag>subst</sgmltag> elements is equivalent to a single
        single substitution represented with single format 2 subtable,
        with those substs as its children.</para>

<code-fragment id="gsub.methods">
  <code-title>Compile GSUB 1 subtable</code-title>
  private Block singleSubstLookupFromXML (Element lookupSubtable,
                                          Element table,
                                          Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    String format = lookupSubtable.getAttribute (&quot;format&quot;);
    if (&quot;1&quot;.equals (format)) {
      return singleSubstFormat1FromXML (lookupSubtable, table, blockCache); }
    if (&quot;2&quot;.equals (format) || &quot;any&quot;.equals (format)) {
      return singleSubstFormat2FromXML (lookupSubtable, table, blockCache); }

    /*cannot get here with valid instance*/
    throw new InvalidFontException (
      &quot;invalid single substitution format (&quot; + format + &quot;)&quot;);
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="gsub.toXMLCount_1">
  <code-title>Count references for GSUB 1 subtable</code-title>
  switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend="gsub.toXMLCount_1_1"/>; break; }
    case 2: { <code-include linkend="gsub.toXMLCount_1_2"/>; break; }}
</code-fragment>

<code-fragment id="gsub.toXML_1">
  <code-title>Emit references for GSUB 1 subtable</code-title>
  switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend="gsub.toXML_1_1"/>; break; }
    case 2: { <code-include linkend="gsub.toXML_1_2"/>; break; }}
</code-fragment>

<code-fragment id="gsub.toXMLEmit_1">
  <code-title>Emit GSUB 1 subtable</code-title>
  switch (getuint16 (stOffset)) {
    case 1: { <code-include linkend="gsub.toXMLEmit_1_1"/>; break; }
    case 2: { <code-include linkend="gsub.toXMLEmit_1_2"/>; break; }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>Both subtable formats start with the same field, the
          uint16 SubstFormat, so that we can distinguish them.</para>

<code-fragment id="gsub_1">
  <code-title>Execute GSUB 1 subtable and return</code-title>
  { int substFormat = getuint16 (stOffset);
    switch (substFormat) {
      case 1: { <code-include linkend="gsub_1_1"/> }
      case 2: { <code-include linkend="gsub_1_2"/> }
      default: {
        throw new InvalidFontException (&quot;GSUB 1/-&quot; + substFormat + &quot;-&quot;); }}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="validation">
        <title>Validation</title>

<code-fragment id="validate_gsub_1">
  <code-title>GSUB 1 subtable validation</code-title>
  ensureAvailableBytes (gsub, 0, 2);
  int substFormat = getuint16 (stOffset);
  switch (substFormat) {
    case 1: { <code-include linkend="validate_gsub_1_1"/>; break; }
    case 2: { <code-include linkend="validate_gsub_1_2"/>; break; }
    default: reportError (&quot;GSUB Subtable at offset &quot; + stOffset
                          + &quot; has an invalid SubstFormat (&quot;
                          + substFormat + &quot;)&quot;); }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Single Substitution Format 1</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Format 1 calculates the indices of the output glyphs,
          which are not explicitly defined in the subtable. To
          calculate an output glyph index, Format 1 adds a constant
          delta value to the input glyph index. For the substitutions
          to occur properly, the glyph indices in the input and output
          ranges must be in the same order. This format does not use
          the Coverage Index that is returned from the Coverage
          table.</para>

        <para>The SingleSubstFormat1 subtable begins with a format
          identifier (SubstFormat) of 1. An offset references a
          Coverage table that specifies the indices of the input
          glyphs. DeltaGlyphID is the constant value added to each
          input glyph index to calculate the index of the
          corresponding output glyph.</para>

        <para>Example 2 at the end of this chapter uses Format 1 to
          replace standard numerals with lining numerals.</para>

        <otformat>
          <title>SingleSubstFormat1 subtable: Calculated output glyph
            indices</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table – from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>int16</otfieldtype>
            <otfieldname>DeltaGlyphID</otfieldname>
            <otfielddesc>Add to original GlyphID to get substitute
              GlyphID</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>I cannot figure out what the third sentence of the first
          paragraph really says. It it phrased as a requirement on the
          way the lookup is built, yet it seems to describe a property
          that follows from the nature of GSUB 1/1
          lookups. Recommendation: remove it for the
          specification.</para>

        <para>In the spirit of cmaps subtable format 4, the arithmetic
          on the glyph index should probably be performed modulo
          65536. Recommendation: make that explicit.</para>

	<para>The pattern matched by this subtable is ▶ C
	  ◀ where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage ∖ LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to replace the glyph
	  matched by C; if the id of that glyph is g, then the
	  replacement glyph has id (g+DeltaGlyphId) % 0xffff.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Single substitution format 1 type</code-title>
  singleSubstTable |=
    attribute format { &quot;1&quot; },
    element coverage { coverageTableOffset },
    element delta {
      attribute v { text }
    }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="gsub.methods">
  <code-title>Compile GSUB 1/1 subtable</code-title>
  private Block singleSubstFormat1FromXML (Element subtable, Element table,
                                           Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Element coverageNode = (Element)subtable.getFirstChild ();
    Element deltaNode = (Element) coverageNode.getNextSibling ();
    String deltaValue = deltaNode.getAttribute (&quot;v&quot;);

    Block coverage = coverageFromXML (coverageNode, table, blockCache);
    int delta = Integer.parseInt (deltaValue);

    Block me = new Block (6, 1);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setint16  (4, delta);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="gsub.toXMLCount_1_1">
  <code-title>Count references for GSUB 1/1 subtable</code-title>
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id="gsub.toXML_1_1">
  <code-title>Emit references for GSUB 1/1 subtable</code-title>
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id="gsub.toXMLEmit_1_1">
  <code-title>Emit GSUB 1/1 subtable</code-title>
  int coverageOffset = stOffset + getOffset (stOffset + 2);

  at = new AttributesImpl ();
  coverageTableOffsetToXML (conf, coverageOffset, counts, &quot;coverage&quot;, at);

  at = new AttributesImpl ();
  at.addAttribute (&quot;&quot;, &quot;v&quot;, &quot;v&quot;, &quot;CDATA&quot;, &quot;&quot; + getint16 (stOffset + 4));
  conf.ch.element (&quot;delta&quot;, at);
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="gsub_1_1">
  <code-title>Execute GSUB 1/1 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    if (getCoverageIndex (gr.glyphAt (inPos), coverageOffset) == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int deltaGlyphId = getint16 (stOffset + 4);
    int newGlyphId = (gr.glyphAt (inPos) + deltaGlyphId) &amp; 0xffff;
    if (listener != null) {
      listener.replace (gr.glyphAt (inPos), newGlyphId);
      listener.applyingSubtable (lookupIndex, gr, curGlyph, &quot;GSUB&quot;, stOffset); }
    gr.replace (inPos, newGlyphId);

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Test Suite</title>

	<section>
	  <title>gsub1_1_simple</title>

	  <para>Our first test is fairly simple. It translates glyphs 18
	  and 19 by 5, to get glyphs 23 and 24:</para>

<aots:test-font id="gsub1_1_simple_f1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>

    <lookupList>
      <lookup id="lookup.test" type="1">
	<singleSubst format="1">
	  <coverage glyphs="18 19" format="any"/>
	  <delta v="5"/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub1_1_simple_t1" font="gsub1_1_simple_f1" inputs="17, 18, 19, 20, 21" outputs="17, 23, 24, 20, 21"/>
	</section>

	<section>
	  <title>gsub1_1_lookupflag</title>

	  <para>Our second test case exercises LookupFlag. The trick
	  to have a glyph which is both in the collection defined by
	  LookupFlag and transformed. Since LookupFlag takes
	  precedence over Coverage, the glyph should not be
	  transformed. In addition, looking at the step by step
	  execution of the lookup over the glyphrun, one should see
	  that there is a single lookup application for this glyph and
	  the next glyph (which is transformed). While the font may
	  seem at first improperly built, it could be that the
	  Coverage is shared with another table.</para>

<aots:test-font id="gsub1_1_lookupflag_f1">
  <base-font name="base.otf"/>
  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
      <class classID="1" glyphs="18"/>
    </glyphClassDef>
  </GDEF>

  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs="yes" type="1">
	<singleSubst format="1">
	  <coverage glyphs="18 19" format="any"/>
	  <delta v="5"/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub1_1_lookupflag_t1" font="gsub1_1_lookupflag_f1" inputs="17, 18, 19, 20, 21" outputs="17, 18, 24, 20, 21"/>
	</section>

	<section>
	  <title>gsub1_1_modulo</title>

	  <para>An interesting test case involves exercising the
	  &quot;modulo&quot; nature of the glyph computation, since it is not
          explicit in the specification. In a modulo arithmetic
          system, there are two cases to consider: when the sum of two
          numbers goes over the base (overflow); and when the sum of
          two (signed) numbers goes below 0 (underflow). Our test font
          includes one feature, with two lookups and all their
          subtables in format 1</para>

	  <para>The behaviour of the test feature is:</para>

	  <table>
	    <title>Test feature</title>

	    <tgroup cols="5">
	      <colspec colwidth="3cm"/>
	      <colspec colwidth="3cm"/>
	      <colspec colwidth="3cm"/>
	      <colspec colwidth="3cm"/>
	      <colspec colwidth="3cm"/>
	      <thead>
		<row>
		  <entry>Input glyph</entry>
		  <entry>Lookup 1</entry>
		  <entry>Intermediate glyph</entry>
		  <entry>Lookup 2</entry>
		  <entry>Output glyph</entry>
		</row>
	      </thead>
	      <tbody>
              <row>
		<entry>21</entry>
		<entry>subtable 1: +32766</entry>
		<entry>32787</entry>
		<entry>subtable 3: -32764</entry>
		<entry>23</entry>
		</row>
		<row>
		  <entry>22</entry>
		  <entry>subtable 1: +32766</entry>
		  <entry>32788</entry>
		  <entry>subtable 4: +32766 (overflow)</entry>
		  <entry>18</entry>
		</row>
		<row>
		  <entry>19</entry>
		  <entry>subtable 2: -32766 (underflow)</entry>
		  <entry>32789</entry>
		  <entry>subtable 5: +32764 (overflow)</entry>
		  <entry>17</entry>
		</row>
		<row>
		  <entry>20</entry>
		  <entry>subtable 2: -32766 (underflow)</entry>
		  <entry>32790</entry>
		  <entry>subtable 6: -32766</entry>
		  <entry>24</entry>
		</row>
		<row>
		  <entry>anything else</entry>
		  <entry>unchanged</entry>
		  <entry/>
		  <entry/>
		  <entry/>
		</row>
		<row>
		  <entry/>
		  <entry/>
		  <entry>anything else</entry>
		  <entry>unchanged</entry>
		  <entry/>
		</row>
	      </tbody>
	    </tgroup>
	  </table>

	  <para>This test case is a bit contrived, because the base font
          on which we apply it does not have pairs of glyphs such that
          one can be reached from the other via a legal DeltaGlyphID
          value involving an overflow or underflow. Instead, we do
          that in two steps (hence the two lookups). The intermediate
          glyph is not in the font, but the first and third
          transformations above help us validate that the program
          under test does not care about that.</para>

<aots:test-font id="gsub1_1_modulo_f1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <scriptList>
      <script tag="latn">
	<defaultLangSys>
	  <featureIndex name="feature.test"/>
	</defaultLangSys>
      </script>
    </scriptList>

    <featureList>
      <feature id="feature.test" tag="test">
	<lookupIndex name="lookup.test.1"/>
	<lookupIndex name="lookup.test.2"/>
      </feature>
    </featureList>

    <lookupList>
      <lookup id="lookup.test.1" type="1">
	<singleSubst format="1">
	  <coverage glyphs="21 22" format="any"/>
	  <delta v="32766"/>
	</singleSubst>
	<singleSubst format="1">
	  <coverage glyphs="19 20" format="any"/>
	  <delta v="-32766"/>
	</singleSubst>
      </lookup>

      <lookup id="lookup.test.2" type="1">
	<singleSubst format="1">
	  <coverage glyphs="32787" format="any"/>
	  <delta v="-32764"/>
	</singleSubst>
	<singleSubst format="1">
	  <coverage glyphs="32788" format="any"/>
	  <delta v="32766"/>
	</singleSubst>
	<singleSubst format="1">
	  <coverage glyphs="32789" format="any"/>
	  <delta v="32764"/>
	</singleSubst>
	<singleSubst format="1">
	  <coverage glyphs="32790" format="any"/>
	  <delta v="-32766"/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub1_1_modulo_t1" font="gsub1_1_modulo_f1" inputs="17, 18, 19, 20, 21, 22, 23, 24" outputs="17, 18, 17, 24, 23, 18, 23, 24"/>

	  <para>Translated to characters (for use with InDesign), the
          string &quot;0123456789&quot; gets translated to &quot;0107616789&quot;.</para>

	</section>
      </section>

      <!--____________________________________________________________________-->
      <section role="validation">
        <title>Validation</title>

        <para>Remembering our general discussion of lookupFlag
          [insert link here], we have a warning-level message if the
          coverage table includes any glyph that is also covered by
          lookupFlag.</para>

<code-fragment id="validate_gsub_1_1">
  <code-title>Validate GSUB 1/1 subtable</code-title>
  ensureAvailableBytes (stOffset, 6);
  markByteRange (stOffset, 6, FRAGMENT_TYPE_GSUB_1_1);
  int coverageOffset = stOffset + getuint16 (stOffset + 2);
  validateCoverageTable (coverageOffset);
  warnIfCoverageOverlapsLookupFlag (lookupFlag, gsub, coverageOffset);
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Single Substitution Format 2</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Format 2 is more flexible than Format 1, but requires
          more space. It provides an array of output glyph indices
          (Substitute) explicitly matched to the input glyph indices
          specified in the Coverage table.</para>

        <para>The SingleSubstFormat2 subtable specifies a format
          identifier (SubstFormat), an offset to a Coverage table that
          defines the input glyph indices, a count of output glyph
          indices in the Substitute array (GlyphCount), and a list of
          the output glyph indices in the Substitute array
          (Substitute).</para>

        <para>The Substitute array must contain the same number of
          glyph indices as the Coverage table. To locate the
          corresponding output glyph index in the Substitute array,
          this format uses the Coverage Index returned from the
          Coverage table.</para>

        <para>Example 3 at the end of this chapter uses Format 2 to
          substitute vertically oriented glyphs for horizontally
          oriented glyphs.</para>

        <otformat>
          <title>SingleSubstFormat2 subtable: Specified output glyph
            indices</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table – from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of GlyphIDs in the Substitute
              array</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Substitute [GlyphCount]</otfieldname>
            <otfielddesc>Array of substitute GlyphIDs – ordered by
              Coverage Index</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>To adopt a consistent language, the third paragraph should
          be changed to &quot;The Coverage index of the input glyph is used to
          index the Susbtitute array and GlyphCount must equal the number of
          covered glyphs.&quot;</para>

	<para>The pattern matched by this subtable is ▶ C
	  ◀ where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage ∖ LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to replace the glyph
	  matched by C by the corresponding glyph in the Substitute
	  array.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Single substitution format 2 type</code-title>
  singleSubstTable |=
    attribute format { &quot;2&quot; },
    element coverage { coverageTableOffset }?,
    element subst {
      attribute in { text },
      attribute out { text }
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="gsub.methods">
  private Block singleSubstFormat2FromXML (Element subtable, Element table,
                                           Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if (! &quot;coverage&quot;.equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (subtable.getChildNodes (), &quot;in&quot;); }
    else {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    int[] replacement = new int [coverage.glyphs.length];
    for (int i = 0; i &lt; replacement.length; i++) {
      replacement [i] = -1; }

    NodeList children = subtable.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element subst = (Element) children.item (i);
      int[] in = getGlyphs (subst.getAttribute (&quot;in&quot;));
      int[] out = getGlyphs (subst.getAttribute (&quot;out&quot;));

      if (in.length != 1) {
        warning (&quot;subst in singleSubstFormat2 must have 'in' attribute &quot;
                 + &quot; with exactly 1 glyph&quot;); }
      if (out.length != 1) {
        warning (&quot;subst in singleSubstFormat2 must have 'out' attribute &quot;
                 + &quot; with exactly 1 glyph&quot;); }

      boolean covered = false;
      for (int j = 0; j &lt; coverage.glyphs.length; j++) {
        if (in [0] == coverage.glyphs [j]) {
          replacement [j] = out [0];
          covered = true;
          break; }}

      if (covered == false) {
        warning (&quot;in glyph '&quot; + in [0]
                 + &quot;' must be covered in singleSubstFormat2&quot;); }}

    for (int j = 0; j &lt; replacement.length; j++) {
      if (replacement [j] == -1) {
        warning (&quot;covered glyph &quot; + coverage.glyphs [j]
                 + &quot; not replaced in singleSubstFormat1&quot;); }}

    me = new Block (6 + 2 * coverage.glyphs.length, 1);
    me.setuint16 (0, 2);
    me.setOffset (2, coverage);
    me.setint16  (4, coverage.glyphs.length);


    for (int i = 0; i &lt; replacement.length; i++) {
      me.setGlyphID (6 + 2*i, replacement [i]); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="gsub.toXMLCount_1_2">
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id="gsub.toXML_1_2">
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
</code-fragment>

<code-fragment id="gsub.toXMLEmit_1_2">
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int glyphCount = getuint16 (stOffset + 4);

    int [] glyphs = getCoveredGlyphs (coverageOffset);

    for (int i = 0; i &lt; glyphCount; i++) {
      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;in&quot;, &quot;in&quot;, &quot;CDATA&quot;,
                       glyphToXML (conf, glyphs [i]));
      at.addAttribute (&quot;&quot;, &quot;out&quot;, &quot;out&quot;, &quot;CDATA&quot;,
                       glyphToXML (conf, getuint16 (stOffset + 6 + 2*i)));
      conf.ch.element (&quot;subst&quot;, at); }
</code-fragment>
     </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="gsub_1_2">
  <code-title>Execute GSUB 1/2 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci  == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int oldGlyphId = gr.glyphAt (inPos);
    int newGlyphId = getGlyphID (stOffset + 6 + 2*ci);

    if (listener != null) {
      listener.replace (oldGlyphId, newGlyphId);
      listener.applyingSubtable (lookupIndex, gr, curGlyph, &quot;GSUB&quot;, stOffset); }

    gr.replace (inPos, newGlyphId);

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Test Suite</title>

        <section>
          <title>gsub1_2_simple</title>

          <para>A simple test to start. Glyph 18 has coverage index 0,
            and is replaced by glyph 22; glyph 20 has coverage index 1,
            and is replaced by glyph 25.</para>

<aots:test-font id="gsub1_2_simple_f1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>

    <lookupList>
      <lookup id="lookup.test" type="1">
	<singleSubst format="2">
	  <coverage glyphs="18 20" format="any"/>
	  <subst in="18" out="22"/>
	  <subst in="20" out="25"/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub1_2_simple_t1" font="gsub1_2_simple_f1" inputs="17, 18, 19, 20, 21" outputs="17, 22, 19, 25, 21"/>
        </section>

        <section>
          <title>gsub1_2_lookupflag</title>

          <para>Our second tests exercises LookupFlag, which captures
          glyph 18. In order to isolate the behaviour of LookupFlag,
          we need to make sure that glyph 18 is covered by the lookup
          itself.</para>

<aots:test-font id="gsub1_2_lookupflag_f1">
  <base-font name="base.otf"/>

  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
      <class classID="1" glyphs="18"/>
    </glyphClassDef>
  </GDEF>

  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs="yes" type="1">
	<singleSubst format="2">
	  <coverage glyphs="18 20" format="any"/>
	  <subst in="18" out="22"/>
	  <subst in="20" out="25"/>
	</singleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub1_2_lookupflag_t1" font="gsub1_2_lookupflag_f1" inputs="17, 18, 19, 20, 21" outputs="17, 18, 19, 25, 21"/>
        </section>

      </section>

      <!--____________________________________________________________________-->
      <section role="validation">
        <title>Validation</title>

<code-fragment id="validate_gsub_1_2">
  <code-title>Validate GSUB 1/2 subtable</code-title>
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>LookupType 2: Multiple Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>A Multiple Substitution (MultipleSubst) subtable
          replaces a single glyph with more than one glyph, as when
          multiple glyphs replace a single ligature. The subtable has
          a single format: MultipleSubstFormat1. The subtable
          specifies a format identifier (SubstFormat), an offset to a
          Coverage table that defines the input glyph indices, a count
          of offsets in the Sequence array (SequenceCount), and an
          array of offsets to Sequence tables that define the output
          glyph indices (Sequence). The Sequence table offsets are
          ordered by the Coverage Index of the input glyphs. </para>

        <para>For each input glyph listed in the Coverage table, a
          Sequence table defines the output glyphs. Each Sequence
          table contains a count of the glyphs in the output glyph
          sequence (GlyphCount) and an array of output glyph indices
          (Substitute).</para>

        <blockquote>
          <para>Note: The order of the output glyph indices depends on
            the writing direction of the text. For text written left
            to right, the left-most glyph will be first glyph in the
            sequence. Conversely, for text written right to left, the
            right-most glyph will be first. </para>
        </blockquote>

        <para>The use of multiple substitution for deletion of an
          input glyph is prohibited. GlyphCount should always be
          greater than 0.</para>

        <para>Example 4 at the end of this chapter shows how to
          replace a single ligature with three glyphs.</para>

        <otformat>
          <title>MultipleSubstFormat1 subtable: Multiple output glyphs</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table – from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SequenceCount</otfieldname>
            <otfielddesc>Number of Sequence table offsets in the
              Sequence array</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Sequence [SequenceCount]</otfieldname>
            <otfielddesc>Array of offsets to Sequence tables – from
              beginning of Substitution table – ordered by Coverage
              Index</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>Sequence table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of GlyphIDs in the Substitute array.
              This should always be greater than 0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Substitute [GlyphCount]</otfieldname>
            <otfielddesc>String of GlyphIDs to
              substitute</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>To adopt a consistent language, the last sentence of the
          first paragraph should be changed to: &quot;The Coverage index of
          the input glyph is used to index the Sequence array and
          SequenceCount must equal the number of covered glyphs. The
          entries in the Sequence array cannot be NULL.&quot;</para>

	<para>The pattern matched by this subtable is ▶ C
	  ◀ where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage ∖ LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to replace the glyph
	  matched by C by the Substitute sequence of glyphs in the
	  corresponding Sequence table, in the order in which they
	  appear in that array.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a multiple substitution, but instead
	  would prefer the compiler to figure out the best
	  representation.:</para>

<code-fragment id="schema">
  <code-title>MultipleSubst type</code-title>
  multipleSubstTable |=
    attribute format { &quot;1&quot; },
    element coverage { coverageTableOffset }?,
    element subst {
      attribute in { text },
      attribute out { text }
    }*

  standaloneMultipleSubstTable =
    element multipleSubstTable { attribute id { text }, multipleSubstTable }

  multipleSubstTableOffset = attribute name { text } | multipleSubstTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="gsub.methods">
  private Block multipleSubstFormat1FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if (&quot;coverage&quot;.equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }
    else {
      coverage = coverageFromXML (subtable.getChildNodes (), &quot;in&quot;); }


    int[][] replacement = new int [coverage.glyphs.length][];
    for (int i = 0; i &lt; replacement.length; i++) {
      replacement [i] = new int [0]; }

    NodeList children = subtable.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element subst = (Element) children.item (i);
      int[] in = getGlyphs (subst.getAttribute (&quot;in&quot;));
      int[] out = getGlyphs (subst.getAttribute (&quot;out&quot;));

      if (in.length != 1) {
        warning (&quot;subst in multipleSubstFormat1 must have 'in' attribute &quot;
                 + &quot; with exactly 1 glyph&quot;); }

      boolean covered = false;
      for (int j = 0; j &lt; coverage.glyphs.length; j++) {
        if (in [0] == coverage.glyphs [j]) {
          replacement [j] = out;
          covered = true;
          break; }}

      if (covered == false) {
        warning (&quot;in glyph '&quot; + in [0]
                 + &quot;' must be covered in multipleSubstFormat1&quot;); }}

    me = new Block (6 + 2 * coverage.glyphs.length, 1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setint16  (4, coverage.glyphs.length);

    for (int i = 0; i &lt; coverage.glyphs.length; i++) {
      Block sequenceTable = new Block (2 + 2 * replacement [i].length, 0);
      sequenceTable.setuint16 (0, replacement [i].length);
      for (int g = 0; g &lt; replacement [i].length; g++) {
        sequenceTable.setGlyphID (2 + 2*g, replacement [i][g]); }
      me.setOffset (6 + 2*i, sequenceTable); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="gsub.toXMLCount_2">
  /* nothing */
</code-fragment>

<code-fragment id="gsub.toXML_2">
  /* nothing */
</code-fragment>

<code-fragment id="gsub.toXMLEmit_2">
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int sequenceCount = getuint16 (stOffset + 4);

    int [] glyphs = getCoveredGlyphs (coverageOffset);

    for (int i = 0; i &lt; sequenceCount; i++) {
      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;in&quot;, &quot;in&quot;, &quot;CDATA&quot;,
                       glyphToXML (conf, glyphs [i]));

      int sequenceOffset = stOffset + getOffset (stOffset + 6 + 2*i);
      StringBuilder s = new StringBuilder ();
      for (int g = 0; g &lt; getuint16 (sequenceOffset); g++) {
        glyphToXML (conf, s, getuint16 (sequenceOffset + 2 + 2*g)); }
      at.addAttribute (&quot;&quot;, &quot;out&quot;, &quot;out&quot;, &quot;CDATA&quot;, s.toString ());
      conf.ch.element (&quot;subst&quot;, at); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="gsub_2">
  <code-title>Execute GSUB 2 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int sequenceOffset = stOffset + getOffset (stOffset + 6 + 2*ci);
    int oldGlyphId = gr.glyphAt (inPos);
    int glyphCount = getuint16 (sequenceOffset);
    int [] newGlyphIds = new int [glyphCount];
    for (int g = 0; g &lt; glyphCount; g++) {
      newGlyphIds [g] = getGlyphID (sequenceOffset + 2 +  2*g); }

    if (listener != null) {
      listener.replace (oldGlyphId, newGlyphIds);
      listener.applyingSubtable (lookupIndex, gr, curGlyph, &quot;GSUB&quot;, stOffset); }
    gr.replace (inPos, newGlyphIds);

    return new LookupResult (true, inPos + glyphCount, glyphCount - 1); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

        <section>
          <title>gsub2_1_simple</title>

          <para>Our first test is simple. It replaces glyph 18 by glyphs
            20, 21 and 22.</para>

<aots:test-font id="gsub2_1_simple_f1">
  <base-font name="base.otf"/>

  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="2">
	<multipleSubst format="1">
	  <coverage glyphs="18" format="any"/>
	  <subst in="18" out="20 21 22"/>
	</multipleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub2_1_simple_t1" font="gsub2_1_simple_f1" inputs="17, 18, 19" outputs="17, 20, 21, 22, 19"/>

          <para>This lookup type has the unique property of increasing
            the size of the glyph run. In implementation in which
            glyphs in a glyph run are identified by indices, one must
            be careful to adjust indices as needed. For example, the
            upper bound of a loop that processes all (or some of) the
            glyphs in a glyph run needs to be adjusted if a multiple
            lookup is applied. This test tries to verify this by
            having an occurrence of glyph 18 (the last one) such that
            its indice after other occurrences are replaced is bigger
            than the original index of the last glyph.</para>

          <aots:gsub-test id="gsub2_1_simple_t2" font="gsub2_1_simple_f1" inputs="17, 18, 19, 18" outputs="17, 20, 21, 22, 19, 20, 21, 22"/>
        </section>

        <section>
          <title>gsub2_1_multiple_sequences</title>

          <para>Our next test verifies that multiple sequences are correctly
            interpreted.</para>

<aots:test-font id="gsub2_1_multiple_sequences_f1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="2">
	<multipleSubst format="1">
	  <coverage glyphs="18 19" format="any"/>
	  <subst in="18" out="20 21"/>
	  <subst in="19" out="22 23"/>
	</multipleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub2_1_multiple_sequences_t1" font="gsub2_1_multiple_sequences_f1" inputs="17, 18,     19,     17" outputs="17, 20, 21, 22, 23, 17"/>
        </section>

        <section>
          <title>gsub2_1_lookupflag</title>

          <para>Our next test verifies that LookupFlag is correctly
            interpreted.</para>

<aots:test-font id="gsub2_1_lookupflag_f1">
  <base-font name="base.otf"/>

  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
      <class classID="1" glyphs="18"/>
    </glyphClassDef>
  </GDEF>

  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="2" ignoreBaseGlyphs="yes">
	<multipleSubst format="1">
	  <coverage glyphs="18 19" format="any"/>
	  <subst in="18" out="20 21"/>
	  <subst in="19" out="22 23"/>
	</multipleSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub2_1_lookupflag_t1" font="gsub2_1_lookupflag_f1" inputs="17, 18, 19,     17" outputs="17, 18, 22, 23, 17"/>
        </section>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>LookupType 3: Alternate Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>An Alternate Substitution (AlternateSubst) subtable
        identifies any number of aesthetic alternatives from which a
        user can choose a glyph variant to replace the input
        glyph. For example, if a font contains four variants of the
        ampersand symbol, the cmap table will specify the index of one
        of the four glyphs as the default glyph index, and an
        AlternateSubst subtable will list the indices of the other
        three glyphs as alternatives. A text-processing client would
        then have the option of replacing the default glyph with any
        of the three alternatives. </para>

        <para>The subtable has one format: AlternateSubstFormat1. The
        subtable contains a format identifier (SubstFormat), an offset
        to a Coverage table containing the indices of glyphs with
        alternative forms (Coverage), a count of offsets to
        AlternateSet tables (AlternateSetCount), and an array of
        offsets to AlternateSet tables (AlternateSet).</para>

        <para>For each glyph, an AlternateSet subtable contains a
        count of the alternative glyphs (GlyphCount) and an array of
        their glyph indices (Alternate). Because all the glyphs are
        functionally equivalent, they can be in any order in the
        array.</para>

        <para>Example 5 at the end of this chapter shows how to
        replace the default ampersand glyph with alternative
        glyphs.</para>

        <otformat>
          <title>AlternateSubstFormat1 subtable: Alternative output
          glyphs</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table – from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>AlternateSetCount</otfieldname>
            <otfielddesc>Number of AlternateSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>AlternateSet
            [AlternateSetCount]</otfieldname> <otfielddesc>Array of
            offsets to AlternateSet tables – from beginning of
            Substitution table – ordered by Coverage
            Index</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>AlternateSet table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of GlyphIDs in the Alternate
              array</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Alternate [GlyphCount]</otfieldname>
            <otfielddesc>Array of alternate GlyphIDs – in arbitrary
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>To adopt a consistent language, the following should be added
          to the second paragraph: &quot;The Coverage index of the input glyph is
          used to index the AlternateSet array and AlternateSetCount must
          equal the number of glyphs covered by Coverage.&quot;</para>

        <para>The specification fails to say if an element of the
          AlternateSet array can be null. We assume it cannot. This can be
          added after the sentence above: &quot;The entries in the AlternateSet
          array cannot be NULL.&quot;</para>

        <para>The specification fails to say if the GlyphCount of an
          AlternateSet table can be 0. We assume it cannot, and this
          can be made clear by adding this sentence to the third paragraph:
          &quot;GlyphCount cannot be 0.&quot;</para>

	<para>The pattern matched by this subtable is ▶ C
	  ◀ where:
	  <itemizedlist>
	    <listitem>
	      <para>C is Coverage ∖ LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this subtable is to replace the glyph
	  matched by C by one of the glyphs in the Alternate array
	  corresponding to the replaced glyph. The mechanism by which
	  the client indicates which of those glyphs is used is not
	  specified.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a alternate substitution, but instead
	  would prefer the compiler to figure out the best
	  representation.:</para>

<code-fragment id="schema">
  <code-title>AlternateSubst type</code-title>
  alternateSubstTable |=
    attribute format { &quot;1&quot; },
    element coverage { coverageTableOffset }?,
    element subst {
      attribute in { text },
      attribute out { text }
    }*

  standaloneAlternateSubstTable =
    element alternateSubstTable { attribute id { text }, alternateSubstTable }

  alternateSubstTableOffset = attribute name { text } | alternateSubstTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="gsub.methods">
  private Block alternateSubstFormat1FromXML (Element subtable, Element table,
                                              Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (firstChild == null) {
      coverage = emptyCoverage (); }
    else if (&quot;subst&quot;.equals (firstChild.getTagName ())) {
      coverage = coverageFromXML (subtable.getChildNodes (), &quot;in&quot;); }
    else {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }


    int[][] alternates = new int [coverage.glyphs.length][];
    for (int i = 0; i &lt; alternates.length; i++) {
      alternates [i] = new int [0]; }

    NodeList children = subtable.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element subst = (Element) children.item (i);
      int[] in = getGlyphs (subst.getAttribute (&quot;in&quot;));
      int[] out = getGlyphs (subst.getAttribute (&quot;out&quot;));

      if (in.length != 1) {
        warning (&quot;subst in alternateSubstFormat1 must have 'in' attribute &quot;
                 + &quot; with exactly 1 glyph&quot;); }

      if (out.length == 0) {
        warning (&quot;subst in alternateSubstFormat1 must have 'out' attribute &quot;
                 + &quot; with at least 1 glyph&quot;); }

      boolean covered = false;
      for (int j = 0; j &lt; coverage.glyphs.length; j++) {
        if (in [0] == coverage.glyphs [j]) {
          alternates [j] = out;
          covered = true;
          break; }}

      if (covered == false) {
        warning (&quot;in glyph '&quot; + in [0]
                 + &quot;' must be covered in alternateSubstFormat1&quot;); }}

    me = new Block (6 + 2 * coverage.glyphs.length, 1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setint16  (4, coverage.glyphs.length);

    for (int i = 0; i &lt; coverage.glyphs.length; i++) {
      Block alternateSetTable = new Block (2 + 2 * alternates [i].length, 0);
      alternateSetTable.setuint16 (0, alternates [i].length);
      for (int g = 0; g &lt; alternates [i].length; g++) {
        alternateSetTable.setGlyphID (2 + 2*g, alternates [i][g]); }
      me.setOffset (6 + 2*i, alternateSetTable); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="gsub.toXMLCount_3">
  coverageTableToXMLCount (getOffset (stOffset, 2), counts);
  /* nothing */
</code-fragment>

<code-fragment id="gsub.toXML_3">
  coverageTableToXML (conf, getOffset (stOffset, 2), counts);
  /* nothing */
</code-fragment>

<code-fragment id="gsub.toXMLEmit_3">
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int sequenceCount = getuint16 (stOffset + 4);

    int [] glyphs = getCoveredGlyphs (coverageOffset);

    at = new AttributesImpl ();
    coverageTableOffsetToXML (conf, coverageOffset, counts, &quot;coverage&quot;, at);

    for (int i = 0; i &lt; sequenceCount; i++) {
      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;in&quot;, &quot;in&quot;, &quot;CDATA&quot;, glyphToXML (conf, glyphs [i]));

      int sequenceOffset = stOffset + getOffset (stOffset + 6 + 2*i);
      StringBuilder s = new StringBuilder ();
      for (int g = 0; g &lt; getuint16 (sequenceOffset); g++) {
        glyphToXML (conf, s, getuint16 (sequenceOffset + 2 + 2*g)); }
      at.addAttribute (&quot;&quot;, &quot;out&quot;, &quot;out&quot;, &quot;CDATA&quot;, s.toString ());
      conf.ch.element (&quot;subst&quot;, at); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>The nature of this feature is requires that it takes
          some input, namely which alternate glyph to use. Various
          applications will choose different methods, depending on
          their needs, so the method we use here should not be taken
          as implied by the specification.</para>

        <para>To help our testing, we want to have some deterministic
          method, yet we want to have a way to reach all alternate
          glyphs. We maintain a table that records for each
          AlternateSet table the alternate to use in the next
          application. On the first application, the glyph is not
          replaced, on the second application, it is replaced by the
          first alternate; when all alternates have been used, we
          restart the cycle.</para>

<code-fragment id="gsub_globals_1">
  <code-title>GSUB private members</code-title>
  java.util.Map&lt;Integer, Integer&gt; alternateMap
       = new java.util.HashMap&lt;Integer, Integer&gt; ();
</code-fragment>


<code-fragment id="gsub_3">
  <code-title>Execute GSUB 3 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos)) {
      return lookupNotApplied; }

    int alternateSetOffset = stOffset + getOffset (stOffset + 6 + 2*ci);
    int glyphCount = getuint16 (alternateSetOffset);

    int alternate = -1;
    Integer o = alternateMap.get (alternateSetOffset);
    if (o != null) {
      alternate = o.intValue (); }

    if (alternate != -1) {
      int oldGlyphId = gr.glyphAt (inPos);
      int newGlyphId = getGlyphID (alternateSetOffset + 2 + 2*alternate);

      if (listener != null) {
        listener.replace (oldGlyphId, newGlyphId);
        listener.applyingSubtable (lookupIndex, gr, curGlyph, &quot;GSUB&quot;, stOffset); }
      gr.replace (inPos, newGlyphId); }

    alternate++;
    if (alternate == glyphCount) {
      alternate = -1; }
    alternateMap.put (alternateSetOffset,
                      alternate);

    return new LookupResult (true, inPos + 1, 0); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

        <section>
          <title>gsub3_1_simple</title>

          <para>Let’s start with a simple test that replaces
          glyph 18 by glyphs 20, 21 or 22.</para>

<aots:test-font id="gsub3_1_simple_f1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="3">
	<alternateSubst format="1">
	  <coverage glyphs="18" format="any"/>
	  <subst in="18" out="20 21 22"/>
	</alternateSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub3_1_simple_t1" font="gsub3_1_simple_f1" inputs="17, 18, 17, 18, 17, 18, 17, 18, 17, 18, 17, 18, 17" outputs="17, 18, 17, 20, 17, 21, 17, 22, 17, 18, 17, 20, 17" select="-1,  0, -1,  1, -1,  2, -1,  3, -1,  0, -1,  1, -1"/>
        </section>

        <section>
          <title>gsub3_1_multiple</title>

          <para>A slightly more complicated case with two alternate
            sets: 18 can be replaced by 20 or 21, and 19 can be replaced by 22
            or 23.</para>

<aots:test-font id="gsub3_1_multiple_f1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="3">
	<alternateSubst format="1">
	  <coverage glyphs="18 19" format="any"/>
	  <subst in="18" out="20 21"/>
	  <subst in="19" out="22 23"/>
	</alternateSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub3_1_multiple_t1" font="gsub3_1_multiple_f1" inputs="17, 18, 18, 18, 18, 19, 19, 19, 19, 17" outputs="17, 18, 20, 21, 18, 19, 22, 23, 19, 17" select="-1,  0,  1,  2,  0,  0,  1,  2,  0, -1"/>
        </section>

        <section>
          <title>gsub3_1_lookupflag</title>

          <para>Let’s add a LookupFlag to skip glyph 18.</para>

<aots:test-font id="gsub3_1_lookupflag_f1">
  <base-font name="base.otf"/>

  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
      <class classID="1" glyphs="18"/>
    </glyphClassDef>
  </GDEF>

  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs="yes" type="3">
	<alternateSubst format="1">
	  <coverage glyphs="18 19" format="any"/>
	  <subst in="18" out="20 21"/>
	  <subst in="19" out="22 23"/>
	</alternateSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub3_1_lookupflag_t1" font="gsub3_1_lookupflag_f1" inputs="17, 18, 18, 18, 19, 19, 19, 19, 17" outputs="17, 18, 18, 18, 19, 22, 23, 19, 17" select="-1, -1, -1, -1,  0,  1,  2,  0, -1"/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>LookupType 4: Ligature Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>A Ligature Substitution (LigatureSubst) subtable
          identifies ligature substitutions where a single glyph
          replaces multiple glyphs. One LigatureSubst subtable can
          specify any number of ligature substitutions.</para>

        <para>The subtable uses a single format: LigatureSubstFormat1.
          It contains a format identifier (SubstFormat), a Coverage
          table offset (Coverage), a count of the ligature sets
          defined in this table (LigSetCount), and an array of offsets
          to LigatureSet tables (LigatureSet). The Coverage table
          specifies only the index of the first glyph component of
          each ligature set.</para>

        <otformat>
          <title>LigatureSubstFormat1 subtable: All ligature
            substitutions in a script</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table – from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LigSetCount</otfieldname>
            <otfielddesc>Number of LigatureSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LigatureSet [LigSetCount]</otfieldname>
            <otfielddesc>Array of offsets to LigatureSet tables
              – from beginning of Substitution table –
              ordered by Coverage Index</otfielddesc>
          </otfield>
        </otformat>

        <para>A LigatureSet table, one for each covered glyph,
          specifies all the ligature strings that begin with the
          covered glyph. For example, if the Coverage table lists the
          glyph index for a lowercase “f,” then a
          LigatureSet table will define the “ffl,”
          “fl,” “ffi,” “fi,”
          and “ff” ligatures. If the Coverage table also
          lists the glyph index for a lowercase “e,”
          then a different LigatureSet table will define the
          “etc” ligature.</para>

        <para>A LigatureSet table consists of a count of the ligatures
          that begin with the covered glyph (LigatureCount) and an
          array of offsets to Ligature tables, which define the glyphs
          in each ligature (Ligature). The order in the Ligature
          offset array defines the preference for using the ligatures.
          For example, if the “ffl” ligature is
          preferable to the “ff” ligature, then the
          Ligature array would list the offset to the
          “ffl” Ligature table before the offset to the
          “ff” Ligature table. </para>


        <otformat>
          <title>LigatureSet table: All ligatures beginning with the
          same glyph</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LigatureCount</otfieldname>
            <otfielddesc>Number of Ligature tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Ligature [LigatureCount]</otfieldname>
            <otfielddesc>Array of offsets to Ligature tables –
              from beginning of LigatureSet table – ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

        <para>For each ligature in the set, a Ligature table specifies
          the GlyphID of the output ligature glyph (LigGlyph); a count
          of the total number of component glyphs in the ligature,
          including the first component (CompCount); and an array of
          GlyphIDs for the components (Component). The array starts
          with the second component glyph (array index = 1) in the
          ligature because the first component glyph is specified in
          the Coverage table.</para>

        <para>Note: The Component array lists GlyphIDs according to
        the writing direction of the text. For text written right to
        left, the right-most glyph will be first. Conversely, for text
        written left to right, the left-most glyph will be
        first.</para>

        <para>Example 6 at the end of this chapter shows how to
        replace a string of glyphs with a single ligature.</para>


        <otformat>
          <title>Ligature table: Glyph components for one
          ligature</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>LigGlyph</otfieldname>
            <otfielddesc>GlyphID of ligature to
              substitute</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CompCount</otfieldname>
            <otfielddesc>Number of components in the
              ligature</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Component [CompCount-1]</otfieldname>
            <otfielddesc>Array of component GlyphIDs – start with the
              second component – ordered in writing
              direction</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>To adopt a consistent language, the last sentence of the
          second paragraph should be replaced by: &quot;The Coverage index of the
          first input glyph is used to index the LigatureSet array and
          LigSetCount must equal the number of glyphs covered by
          Coverage.&quot;</para>

        <para>The specification fails to say if an element of the
          LigatureSet array can be null. We assume it cannot. This can be
          added after the sentence above: &quot;The entries in the LigatureSet
          array cannot be NULL.&quot;</para>

        <para>It is unclear whether the LigatureCount of a LigatureSet
          table can be 0. We assume that
          LigatureCount must be at least 1 and recommend that it be spelled
          out in the specification.</para>

        <para>It is unclear whether the CompCount of a Ligature table can
          be 0 or 1. The value 0 is most certainly illegal (since a
          Ligature table is used in the context of a first glyph
          match). While the value 1 could be accepted, this would amount to
          a one for one substitution, which is probably better handled by a
          Single Substitution lookup. Therefore, we assume that CompCount
          must be 2 or more, and recommend that it be spelled out in the
          specification.</para>

	<para>The pattern matched by the Ligature table t = LigatureSet
	  [m].Ligature [n] is ▶ L<subscript>0</subscript> L*
	  L<subscript>1</subscript> L* ... L*
	  L<subscript>i-1</subscript> ◀, where:
	  <itemizedlist>
	    <listitem>
	      <para>i is t.CompCount</para>
	    </listitem>
	    <listitem>
	      <para>L<subscript>0</subscript> is {Coverage[m]}
	      ∖ LookupFlag</para>
	    </listitem>

	    <listitem>
	      <para>L<subscript>k</subscript> is {t.Component [k-1]} ∖ LookupFlag,
	      for k &gt; 0</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>The action of this Ligature table is to replace the entire
	  input sequence by the glyph t.LigGlyph.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>LigatureSubst type</code-title>
  ligatureSubstTable |=
    attribute format { &quot;1&quot; },
    element coverage { coverageTableOffset }?,
    element subst {
      attribute in { text },
      attribute out { text }
    }*

  standaloneLigatureSubstTable =
    element ligatureSubstTable { attribute id { text }, ligatureSubstTable }

  ligatureSubstTableOffset = attribute name { text } | ligatureSubstTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="gsub.methods">
  private Block ligatureSubstFormat1FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (   (firstChild != null)
        &amp;&amp; (! &quot;subst&quot;.equals (firstChild.getTagName ()))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    NodeList substs = subtable.getChildNodes ();
    int substsCount = substs.getLength ();

    int [][] in  = new int [substsCount] [];
    int []   out = new int [substsCount];

    for (int i = 0; i &lt; substsCount; i++) {
      Element subst = (Element) substs.item (i);
      in [i] = getGlyphs (subst.getAttribute (&quot;in&quot;));
      out [i] = parseOneGlyph (subst.getAttribute (&quot;out&quot;)); }

    if (coverage == null) {
      int [] coveredGlyphs = new int [substsCount];
      int count = 0;
      for (int i = 0; i &lt; substsCount; i++) {
         int glyph = in [i][0];
         boolean addIt = true;
         for (int j = 0; j &lt; count; j++) {
           if (glyph == coveredGlyphs [j]) {
             addIt = false;
             break; }}
         if (addIt) {
           coveredGlyphs [count++] = glyph; }}
      coverage = coverageFromGlyphs (coveredGlyphs, count); }


    me = new Block (6 + 2 * coverage.glyphs.length,
                    1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, coverage.glyphs.length);

    for (int g = 0; g &lt; coverage.glyphs.length; g++) {
      // count the number of subst that start with coverage.glyphs [g]
      int nodeCount = 0;

      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {
          nodeCount++; }}

      Block ligatureSetTable = new Block (2 + 2*nodeCount, nodeCount);
      int zz = 0;
      ligatureSetTable.setuint16 (0, nodeCount);
      me.setOffset (6 + 2*g, ligatureSetTable);

      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {

          Block ligatureTable = new Block (4 + 2 *(in[j].length - 1), 0);
          ligatureTable.setGlyphID (0, out [j]);
          ligatureTable.setuint16  (2, in [j].length);
          for (int k = 1; k &lt; in [j].length; k++) {
            ligatureTable.setGlyphID (4 + 2*(k-1), in [j][k]); }

          ligatureSetTable.setOffset (2 + 2*zz, ligatureTable);
          zz++; }}}

    return me;
  }

</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="gsub.toXMLCount_4">
  /* nothing */
</code-fragment>

<code-fragment id="gsub.toXML_4">
  /* nothing */
</code-fragment>

<code-fragment id="gsub.toXMLEmit_4">
    int coverageOffset = stOffset + getOffset (stOffset + 2);
    int sequenceCount = getuint16 (stOffset + 4);

    int [] glyphs = getCoveredGlyphs (coverageOffset);

    for (int i = 0; i &lt; sequenceCount; i++) {
      int ligatureSetOffset = stOffset + getOffset (stOffset + 6 + 2*i);
      int ligatureCount = getuint16 (ligatureSetOffset);

      for (int l = 0; l &lt; ligatureCount; l++) {
        int ligatureOffset = ligatureSetOffset + getOffset (ligatureSetOffset + 2 + 2*l);
	int compCount = getuint16 (ligatureOffset + 2);

        at = new AttributesImpl ();

        StringBuilder s = new StringBuilder ();
	glyphToXML (conf, s, glyphs [i]);
        for (int g = 0; g &lt; compCount - 1; g++) {
          glyphToXML (conf, s, getuint16 (ligatureOffset + 4 + 2*g)); }
        at.addAttribute (&quot;&quot;, &quot;in&quot;, &quot;in&quot;, &quot;CDATA&quot;, s.toString ());

        at.addAttribute (&quot;&quot;, &quot;out&quot;, &quot;out&quot;, &quot;CDATA&quot;,
                         glyphToXML (conf, getuint16 (ligatureOffset)));

        conf.ch.element (&quot;subst&quot;, at); }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>We start with a procedure that performs the matching for
          a single ligature. When this procedure is called, it is
          known that the glyph run matched
          L<subscript>0</subscript> and that L<subscript>0</subscript>
          is at <varname>inPos</varname>. If the glyph run does not
          match the rest of the ligature, then this procedure returns
          null. Otherwise, it returns an array of the glyph run
          positions that where matched, i.e. the positions of
          L<subscript>0</subscript>, L<subscript>1</subscript>,
          …</para>

        <para>Note that the organization of this procedure matches the
          organization of the subtable: L<subscript>0</subscript> is
          recorded in the Coverage of the subtable, and
          L<subscript>1</subscript>, … are recorded in a
          Ligature table; essentially this procedure takes care of one
          Ligature table.</para>

<code-fragment id="gsub.methods">
  <code-title>Procedure to match one GSUB 4 ligature</code-title>

  int[] matchOneLigature (GlyphRun gr, int inPos, int ligatureOffset,
                          int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int compCount = getuint16 (ligatureOffset + 2);
    int [] matchedPositions = new int [compCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int i = 1; i &lt; compCount; i++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (gr.glyphAt (inPos) != getGlyphID (ligatureOffset + 4 + 2*(i-1))) {
        return null; }

      matchedPositions [i] = inPos;
      inPos++; }

    return matchedPositions;
  }
</code-fragment>

    <para>With that in place, we can now implement the full
    subtable.</para>

<code-fragment id="gsub_4">
  <code-title>Execute GSUB 4 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    int ligatureSetOffset = stOffset + getOffset (stOffset + 6 + 2*ci);
    int ligatureCount = getuint16 (ligatureSetOffset);

    for (int l = 0; l &lt; ligatureCount; l++) {
      int ligatureOffset
        = ligatureSetOffset + getOffset (ligatureSetOffset + 2 + 2*l);

      int [] matchedPositions
        = matchOneLigature (gr, inPos, ligatureOffset,
                            lookupIndex, lookupFlag);

      if (   matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions [matchedPositions.length-1])) {
        int nextPosition = matchedPositions [matchedPositions.length - 1] + 1;
        int newGlyphId = getGlyphID (ligatureOffset);
        if (listener != null) {
          int[] oldGlyphIds = new int [matchedPositions.length];
          for (int i = 0; i &lt; matchedPositions.length; i++) {
            oldGlyphIds [i] = gr.glyphAt (matchedPositions [i]); }
          listener.replace (oldGlyphIds, newGlyphId);
          listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                     &quot;GSUB&quot;, ligatureOffset); }
        gr.replace (matchedPositions, newGlyphId);
        nextPosition = nextPosition - matchedPositions.length + 1;
        return new LookupResult (true, nextPosition,
                                 -(matchedPositions.length -1)); }}

    return lookupNotApplied; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

        <section>
          <title>gsub4_1_simple</title>

          <para>Let’s start with a simple test that replaces
          glyphs 18, 19, and 20 by glyph 23.</para>

<aots:test-font id="gsub4_1_simple_f1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="4">
	<ligatureSubst format="1">
	  <coverage glyphs="18" format="any"/>
	  <subst in="18 19 20" out="23"/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub4_1_simple_t1" font="gsub4_1_simple_f1" inputs="17, 18, 19, 20, 17, 18, 19, 22, 20" outputs="17, 23,         17, 18, 19, 22, 20"/>
        </section>

        <section>
          <title>gsub4_1_lookupflag</title>

          <para>Let’s add LookupFlag in a straightforward way;
          in addition to the change above, glyph 24 is skipped.</para>

<aots:test-font id="gsub4_1_lookupflag_f1">
  <base-font name="base.otf"/>
  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
      <class classID="1" glyphs="24"/>
    </glyphClassDef>
  </GDEF>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" ignoreBaseGlyphs="yes" type="4">
	<ligatureSubst format="1">
	  <coverage glyphs="18" format="any"/>
	  <subst in="18 19 20" out="23"/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <para>In the glyph run, we inject glyph 24 just before, in the
            middle (one or more occurrences), and after the input pattern
            match. If one observes the glyph run after each lookup
            application, one should see:</para>
<literallayout>
 *17  24  18  24  19  24  24  20  24  17  18  19  22  20
  17 *24  18  24  19  24  24  20  24  17  18  19  22  20
  17  24  23  24  24  24 *24  17  18  19  22  20
  17  24  23  24  24  24  24 *17  18  19  22  20
  17  24  23  24  24  24  24  17 *18  19  22  20
  17  24  23  24  24  24  24  17  18 *19  22  20
  17  24  23  24  24  24  24  17  18  19 *22  20
  17  24  23  24  24  24  24  17  18  19  22 *20
  17  24  23  24  24  24  24  17  18  19  22  20
</literallayout>

          <para>Note that the first match is on the first occurrence of
            glyph 24, and that it covers the glyph run up to glyph 20; the
            next lookup application is at the occurrence of glyph 24 just
            following glyph 20.</para>

          <aots:gsub-test id="gsub4_1_lookupflag_t1" font="gsub4_1_lookupflag_f1" inputs="17, 24, 18, 24, 19, 24, 24, 20, 24, 17, 18, 19, 22, 20" outputs="17, 24, 23, 24,     24, 24,     24, 17, 18, 19, 22, 20"/>
        </section>

        <section>
          <title>gsub4_1_multiple_ligatures</title>


          <para>Let’s verify what happens when multiple
          ligatures are present. Let’s have (18, 19, 20) go to
          23, and then (18, 19) go to 24. Note that the first ligature
          is more specific than the second one.</para>

<aots:test-font id="gsub4_1_multiple_ligatures_f1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="4">
	<ligatureSubst format="1">
	  <coverage glyphs="18" format="any"/>
	  <subst in="18 19 20" out="23"/>
	  <subst in="18 19" out="24"/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub4_1_multiple_ligatures_t1" font="gsub4_1_multiple_ligatures_f1" inputs="17, 18, 19, 20, 17, 18, 19, 22, 20" outputs="17, 23,         17, 24,     22, 20"/>

          <para>Let’s invert the order of those two ligatures,
          to make the second one more specific (and see that it never
          applies).</para>

<aots:test-font id="gsub4_1_multiple_ligatures_f2">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="4">
	<ligatureSubst format="1">
	  <coverage glyphs="18" format="any"/>
	  <subst in="18 19" out="24"/>
	  <subst in="18 19 20" out="23"/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub4_1_multiple_ligatures_t2" font="gsub4_1_multiple_ligatures_f2" inputs="17, 18, 19, 20, 17, 18, 19, 22, 20" outputs="17, 24,     20, 17, 24,     22, 20"/>
        </section>

        <section>
          <title>gsub4_1_multiple_ligsets</title>

          <para>Moving on to multiple ligature sets. (18, 19) goes to 23 and
            (20, 19) goes to 24.</para>

<aots:test-font id="gsub4_1_multiple_ligsets_f1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="4">
	<ligatureSubst format="1">
	  <coverage glyphs="18 20" format="any"/>
	  <subst in="18 19" out="23"/>
	  <subst in="20 19" out="24"/>
	</ligatureSubst>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub4_1_multiple_ligsets_t1" font="gsub4_1_multiple_ligsets_f1" inputs="17, 18, 19, 21, 20, 19, 22" outputs="17, 23,     21, 24,     22"/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>LookupType 5: Contextual Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>A Contextual Substitution (ContextSubst) subtable
          defines the most powerful type of glyph substitution lookup:
          it describes glyph substitutions in context that replace one
          or more glyphs within a certain pattern of glyphs.</para>

        <para>ContextSubst subtables can be any of three formats that
          define a context in terms of a specific sequence of glyphs,
          glyph classes, or glyph sets. Each format can describe one
          or more input glyph sequences and one or more substitutions
          for each sequence.</para>

        <para>All three formats of ContextSubst subtables specify
          substitution data in a SubstLookupRecord. A description of
          that record follows.</para>

        <otformat>
          <title>SubstLookupRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SequenceIndex</otfieldname>
            <otfielddesc>Index into current glyph sequence – first glyph
              = 0</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupListIndex</otfieldname>
            <otfielddesc>Lookup to apply to that
              position – zero-based</otfielddesc>
          </otfield>
        </otformat>

        <para>The SequenceIndex in a SubstLookupRecord must take into
          consideration the order in which lookups are applied to the
          entire glyph sequence. Because multiple substitutions may
          occur per context, the SequenceIndex and LookupListIndex
          refer to the glyph sequence after the text-processing client
          has applied any previous lookups. In other words, the
          SequenceIndex identifies the location for the substitution
          at the time that the lookup is to be applied. For example,
          consider an input glyph sequence of four glyphs. The first
          glyph does not have a substitute, but the middle two glyphs
          will be replaced with a ligature, and a single glyph will
          replace the fourth glyph:</para>

        <itemizedlist>
          <listitem>
            <para>The first glyph is in position 0. No lookups will be
            applied at position 0, so no SubstLookupRecord is
            defined.</para>
          </listitem>
          <listitem>
            <para>The SubstLookupRecord defined for the ligature
            substitution specifies the SequenceIndex as position 1,
            which is the position of the first-glyph component in the
            ligature string. After the ligature replaces the glyphs in
            positions 1 and 2, however, the input glyph sequence
            consists of only three glyphs, not the original
            four.</para>
          </listitem>
          <listitem>
            <para>To replace the last glyph in the sequence, the
            SubstLookupRecord defines the SequenceIndex as position 2
            instead of position 3. This position reflects the effect
            of the ligature substitution applied before this single
            substitution. </para>
          </listitem>
        </itemizedlist>

        <para>Note: this example assumes that the LookupList
          specifies the ligature substitution lookup before the single
          substitution lookup.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

	<para>Contextual Lookup are fundamentally the same thing in
	GSUB and GPOS. The only differences are the numeric values of
	the types (5 in GSUB, 7 in GPOS), and the LookupList against
	which the lookup indices in the SubstLookupRecord are
	resolved. It would be a great simplification for the users of
	the specification if there was a single descrription of
	Contextual subtables. The same applies to Chaining Contextual
	subtables.</para>

	<para>The interaction between the LookupFlag of a contextual
	lookup and the LookupFlag of the lookup(s) it invokes is not
	very well defined. For example, if the contextual lookup does
	not skip other any glyphs, but it invokes a lookup that
	ignores some glyphs, should those be ignored?</para>

        <para>The description of the SubstLookupRecord used to be in
        another place in version 1.25, after the description of
        lookups 5 and 6, I believe. As it stands, it is parts of the
        LookupType 5 description, which is a bit misleading since
        it’s also used in type 6. Recommendation: restore it in
        its own section.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

	<para>It is difficult to find a format-independent description
	of a contextual substitution, so we do not have one for now.</para>

	<para>Here is the boiler plate:</para>

<code-fragment id="schema">
  <code-title>Coverage tables</code-title>
  standaloneContextualTable =
    element contextualTable { attribute id { text }, contextualTable }

  contextualTableOffset = attribute name { text } | contextualTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  <code-title>Compile singlePos lookups</code-title>
  protected Block contextLookupFromXML (Element lookupSubtable,
                                        Element table,
                                        Map&lt;Element, Block&gt; blockCache,
					Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    String format = lookupSubtable.getAttribute (&quot;format&quot;);
    if (&quot;1&quot;.equals (format)) {
      return contextLookupFormat1FromXML (lookupSubtable, table,
                                          blockCache, lookupIndices); }
    if (&quot;2&quot;.equals (format)) {
      return contextLookupFormat2FromXML (lookupSubtable, table,
                                          blockCache, lookupIndices); }
    if (&quot;3&quot;.equals (format)) {
      return contextLookupFormat3FromXML (lookupSubtable, table,
                                          blockCache, lookupIndices); }

    /* cannot get here with a valid document */
    throw new InvalidFontException (
      &quot;invalid contextual lookup format (&quot; + format + &quot;)&quot;);
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  public void contextualLookupToXMLCount (int stOffset, int[] counts) {

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend="contextualLookup.toXMLCount_1"/>; break; }
      case 2: { <code-include linkend="contextualLookup.toXMLCount_2"/>; break; }
      case 3: { <code-include linkend="contextualLookup.toXMLCount_3"/>; break; }}
  }

  public void contextualLookupToXML (DecompilerConfig conf,
                                     int stOffset, int[] counts)
     throws org.xml.sax.SAXException, InvalidFontException {

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend="contextualLookup.toXML_1"/>; break; }
      case 2: { <code-include linkend="contextualLookup.toXML_2"/>; break; }
      case 3: { <code-include linkend="contextualLookup.toXML_3"/>; break; }}
  }

  public void contextualLookupToXMLEmit (DecompilerConfig conf,
                                         int stOffset, int[] counts)
     throws org.xml.sax.SAXException, InvalidFontException {

    AttributesImpl at;
    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend="contextualLookup.toXMLEmit_1"/>; break; }
      case 2: { <code-include linkend="contextualLookup.toXMLEmit_2"/>; break; }
      case 3: { <code-include linkend="contextualLookup.toXMLEmit_3"/>; break; }}
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>As usual, all subtable formats start with the same
          field, the uint16 SubstFormat, which we use to
          dispatch:</para>

<code-fragment id="lookuptable.methods">
  <code-title>?</code-title>
  public LookupResult applyContextualLookupSubtable
                          (int lookupIndex, int lookupType, int lookupFlag,
                           int stOffset, GlyphRun gr, int curGlyph)
      throws InvalidFontException {

    int substFormat = getuint16 (stOffset);

    switch (substFormat) {
      case 1: { <code-include linkend="contextualLookup_format1"/> }
      case 2: { <code-include linkend="contextualLookup_format2"/> }
      case 3: { <code-include linkend="contextualLookup_format3"/> }
      default:
        throw new InvalidFontException (&quot;GSUB 5/-&quot; + substFormat + &quot;-&quot;); }
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Context Substitution Format 1</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Format 1 defines the context for a glyph substitution
          as a particular sequence of glyphs. For example, a context
          could be &lt;xyz&gt;, &lt;holiday&gt;, &lt;!?*#@&gt;, or any other glyph
          sequence.</para>

        <para>Within a context sequence, Format 1 identifies
          particular glyph positions (not glyph indices) as the
          targets for specific substitutions. When a text-processing
          client locates a context in a string of text, it finds the
          lookup data for a targeted position and makes a substitution
          by applying the lookup data at that location.</para>

        <para>For example, if a client is to replace the glyph string
          &lt;abc&gt; with its reverse glyph string &lt;cba&gt;, the input
          context is defined as the glyph sequence, &lt;abc&gt;, and the
          lookups defined for the context are (1) “a” to
          “c” and (2) “c” to
          “a”. When a client encounters the context
          &lt;abc&gt;, the lookups are performed in the order stored.
          First, “c” is substituted for
          “a” resulting in &lt;cbc&gt;. Second,
          “a” is substituted for the “c”
          that has not yet been touched, resulting in &lt;cba&gt;.</para>

        <para>To specify a context, a Coverage table lists the first
          glyph in the sequence, and a SubRule table identifies the
          remaining glyphs. To describe the &gt;abc&lt; context used in
          the previous example, the Coverage table lists the glyph
          index of the first component of the sequence ߝ the
          “a” glyph. A SubRule table defines indices for
          the “b” and “c” glyphs. </para>

        <para>A single ContextSubstFormat1 subtable may define more
          than one context glyph sequence. If different context
          sequences begin with the same glyph, then the Coverage table
          should list the glyph only once because all glyphs in the
          table must be unique. For example, if three contexts each
          start with an “s” and two start with a
          “t,” then the Coverage table will list one
          “s” and one “t.”</para>

        <para>For each context, a SubRule table lists all the glyphs
          that follow the first glyph. The table also contains an
          array of SubstLookupRecords that specify the substitution
          lookup data for each glyph position (including the first
          glyph position) in the context.</para>

        <para>All of the SubRule tables defining contexts that begin
          with the same first glyph are grouped together and defined
          in a SubRuleSet table. For example, the SubRule tables that
          define the three contexts that begin with an
          “s” are grouped in one SubRuleSet table, and
          the SubRule tables that define the two contexts that begin
          with a “t” are grouped in a second SubRuleSet
          table. Each glyph listed in the Coverage table must have a
          SubRuleSet table defining all the SubRule tables that apply
          to a covered glyph.</para>

          <para>To locate a context glyph sequence, the
          text-processing client searches the Coverage table each time
          it encounters a new text glyph. If the glyph is covered, the
          client reads the corresponding SubRuleSet table and examines
          each SubRule table in the set to determine whether the rest
          of the context matches the subsequent glyphs in the text. If
          the context and text string match, the client finds the
          target glyph positions, applies the lookups for those
          positions, and completes the substitutions.</para>

          <para>A ContextSubstFormat1 subtable contains a format
          identifier (SubstFormat), an offset to a Coverage table
          (Coverage), a count of defined SubRuleSets
          (SubRuleSetCount), and an array of offsets to the SubRuleSet
          tables (SubRuleSet). As mentioned, one SubRuleSet table must
          be defined for each glyph listed in the Coverage
          table.</para>

          <para>In the SubRuleSet array, the SubRuleSet table offsets
          are ordered in the Coverage Index order. The first
          SubRuleSet in the array applies to the first GlyphID listed
          in the Coverage table, the second SubRuleSet in the array
          applies to the second GlyphID listed in the Coverage table,
          and so on.</para>


        <otformat>
            <title>ContextSubstFormat1 subtable: Simple context glyph
            substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table – from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubRuleSetCount</otfieldname>
            <otfielddesc>Number of SubRuleSet tables – must equal
              GlyphCount in Coverage table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubRuleSet [SubRuleSetCount]</otfieldname>
            <otfielddesc>Array of offsets to SubRuleSet tables
              – from beginning of Substitution table – ordered by
              Coverage Index</otfielddesc>
          </otfield>
        </otformat>

        <para>A SubRuleSet table consists of an array of offsets to
          SubRule tables (SubRule), ordered by preference, and a count
          of the SubRule tables defined in the set (SubRuleCount). The
          order in the SubRule array can be critical. Consider two
          contexts, &lt;abc&gt; and &lt;abcd&gt;. If &lt;abc&gt; is first in
          the SubRule array, all instances of &lt;abc&gt; in the
          text – including all instances of &lt;abcd&gt; – will be
          changed. If &lt;abcd&gt; comes first in the array, however,
          only &lt;abcd&gt; sequences will be changed, without affecting
          any instances of &lt;abc&gt;.</para>


        <otformat>
            <title>SubRuleSet table: All contexts beginning with the
            same glyph</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubRuleCount</otfieldname>
            <otfielddesc>Number of SubRule tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubRule [SubRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to SubRule tables – from
              beginning of SubRuleSet table – ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

          <para>A SubRule table consists of a count of the glyphs to
          be matched in the input context sequence (GlyphCount),
          including the first glyph in the sequence, and an array of
          glyph indices that describe the context (Input). The
          Coverage table specifies the index of the first glyph in the
          context, and the Input array begins with the second glyph
          (array index = 1) in the context sequence.</para>

          <blockquote>
            <para>Note: The Input array lists the indices in the order
            the corresponding glyphs appear in the text. For text
            written from right to left, the right-most glyph will be
            first; conversely, for text written from left to right,
            the left-most glyph will be first.</para>
          </blockquote>

          <para>A SubRule table also contains a count of the
          substitutions to be performed on the input glyph sequence
          (SubstCount) and an array of SubstitutionLookupRecords
          (SubstLookupRecord). Each record specifies a position in the
          input glyph sequence and a LookupListIndex to the
          substitution lookup that is applied at that position. The
          array should list records in design order, or the order the
          lookups should be applied to the entire glyph
          sequence.</para>

        <otformat>
            <title>SubRule table: One simple context definition</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in input glyph
              sequence – includes the first glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Input [GlyphCount-1]</otfieldname>
            <otfielddesc>Array of input GlyphIDs – start with second
              glyph</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords – in design
              order</otfielddesc>
          </otfield>
        </otformat>

          <para>Example 7 at the end of the chapter shows how to use
          the ContextSubstFormat1 subtable to replace a sequence of
          three glyphs with a sequence preferred for the French
          language system.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>Second paragraph: &quot;... locates a context in a string of
          text, ...&quot; shoud be replaced by &quot;... locates a context in a
          string of glyphs, ...&quot;.</para>

        <para>In the fourth paragraph the '&lt;' and '&gt;' around the
          first literal context are inverted.</para>


        <para>To adopt a consistent language, the last paragraph
          before the ContextSubtFormat1 table, and the last sentence
          of the previous paragraph, should be replaced by: &quot;The
          Coverage index of the first input glyph is used to index the
          SubRuleSet array and SubRuleSetCount must equal the number
          of glyphs covered by Coverage. The entries in the SubRuleSet
          array cannot be NULL.&quot;</para>

        <para>It is unclear whether the SubRuleCount of a SubRuleSet
          table can be 0. We assume that SubRuleCount must be at least
          1 and recommend that it be spelled out in the
          specification.</para>

        <para>It is unclear whether the GlyphCount of a SubRule can be
          0 or 1. The value 0 is most certainly illegal (since a
          SubRule table is used in the context of a first glyph
          match). We assume that the value 1 is legal (because it
          makes sense for a similar LookupType 6 subtable), eventhough
          it is difficult to exhibit an interesting use of that
          case.</para>

        <para>It is unclear whether the SubstCount of a SubRule can be
          0. At first it seems that such a SubRule could be removed,
          since it does nothing. On the other hand, this could be
          useful to prevent the activation of following SubRules; e.g.
          if one wanted the sequence &lt;abc&gt; modified, but not the
          sequence &lt;abcd&gt;. The recommendation is to explicitly
          mention that case as permitted.</para>

	<para>The pattern matched by the SubRule table t = SubRuleSet
	  [m].SubRule [n] is ▶
	  I<subscript>0</subscript> L* I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> ◀, where:

	  <itemizedlist>
	    <listitem>
	      <para>i is t.GlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>0</subscript> is {Coverage[m]}
	      ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is {t.Input [k-1]}
	      ∖ LookupFlag, for k &gt; 0</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubRule table does not directly modify the glyph
	run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Contextual substitution format 1 type</code-title>
  contextualTable |=
    attribute format { &quot;1&quot; },
    element coverage { coverageTableOffset }?,
    element pattern {
      attribute in { text },
      subLookups
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  private Block contextLookupFormat1FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block&gt; blockCache,
					     Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith (&quot;coverage&quot;))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    NodeList rules = subtable.getChildNodes ();
    int rulesCount = rules.getLength ();

    int [][] in  = new int [rulesCount] [];

    for (int i = 0; i &lt; rulesCount; i++) {
      Element rule = (Element) rules.item (i);
      in [i] = getGlyphs (rule.getAttribute (&quot;in&quot;)); }

    if (coverage == null) {
      int [] coveredGlyphs = new int [rulesCount];
      int count = 0;
      for (int i = 0; i &lt; rulesCount; i++) {
        int glyph = in [i][0];
        boolean addIt = true;
        for (int j = 0; j &lt; count; j++) {
          if (glyph == coveredGlyphs [j]) {
            addIt = false;
            break; }}
        if (addIt) {
          coveredGlyphs [count++] = glyph; }}
      coverage = coverageFromGlyphs (coveredGlyphs, count); }


    me = new Block (6 + 2 * coverage.glyphs.length,
                    1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, coverage.glyphs.length);

    for (int g = 0; g &lt; coverage.glyphs.length; g++) {
      // count the number of subst that start with coverage.glyphs [g]
      int nodeCount = 0;
      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {
          nodeCount++; }}

      Block subRuleSetTable = new Block (2 + 2*nodeCount, nodeCount);
      subRuleSetTable.setuint16 (0, nodeCount);
      nodeCount = 0;
      me.setOffset (6 + 2*g, subRuleSetTable);

      for (int j = 0; j &lt; in.length; j++) {
        if (in [j][0] == coverage.glyphs [g]) {

          Element rule = (Element) rules.item (j);
          NodeList substs = rule.getChildNodes ();
          int substCount = substs.getLength ();

          Block subRuleTable = new Block (4 + 2 * (in[j].length - 1) +
                                          4 * substCount, 0);
          subRuleSetTable.setOffset (2 + 2*(nodeCount++), subRuleTable);
          subRuleTable.setuint16 (0, in[j].length);
          subRuleTable.setuint16 (2, substCount);

          for (int k = 1; k &lt; in[j].length; k++) {
            subRuleTable.setGlyphID (4 + 2*(k-1), in [j][k]); }

	  subLookupsFromXML (substCount, substs,
	                    subRuleTable, 4 + 2*(in[j].length-1),
			    lookupIndices); }}}

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="contextualLookup.toXMLCount_1">
  /* nothing */
</code-fragment>

<code-fragment id="contextualLookup.toXML_1">
  /* nothing */
</code-fragment>

<code-fragment id="contextualLookup.toXMLEmit_1">
    int posRuleSetCount = getuint16 (stOffset + 4);
    int[] coveredGlyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 2));

    for (int i = 0; i &lt; posRuleSetCount; i++) {
      int posRuleSetOffset = stOffset + getOffset (stOffset + 6 + 2*i);
      int posRuleCount = getuint16 (posRuleSetOffset);
      for (int j = 0; j &lt; posRuleCount; j++) {
        int posRuleOffset = posRuleSetOffset + getOffset (posRuleSetOffset + 2 + 2*j);
        int glyphCount = getuint16 (posRuleOffset);
        StringBuilder s = new StringBuilder ();
	glyphToXML (conf, s, coveredGlyphs [i]);
        for (int g = 0; g &lt; glyphCount - 1; g++) {
          glyphToXML (conf, s, getuint16 (posRuleOffset + 4 + 2*g)); }

        at = new AttributesImpl ();
        at.addAttribute (&quot;&quot;, &quot;in&quot;, &quot;in&quot;, &quot;CDATA&quot;, s.toString ());
        conf.ch.startElement (&quot;pattern&quot;, at); {
          subLookupsToXML (conf, getuint16 (posRuleOffset + 2),
                           posRuleOffset + 4 + 2*(glyphCount-1));
          conf.ch.endElement (&quot;pattern&quot;); }}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>This subtable is very similar to a Ligature Substitution
          subtable. The matched patterns are the same. The difference
          is in the replacement; in a Ligature Substitution, the
          matched glyphs are replaced by a specific glyph, whereas in
          this subtable, SubstLookupRecords are invoked.</para>

        <para>We start with a procedure that performs the matching for
          a single sub rule. When this procedure is called, it is
          known that the glyph run matched
          L<subscript>0</subscript> and that L<subscript>0</subscript>
          is at <varname>inPos</varname>. If the glyph run does not
          match the rest of the sub rule, then this procedure returns
          null. Otherwise, it returns an array of the glyph run
          positions that where matched, i.e. the positions of
          L<subscript>0</subscript>, L<subscript>1</subscript>,
          …</para>

        <para>Note that the organization of this procedure matches the
          organization of the subtable: L<subscript>0</subscript> is
          recorded in the coverage of the subtable, and
          L<subscript>1</subscript>, … are recorded in SubRule
          table; essentially this procedure takes care of one SubRule
          table.</para>

<code-fragment id="lookuptable.methods">
  <code-title>Procedure to match one GSUB 5/1 sub rule</code-title>

  int[] matchOneRule (GlyphRun gr, int inPos, int ruleOffset,
                         int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int glyphCount = getuint16 (ruleOffset);
    int [] matchedPositions = new int [glyphCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int i = 1; i &lt; glyphCount; i++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (gr.glyphAt (inPos) != getuint16 (ruleOffset + 4 + 2*(i-1))) {
        return null; }

      matchedPositions [i] = inPos;
      inPos++; }

    return matchedPositions;
  }
</code-fragment>

        <para>With that in place, we can now implement the full
          subtable.</para>

        <para>The only complication is the determination of the
          position of the next glyph to process. The next glyph is the
          one following L<subscript>n-1</subscript>. Before the
          SubstLookupRecords are applied, we know the position of that
          glyph, but it can modified by the SubstLookupRecords. We
          could arrange for the application of the SubstLookupRecords
          to indicate how many glyphs are inserted or deleted, but
          this would complicate that code. Instead, we rely on the
          property that the SubstLookupRecords cannot modify glyphs
          outside of the matched pattern: in particular, we know that
          none of the glyphs following L<subscript>n-1</subscript> in
          the glyph run are modified, and therefore that their number
          does not change.</para>

<code-fragment id="contextualLookup_format1">
  <code-title>Execute contextual lookup subtable, format 1, and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    int ruleSetOffset = stOffset + getuint16 (stOffset + 6 + ci*2);
    int ruleCount = getuint16 (ruleSetOffset);

    for (int s = 0; s &lt; ruleCount; s++) {
      int ruleOffset = ruleSetOffset +  getOffset (ruleSetOffset + 2 + 2*s);

      int[] matchedPositions
        = matchOneRule (gr, inPos, ruleOffset, lookupIndex, lookupFlag);

      if (matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions [matchedPositions.length-1])) {

        int glyphCount = getuint16 (ruleOffset);
        int applyCount = getuint16 (ruleOffset + 2);
        int applyOffset = ruleOffset + 4 + 2*(glyphCount-1);
        if (listener != null) {
           listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                      Tag.tag2string (tag), stOffset); }
        return applySubLookups (gr, matchedPositions,
                                applyCount, applyOffset); }}

    return lookupNotApplied; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>


        <section>
          <title>context1_simple</title>

          <para>Let’s start with a simple test that matches the
          sequence 20, 21, 22. At each position, we then apply a
          our standard sublookups.</para>

<aots:context-test-font id="context1_simple_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="1">
	<pattern in="20 21 22">
	  <apply pos="0" lookup="lookup.single"/>
	  <apply pos="1" lookup="lookup.single"/>
	  <apply pos="2" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_simple_t1" font="context1_simple_f1" inputs="00,  20,   21,   22,   00" outputs="00,  60,   61,   62,   00" xdeltas=" 0,  20,   20,   20,    0" ydeltas=" 0,   0,    0,    0,    0"/>

          <para>Here is a test case on the same font that involves incomplete
	  matches of input sequence:</para>

          <aots:context-test id="context1_simple_t2" font="context1_simple_f1" inputs="00,  20,  00,  20,  21,  00" outputs="00,  20,  00,  20,  21,  00" xdeltas="0,    0,   0,   0,   0,   0" ydeltas="0,    0,   0,   0,   0,   0"/>

	  <para>When applying a sublookup, that must be done as the
	  position given by the contextual lookup, not to all possible
	  positions in the matched input or beyond:</para>

<aots:context-test-font id="context1_simple_f2">
  <lookup id="lookup.test" type="contextual">
    <contextual format="1">
	<pattern in="20 20 20">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_simple_t3" font="context1_simple_f2" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  20,   60,   20,   20,   20,   00" xdeltas="0,    0,   20,    0,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>
        </section>

        <section>
          <title>context1_next_glyph</title>

          <para>Our next test verifies that the proper glyph is
            processed after a contextual lookup it applied. The lookup
            matches the sequence 20, 20  and applies the standard
	    sublookups to the first occurrence of 20.</para>

<aots:context-test-font id="context1_next_glyph_f1">
  <lookup id="lookup.test" type="contextual">
	<contextual format="1">
	  <pattern in="20 20">
	    <apply pos="0" lookup="lookup.single"/>
	  </pattern>
	</contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_next_glyph_t1" font="context1_next_glyph_f1" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  60,   20,   60,   20,   20,   00" xdeltas="0,   20,    0,   20,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>

        </section>

        <section>
          <title>context1_boundary</title>

          <para>We test the boundary case of SubstCount equal to
	  0.</para>

<aots:context-test-font id="context1_boundary_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="1">
	<pattern in="20 20"/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_boundary_t1" font="context1_boundary_f1" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  20,   20,   20,   20,   20,   00" xdeltas="0,    0,    0,    0,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>

          <para>Another boundary case is when GlyphCount is 1.</para>

<aots:context-test-font id="context1_boundary_f2">
  <lookup id="lookup.test" type="contextual">
    <contextual format="1">
	<pattern in="20">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_boundary_t2" font="context1_boundary_f2" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  60,   60,   60,   60,   60,   00" xdeltas="0,   20,   20,   20,   20,   20,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>
	</section>

        <section>
          <title>context1_multiple_subrules</title>

          <para>The next two tests ensure that the subrules of
          subruleset are applied in the prescribed order. In the first
          one, the matched sequences are 20, 21, 22, with the standard
          sublookups applied on 20, and 20, 21, with the standard
          sublookups applied on 21.</para>

<aots:context-test-font id="context1_multiple_subrules_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="1">
	<pattern in="20 21 22">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
	<pattern in="20 21">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_multiple_subrules_t1" font="context1_multiple_subrules_f1" inputs="00,  20,   21,   22,   00,   20,   21,   00" outputs="00,  60,   21,   22,   00,   20,   61,   00" xdeltas=" 0,  20,    0,    0,    0,    0,   20,    0" ydeltas=" 0,   0,    0,    0,    0,    0,    0,    0"/>

          <para>In the next test, we just invert the order of two
	  subrules.</para>

<aots:context-test-font id="context1_multiple_subrules_f2">
  <lookup id="lookup.test" type="contextual">
    <contextual format="1">
	<pattern in="20 21">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
	<pattern in="20 21 22">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_multiple_subrules_t2" font="context1_multiple_subrules_f2" inputs="00,  20,   21,   22,   00,   20,   21,   00" outputs="00,  20,   61,   22,   00,   20,   61,   00" xdeltas=" 0,   0,   20,    0,    0,    0,   20,    0" ydeltas=" 0,   0,    0,    0,    0,    0,    0,    0"/>
        </section>

        <section>
          <title>context1_successive</title>

          <para>In this test, we verify the case described in the
          SubstLookupRecord section. This applies to GSUB contextual
          lookups only. The matched sequence is 20 21 22 23. Glyphs 21
          and 22 are replaced by glyph 61 and glyph 23 is replaced by
          glyph 63. The difficult part is that the lookup that
          replaces 22 is applied at position 2, which is counted after
          the ligature substitution is applied.</para>

<aots:context-test-font id="context1_successive_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="1">
	<pattern in="20 21 22 23">
	  <apply pos="1" lookup="lookup.double"/>
	  <apply pos="2" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_successive_t1" font="context1_successive_f1" inputs="00,  20,   21,   22,  23,   00" outputs="00,  20,   61,        63,   00" xdeltas=" 0,   0,   20,   20,   0,    0" ydeltas=" 0,   0,    0,    0,   0,    0"/>
        </section>

        <section>
          <title>context1_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
          sequence is 20 21 22, with standard sublookups applied at
          all three positions.</para>

<aots:context-test-font id="context1_lookupflag_f1">
  <lookup id="lookup.test" type="contextual" ignoreMarks="yes">
    <contextual format="1">
	<pattern in="20 21 22">
	  <apply pos="0" lookup="lookup.single"/>
	  <apply pos="1" lookup="lookup.single"/>
	  <apply pos="2" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>


	  <aots:context-test id="context1_lookupflag_t1" font="context1_lookupflag_f1" inputs="00,  20,  90,  21,  91,  92,  22,   00" outputs="00,  60,  90,  61,  91,  92,  62,   00" xdeltas="0,   20,   0,  20,   0,   0,  20,    0" ydeltas="0,    0,   0,   0,   0,   0,   0,    0"/>

	  <para>The interaction between LookupFlag of the contextal
	  substitution and LookupFlag of the sublookups is not very
	  clear. It is certainly desired that any glyph covered by
	  the contextual substitution LookupFlag be invisible to the
	  sublookups; what is unclear is whether this is achieved by
	  constraining legal fonts, or whether CommonType engines have
	  to enforce that behavior. Here is a font that does have
	  consistent LookupFlag, and it should behave properly with
	  all layout engines.</para>

<aots:context-test-font id="context1_lookupflag_f2">
  <lookup id="lookup.test" type="contextual" ignoreMarks="yes">
    <contextual format="1">
	<pattern in="20 21 22">
	  <apply pos="1" lookup="lookup.double.nomarks"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_lookupflag_t2" font="context1_lookupflag_f2" inputs="00,  20,  90,  21,  91,  92,  22,   00" outputs="00,  20,  90,  61,  91,  92,        00" xdeltas="0,    0,   0,  20,   0,   0,   0,    0" ydeltas="0,    0,   0,   0,   0,   0,   0,    0"/>
        </section>

        <section>
          <title>context1_expansion</title>

          <para>As we have noted in multiple substitution lookups, the
          glyph run can be expanded. While a chaining lookup does not
          be itself perform that operation, it may invoke a multiple
          substitution lookup.</para>

<aots:context-test-font id="context1_expansion_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="1">
	<pattern in="20 21 22">
	  <apply pos="1" lookup="lookup.multiple"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context1_expansion_t1" font="context1_expansion_f1" inputs="00,  20,  21,            22,  00" outputs="00,  20,  61,  62,  63,  22,  00" xdeltas="0,    0,   0,             0,   0" ydeltas="0,    0,   0,             0,   0"/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Context Substitution Format 2</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Format 2, a more flexible format than Format 1,
          describes class-based context substitution. For this format,
          a specific integer, called a class value, must be assigned
          to each glyph component in all context glyph
          sequences. Contexts are then defined as sequences of glyph
          class values. More than one context may be defined at a
          time.</para>

        <para>For example, suppose that a swash capital glyph should
          replace each uppercase letter glyph that is preceded by a
          space glyph and followed by a lowercase letter glyph (a
          glyph sequence of space – uppercase –
          lowercase). The set of uppercase glyphs would constitute one
          glyph class (Class 1), the set of lowercase glyphs would
          constitute a second class (Class 2), and the space glyph
          would constitute a third class (Class 3). The input context
          might be specified with a context rule (called a
          SubClassRule) that describes “the set of glyph strings that
          form a sequence of three glyph classes, one glyph from Class
          3, followed by one glyph from Class 1, followed by one glyph
          from Class 2.”</para>

        <para>Each ContextSubstFormat2 subtable contains an offset
          to a class definition table (ClassDef), which defines the
          glyph class values of all input contexts. Generally, a
          unique ClassDef table will be declared in each instance of
          the ContextSubstFormat2 table that is included in a font,
          even though several Format 2 tables could share ClassDef
          tables. Class assignments are fixed (the same for each
          position in the context), and classes are exclusive (a glyph
          cannot be in more than one class at a time). The output
          glyphs that replace the glyphs in the context sequences do
          not need class values because they are specified elsewhere
          by GlyphID.</para>

          <para>The ContextSubstFormat2 subtable also contains a
          format identifier (SubstFormat) and defines an offset to a
          Coverage table (Coverage). For this format, the Coverage
          table lists indices for the complete set of unique glyphs
          (not glyph classes) that may appear as the first glyph of
          any class-based context. In other words, the Coverage table
          contains the list of glyph indices for all the glyphs in all
          classes that may be first in any of the context class
          sequences. For example, if the contexts begin with a Class 1
          or Class 2 glyph, then the Coverage table will list the
          indices of all Class 1 and Class 2 glyphs.</para>

          <para>A ContextSubstFormat2 subtable also defines an array
          of offsets to the SubClassSet tables (SubClassSet) and a
          count of the SubClassSet tables (SubClassSetCnt). The array
          contains one offset for each class (including Class 0) in
          the ClassDef table. In the array, the class value defines an
          offset's index position, and the SubClassSet offsets are
          ordered by ascending class value (from 0 to SubClassSetCnt -
          1).</para>

          <para>For example, the first SubClassSet listed in the array
          contains all contexts beginning with Class 0 glyphs, the
          second SubClassSet contains all contexts beginning with
          Class 1 glyphs, and so on. If no contexts begin with a
          particular class (that is, if a SubClassSet contains no
          SubClassRule tables), then the offset to that particular
          SubClassSet in the SubClassSet array will be set to
          NULL.</para>

        <otformat>
            <title>ContextSubstFormat2 subtable: Class-based context
            glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table – from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ClassDef</otfieldname>
            <otfielddesc>Offset to glyph ClassDef table – from beginning
              of Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubClassSetCnt</otfieldname>
            <otfielddesc>Number of SubClassSet tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubClassSet [SubClassSetCnt]</otfieldname>
            <otfielddesc>Array of offsets to SubClassSet tables
              – from beginning of Substitution table –
              ordered by class – may be NULL</otfielddesc>
          </otfield>
        </otformat>

          <para>Each context is defined in a SubClassRule table, and
          all SubClassRules that specify contexts beginning with the
          same class value are grouped in a SubClassSet
          table. Consequently, the SubClassSet containing a context
          identifies a context's first class component.</para>

          <para>Each SubClassSet table consists of a count of the
          SubClassRule tables defined in the SubClassSet
          (SubClassRuleCnt) and an array of offsets to SubClassRule
          tables (SubClassRule). The SubClassRule tables are ordered
          by preference in the SubClassRule array of the
          SubClassSet.</para>

        <otformat>
            <title>SubClassSet subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubClassRuleCnt</otfieldname>
            <otfielddesc>Number of SubClassRule tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubClassRule [SubClassRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to SubClassRule tables – from
              beginning of SubClassSet – ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

          <para>For each context, a SubClassRule table contains a
          count of the glyph classes in the context sequence
          (GlyphCount), including the first class. A Class array lists
          the classes, beginning with the second class (array index =
          1), that follow the first class in the context.</para>

          <blockquote>
            <para>Note: Text order depends on the writing direction of
            the text. For text written from right to left, the
            right-most class will be first. Conversely, for text
            written from left to right, the left-most class will be
            first.</para>
          </blockquote>

          <para>The values specified in the Class array are the values
          defined in the ClassDef table. For example, a context
          consisting of the sequence “Class 2, Class 7, Class 5, Class
          0” will produce a Class array of 7,5,0. The first class in
          the sequence, Class 2, is identified in the
          ContextSubstFormat2 table by the SubClassSet array index of
          the corresponding SubClassSet.</para>

          <para>A SubClassRule also contains a count of the
          substitutions to be performed on the context (SubstCount)
          and an array of SubstLookupRecords (SubstLookupRecord) that
          supply the substitution data. For each position in the
          context that requires a substitution, a SubstLookupRecord
          specifies a LookupList index and a position in the input
          glyph sequence where the lookup is applied. The
          SubstLookupRecord array lists SubstLookupRecords in design
          order – that is, the order in which lookups should be applied
          to the entire glyph sequence.</para>


        <otformat>
            <title>SubClassRule table: Context definition for one
            class</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Total number of classes specified for the
              context in the rule – includes the first
              class</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Class [GlyphCount-1]</otfieldname>
            <otfielddesc>Array of classes – beginning with the second
              class – to be matched to the input glyph class
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of Substitution lookups – in design
              order</otfielddesc>
          </otfield>
        </otformat>

          <para>Example 8 at the end of this chapter uses Format 2 to
          substitute Arabic mark glyphs for base glyphs of different
          heights.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>In the third paragraph, the possibility of sharing of a
          class definition is too restrictive: a class definition
          could be used in a LookupType 6, for example. The
          recommendation is to replace &quot;Generally&quot; by &quot;Typically&quot;, and
          the part of the sentence starting with &quot;even though&quot; by
          &quot;but in general, a class definition can be used in multiple
          lookups.&quot;</para>

        <para>In the description of the Coverage in the fourth
          paragraph, the sentences starting with &quot;In other words,&quot; are
          a bit misleading: the coverage may contain more or less than
          the union of the classes that have non-NULL SubClassSet
          offsets. This can be useful when the class definition is
          shared by multiple lookups. The recommendation is to replace
          the fouth paragraph by: &quot;The ContextSubstFormat2 subtable
          also contains a format identifier (SubstFormat) and defines
          an offset to a Coverage table (Coverage). The lookup will
          apply only if the current glyph is covered by Coverage.
          Typically, the coverage is the union of the classes that
          appear as the first class of any context; for example, if
          the contexts begin with classes 1 and 2, then the Coverage
          will be exactly the glyphs in classes 1 and 2. However, this
          is not mandatory; in particular, it may be useful to have a
          Coverage which is a subset of those glyphs.&quot;</para>

        <para>To adopt a more consistent language, in the fifth
          paragraph, the sentences following the first should be
          replaced by: &quot;The class of the first input glyph under
          ClassDef is used to index the SubClassSet array and
          SubClassSetCnt must equal the number of classes defined by
          ClassDef (including class 0).&quot;</para>

        <para>It is unclear whether the SubClassRuleCnt of a
          SubClassSet table can be 0. We assume that SubRuleCount must
          be at least 1 and recommend that it be spelled out in the
          specification.</para>

        <para>It is unclear whether the GlyphCount of a SubClassRule
          can be 0 or 1. The value 0 is most certainly illegal (since
          a SubClassRule table is used in the context of a first glyph
          match). We assume that the value 1 is legal (because it
          makes sense for a similar LookupType 6 subtable), eventhough
          it is difficult to exhibit an interesting use of that
          case.</para>

        <para>It is unclear whether the SubstCount of a SubClassRule
          can be 0. At first it seems that such a SubClassRule could
          be removed, since it does nothing. On the other hand, this
          could be useful to prevent the activation of following
          SubClassRules; e.g. if one wanted the sequence &lt;1 2 3&gt;
          modified, but not the sequence &lt;1 2 3 4&gt;. The
          recommendation is to explicitly mention that case as
          permitted.</para>

	<para>The pattern matched by the SubClassRule table t = SubClassSet
	  [m].SubClassRule [n] is
	  ▶ I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> ◀, where:

	  <itemizedlist>
	    <listitem>
	      <para>i is t.GlyphCount</para>
	    </listitem>

	    <listitem>
	      <para>I<subscript>0</subscript> is (Coverage ∩
	      ClassDef [m]) ∖ LookupFlag</para>
	    </listitem>

	    <listitem>
	      <para>I<subscript>k</subscript> is ClassDef [t.Class
	      [k-1]] ∖ LookupFlag, for k &gt; 0</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubClassRule table does not directly modify the glyph
	run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Contextual substitution format 2</code-title>
  contextualTable |=
    attribute format { &quot;2&quot; },
    element coverage { coverageTableOffset }?,
    element classDef { classDefTableOffset },
    element pattern {
      attribute in { text },
      subLookups
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  private Block contextLookupFormat2FromXML (Element subtable, Element table,
                                             Map&lt;Element, Block&gt; blockCache,
					     Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;

    Element firstChild = (Element) subtable.getFirstChild ();
    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith (&quot;coverage&quot;))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    ClassdefTableBlock inputClassdef
        = classdefFromXML ((Element) subtable.getFirstChild (),
                           table, blockCache);
    subtable.removeChild (subtable.getFirstChild ());

    NodeList classPatterns = subtable.getChildNodes ();

    if (coverage == null) {
      System.err.println (&quot;implicit coverage in contextSubstFormat2 not yet supported&quot;); }


    me = new Block (8 + 2*inputClassdef.classCount,
                    2 + inputClassdef.classCount);
    me.setuint16 (0, 2);
    me.setOffset (2, coverage);
    me.setOffset (4, inputClassdef);
    me.setuint16 (6, inputClassdef.classCount);

    for (int c = 0; c &lt; inputClassdef.classCount; c++) {

      // count how many classPatterns start with class c
      int count = 0;
      for (int j = 0; j &lt; classPatterns.getLength (); j++) {
        Element classPattern = (Element) classPatterns.item (j);
        int[] classes = parseIntList (classPattern.getAttribute (&quot;in&quot;));
        if (classes [0] == c) {
          count++; }}

      if (count == 0) {
        me.setOffset (8 + 2*c, null); }

      else {
        Block subClassSet = new Block (2 + 2*count, count);
        me.setOffset (8 + 2*c, subClassSet);
        subClassSet.setuint16 (0, count);

        count = 0;
        for (int j = 0; j &lt; classPatterns.getLength (); j++) {
          Element classPattern = (Element) classPatterns.item (j);
          int[] classes = parseIntList (classPattern.getAttribute (&quot;in&quot;));
          if (classes [0] == c) {

            NodeList applies = classPattern.getChildNodes ();
            int applyCount = applies.getLength ();

            Block subClassRule = new Block (4 + 2 * (classes.length - 1)
                                            + 4 * applyCount,
                                            0);

            subClassSet.setOffset (2 + 2*(count++), subClassRule);
            subClassRule.setuint16 (0, classes.length);
            subClassRule.setuint16 (2, applyCount);
            for (int k = 1; k &lt; classes.length; k++) {
              subClassRule.setuint16 (4 + 2*(k-1), classes [k]); }

            subLookupsFromXML (applyCount, applies,
                              subClassRule, 4 + 2*(classes.length-1),
			      lookupIndices); }}}}

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="contextualLookup.toXMLCount_2">
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 4), counts);
</code-fragment>

<code-fragment id="contextualLookup.toXML_2">
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 4), counts);
</code-fragment>

<code-fragment id="contextualLookup.toXMLEmit_2">
    at = new AttributesImpl ();
    coverageTableOffsetToXML (conf, stOffset + getOffset (stOffset + 2), counts,
                              &quot;coverage&quot;, at);

    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, stOffset + getOffset (stOffset + 4), counts,
                              &quot;classDef&quot;, at);

    int classSetCount = getuint16 (stOffset + 6);
    for (int c = 0; c &lt; classSetCount; c++) {
      int xx = getOffset (stOffset + 8 + 2*c);
      if (xx != 0) {
        int classSetOffset = stOffset + xx;

        int classRuleCount = getuint16 (classSetOffset);
        for (int r = 0; r &lt; classRuleCount; r++) {
          int classRuleOffset = classSetOffset
                                + getOffset (classSetOffset + 2 + 2*r);

          at = new AttributesImpl ();

          int glyphCount = getuint16 (classRuleOffset);
          StringBuilder s = new StringBuilder ();
          s.append (&quot;&quot; + c);
          for (int g = 0; g &lt; glyphCount - 1; g++) {
            s.append (&quot; &quot; + getuint16 (classRuleOffset + 4 + 2*g)); }
          at.addAttribute (&quot;&quot;, &quot;in&quot;, &quot;in&quot;, &quot;CDATA&quot;, s.toString ());

          conf.ch.startElement (&quot;pattern&quot;, at); {
            subLookupsToXML (conf, getuint16 (classRuleOffset + 2),
                             classRuleOffset + 4 + 2*(glyphCount-1));
          conf.ch.endElement (&quot;pattern&quot;); }}}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>We start with a procedure that performs the matching for
          a single SubClassRule. When this procedure is called, it is
          known that the glyph run match L<subscript>0</subscript>
          and that L<subscript>0</subscript> is at
          <varname>inPos</varname>. If the glyph run does not match
          the rest of the SubClassRule, then this procedure returns
          null. Otherwise, it returns an array of the glyph run
          positions that where matched, i.e. the positions of
          L<subscript>0</subscript>, L<subscript>1</subscript>,
          …</para>


<code-fragment id="lookuptable.methods">
  <code-title>Procedure to match one GSUB 5/2 sub class rule</code-title>
  int[] matchOneClassRule (GlyphRun gr, int inPos,
                           int classRuleOffset, int classOffset,
                           int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int glyphCount = getuint16 (classRuleOffset);
    int[] matchedPositions = new int [glyphCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int g = 1; g &lt; glyphCount; g++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (   classIndex (gr.glyphAt (inPos), classOffset)
          != getuint16 (classRuleOffset + 4 + 2*(g-1))) {
        return null; }

      matchedPositions [g] = inPos;
      inPos++; }

    return matchedPositions;
  }
</code-fragment>

        <para>With that in place, we can now implement the full
          subtable.</para>

<code-fragment id="contextualLookup_format2">
  <code-title>Execute contextual lookup subtable, format 2, and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int classDefOffset = stOffset + getOffset (stOffset + 4);
    int inPos = curGlyph;

    if (-1 == getCoverageIndex (gr.glyphAt (inPos), coverageOffset)) {
      return lookupNotApplied; }

    int cl = classIndex (gr.glyphAt (inPos), classDefOffset);
    if (cl &gt; getuint16 (stOffset + 6) - 1) {
      return lookupNotApplied; }
    int classSetOffset = getOffset (stOffset + 8 + 2*cl);
    if (classSetOffset == 0) {
      return lookupNotApplied; }
    classSetOffset += stOffset;
    int classRuleCnt = getuint16 (classSetOffset);

    for (int i = 0; i &lt; classRuleCnt; i++) {
      int classRuleOffset
        = classSetOffset + getOffset (classSetOffset + 2 + 2*i);
      int glyphCount = getuint16 (classRuleOffset);

      int[] matchedPositions
        = matchOneClassRule (gr, inPos,
                             classRuleOffset, classDefOffset,
                             lookupIndex, lookupFlag);

      if (matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions [matchedPositions.length-1])) {
        int applyCount = getuint16 (classRuleOffset + 2);
        int applyOffset = classRuleOffset + 4 + 2*(glyphCount-1);
        if (listener != null) {
          listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                     Tag.tag2string (tag), stOffset); }
        return applySubLookups (gr, matchedPositions,
                                applyCount, applyOffset); }}
    return lookupNotApplied; }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

        <section>
          <title>context2_simple: simple case</title>

          <para>Let’s start with a simple test that matches the
          sequence [1=20], [2=21], [3=22]. At each position, we then apply a
          our standard sublookups.</para>

<aots:context-test-font id="context2_simple_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	  <class classID="2" glyphs="21"/>
	  <class classID="3" glyphs="22"/>
	</classDef>

	<pattern in="1 2 3">
	  <apply pos="0" lookup="lookup.single"/>
	  <apply pos="1" lookup="lookup.single"/>
	  <apply pos="2" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_simple_t1" font="context2_simple_f1" inputs="00,  20,   21,   22,   00" outputs="00,  60,   61,   62,   00" xdeltas="0,   20,   20,   20,    0" ydeltas="0,    0,    0,    0,    0"/>

          <para>Here is a test case on the same font that involves partial
          matches input sequence:</para>

          <aots:context-test id="context2_simple_t2" font="context2_simple_f1" inputs="00,  20,  00,  20,  21,  00" outputs="00,  20,  00,  20,  21,  00" xdeltas="0,    0,   0,   0,   0,   0" ydeltas="0,    0,   0,   0,   0,   0"/>

	  <para>When applying a sublookup, that must be done as the
	  position given by the contextual lookup, not to all possible
	  positions in the matched input or beyond:</para>

<aots:context-test-font id="context2_simple_f2">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	</classDef>
	<pattern in="1 1 1">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_simple_t3" font="context2_simple_f2" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  20,   60,   20,   20,   20,   00" xdeltas="0,    0,   20,    0,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>
        </section>

        <section>
          <title>context2_next_glyph</title>

          <para>Our next test verifies that the proper glyph is
	  processed after a contextual lookup it applied. The lookup
	  matches the sequence 20, 20  and applies the standard
	  sublookups to the first occurrence of 20.</para>

<aots:context-test-font id="context2_next_glyph_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	</classDef>
	<pattern in="1 1">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_next_glyph_t1" font="context2_next_glyph_f1" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  60,   20,   60,   20,   20,   00" xdeltas="0,   20,    0,   20,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>

        </section>

        <section>
          <title>context2_boundary</title>

          <para>We test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id="context2_boundary_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	</classDef>
	<pattern in="1 1"/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_boundary_t1" font="context2_boundary_f1" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  20,   20,   20,   20,   20,   00" xdeltas="0,    0,    0,    0,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>

          <para>Another boundary case is when GlyphCount is 1.</para>

<aots:context-test-font id="context2_boundary_f2">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	</classDef>
	<pattern in="1">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

	  <aots:context-test id="context2_boundary_t2" font="context2_boundary_f2" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  60,   60,   60,   60,   60,   00" xdeltas="0,   20,   20,   20,   20,   20,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>
	</section>


        <section>
          <title>context2_multiple_subrules</title>

          <para>The next two tests ensure that the subrules of
          subruleset are applied in the prescribed order. In the first
          one, the matched sequences are 20, 21, 22, with the standard
          sublookups applied on 20, and 20, 21, with the standard
          sublookups applied on 21.</para>

<aots:context-test-font id="context2_multiple_subrules_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	  <class classID="2" glyphs="21"/>
	  <class classID="3" glyphs="22"/>
	</classDef>
	<pattern in="1 2 3">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
	<pattern in="1 2">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

	  <aots:context-test id="context2_multiple_subrules_t1" font="context2_multiple_subrules_f1" inputs="00,  20,   21,   22,   00,   20,   21,   00" outputs="00,  60,   21,   22,   00,   20,   61,   00" xdeltas="0,   20,    0,    0,    0,    0,   20,    0" ydeltas="0,    0,    0,    0,    0,    0,    0,    0"/>

          <para>In the next test, we just invert the order of two
	  subrules.</para>

<aots:context-test-font id="context2_multiple_subrules_f2">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	  <class classID="2" glyphs="21"/>
	  <class classID="3" glyphs="22"/>
	</classDef>
	<pattern in="1 2">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
	<pattern in="1 2 3">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_multiple_subrules_t2" font="context2_multiple_subrules_f2" inputs="00,  20,   21,   22,   00,   20,   21,   00" outputs="00,  20,   61,   22,   00,   20,   61,   00" xdeltas="0,    0,   20,    0,    0,    0,   20,    0" ydeltas="0,    0,    0,    0,    0,    0,    0,    0"/>
        </section>

        <section>
          <title>context2_successive</title>

          <para>In this test, we verify the case described in the
          SubstLookupRecord section. This applies to GSUB contextual
          lookups only. The matched sequence is 20 21 22 23. Glyphs 21
          and 22 are replaced by glyph 61 and glyph 23 is replaced by
          glyph 63. The difficult part is that the lookup that
          replaces 22 is applied at position 2, which is counted after
          the ligature substitution is applied.</para>

<aots:context-test-font id="context2_successive_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	  <class classID="2" glyphs="21"/>
	  <class classID="3" glyphs="22"/>
	  <class classID="4" glyphs="23"/>
	</classDef>
	<pattern in="1 2 3 4">
	  <apply pos="1" lookup="lookup.double"/>
	  <apply pos="2" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_successive_t1" font="context2_successive_f1" inputs="00,  20,   21,   22,  23,   00" outputs="00,  20,   61,        63,   00" xdeltas="0,    0,   20,   20,   0,    0" ydeltas="0,    0,    0,    0,   0,    0"/>
        </section>

        <section>
          <title>context2_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
          sequence is 20 21 22, with standard sublookups applied at
          all three positions.</para>

<aots:context-test-font id="context2_lookupflag_f1">
  <lookup id="lookup.test" type="contextual" ignoreMarks="yes">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	  <class classID="2" glyphs="21"/>
	  <class classID="3" glyphs="22"/>
	</classDef>
	<pattern in="1 2 3">
	  <apply pos="0" lookup="lookup.single"/>
	  <apply pos="1" lookup="lookup.single"/>
	  <apply pos="2" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_lookupflag_t1" font="context2_lookupflag_f1" inputs="00,  20,  90,  21,  91,  92,  22,   00" outputs="00,  60,  90,  61,  91,  92,  62,   00" xdeltas="0,   20,   0,  20,   0,   0,  20,    0" ydeltas="0,    0,   0,   0,   0,   0,   0,    0"/>

	  <para>The interaction between LookupFlag of the contextal
	  substitution and LookupFlag of the sublookups is not very
	  clear. It is certainly desired that any glyph covered by
	  the contextual substitution LookupFlag be invisible to the
	  sublookups; what is unclear is whether this is achieved by
	  constraining legal fonts, or whether CommonType engines have
	  to enforce that behavior. Here is a font that does have
	  consistent LookupFlag, and it should behave properly with
	  all layout engines.</para>

<aots:context-test-font id="context2_lookupflag_f2">
  <lookup id="lookup.test" type="contextual" ignoreMarks="yes">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	  <class classID="2" glyphs="21"/>
	  <class classID="3" glyphs="22"/>
	</classDef>
	<pattern in="1 2 3">
	  <apply pos="1" lookup="lookup.double.nomarks"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_lookupflag_t2" font="context2_lookupflag_f2" inputs="00,  20,  90,  21,  91,  92,  22,   00" outputs="00,  20,  90,  61,  91,  92,        00" xdeltas="0,    0,   0,  20,   0,   0,   0,    0" ydeltas="0,    0,   0,   0,   0,   0,   0,    0"/>
        </section>

        <section>
          <title>context2_expansion</title>

          <para>As we have noted in multiple substitution lookups, the
          glyph run can be expanded. While a chaining lookup does not
          be itself perform that operation, it may invoke a multiple
          substitution lookup.</para>

<aots:context-test-font id="context2_expansion_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage glyphs="20" format="any"/>
	<classDef format="any">
	  <class classID="1" glyphs="20"/>
	  <class classID="2" glyphs="21"/>
	  <class classID="3" glyphs="22"/>
	</classDef>
	<pattern in="1 2 3">
	  <apply pos="1" lookup="lookup.multiple"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_expansion_t1" font="context2_expansion_f1" inputs="00,  20,  21,            22,  00" outputs="00,  20,  61,  62,  63,  22,  00" xdeltas="0,    0,   0,             0,   0" ydeltas="0,    0,   0,             0,   0"/>
        </section>

        <section>
          <title>context2_classes</title>

          <para>So far, we have used a fairly simple class definition,
          with one glyph per class. Time to do something a bit more
          fancy, with a format 2 Class Definition. Note that the
          coverage of the subtable does not include all the glyphs in
          class 1 (the first class in the input pattern), glyph 22 is
          left out.</para>

<aots:context-test-font id="context2_classes_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="2">
	<coverage format="any" glyphs="20 21"/>
	<classDef format="any">
	  <class classID="1" glyphs="20 21 22"/>
	  <class classID="2" glyphs="26 27 28 29"/>
	  <class classID="3" glyphs="24"/>
	</classDef>
	<pattern in="1 2 2 3">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_classes_t1" font="context2_classes_f1" inputs="00, 20, 26, 28, 24, 00, 21, 27, 26, 24, 00, 22, 27, 26, 24" outputs="00, 20, 66, 28, 24, 00, 21, 67, 26, 24, 00, 22, 27, 26, 24" xdeltas=" 0,  0, 20,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0" ydeltas=" 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0"/>

          <para>So far, the covered glyphs have been in a single
            class. Let’s use two SubClassSets, by adding [3] [2] [1]
            as an input sequence.This time, we include glyph 22 in the
            coverage.</para>

<aots:context-test-font id="context2_classes_f2">
  <lookup id="lookup.test" type="contextual">
	<contextual format="2">
	  <coverage format="any" glyphs="20 21 22 24"/>
	  <classDef format="any">
	    <class classID="1" glyphs="20 21 22"/>
	    <class classID="2" glyphs="26 27 28 29"/>
	    <class classID="3" glyphs="24"/>
	  </classDef>
	  <pattern in="1 2 2 3">
	    <apply pos="1" lookup="lookup.single"/>
	  </pattern>
	  <pattern in="3 3 2 1">
	    <apply pos="2" lookup="lookup.single"/>
	  </pattern>
	</contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context2_classes_t2" font="context2_classes_f2" inputs="00, 22, 27, 26, 24, 00, 24, 24, 29, 22, 00, 22, 27, 26, 24" outputs="00, 22, 67, 26, 24, 00, 24, 24, 69, 22, 00, 22, 67, 26, 24" xdeltas=" 0,  0, 20,  0,  0,  0,  0,  0, 20,  0,  0,  0, 20,  0,  0" ydeltas=" 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0"/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Context Substitution Format 3</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Format 3, coverage-based context substitution, defines
          a context rule as a sequence of coverage tables. Each
          position in the sequence may define a different Coverage
          table for the set of glyphs that matches the context
          pattern. With Format 3, the glyph sets defined in the
          different Coverage tables may intersect, unlike Format 2
          which specifies fixed class assignments (identical for each
          position in the context sequence) and exclusive classes (a
          glyph cannot be in more than one class at a time).</para>

        <para>For example, consider an input context that contains a
          lowercase glyph (position 0), followed by an uppercase glyph
          (position 1), either a lowercase or numeral glyph (position
          2), and then either a lowercase or uppercase vowel (position
          3). This context requires four Coverage tables, one for each
          position:</para>

        <itemizedlist>
          <listitem>
            <para>In position 0, the Coverage table lists the set of
              lowercase glyphs.</para>
          </listitem>
          <listitem>
            <para>In position 1, the Coverage table lists the set of
              uppercase glyphs.</para>
          </listitem>
          <listitem>
            <para>In position 2, the Coverage table lists the set of
              lowercase and numeral glyphs, a superset of the glyphs
              defined in the Coverage table for position 0.</para>
          </listitem>
          <listitem>
            <para>In position 3, the Coverage table lists the set of
              lowercase and uppercase vowels, a subset of the glyphs
              defined in the Coverage tables for both positions 0 and
              1.</para>
          </listitem>
          </itemizedlist>

        <para>Unlike Formats 1 and 2, this format defines only one
          context rule at a time. It consists of a format identifier
          (SubstFormat), a count of the glyphs in the sequence to be
          matched (GlyphCount), and an array of Coverage offsets that
          describe the input context sequence (Coverage).</para>


        <blockquote>
          <para>Note: The order of the Coverage tables listed in the
            Coverage array must follow the writing direction. For text
            written from right to left, then the right-most glyph will
            be first. Conversely, for text written from left to right,
            the left-most glyph will be first.</para>
        </blockquote>

        <para>The subtable also contains a count of the
          substitutions to be performed on the input Coverage sequence
          (SubstCount) and an array of SubstLookupRecords
          (SubstLookupRecord) in design order – that is, the order in
          which lookups should be applied to the entire glyph
          sequence.</para>


        <para>Example 9 at the end of this chapter substitutes swash
          glyphs for two out of three glyphs in a sequence.</para>


        <otformat>
          <title>ChainContextSubstFormat3 subtable: Coverage-based
            context glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in the input glyph
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [GlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to Coverage table – from
              beginning of Substitution table – in glyph sequence
              order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords – in design
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>It's probably worth noting that GlyphCount should be
          non-zero.</para>

        <para>It is unclear whether the SubstCount can be 0. At first
          it seems that such a subtable is not interesting, since it
          does nothing. On the other hand, this could be useful to
          prevent the activation of following subtables. The
          recommendation is to explicitly mention that case as
          permitted.</para>

	<para>The pattern matched by this subtable is ▶
	  I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> ◀, where:

	  <itemizedlist>
	    <listitem>
	      <para>i is GlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>i</subscript> is
		Coverage [i] ∖ LookupFlag.</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>This table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Contextual substitution format 3 type</code-title>
  contextualTable |=
    attribute format { &quot;3&quot; },
    element coverage { coverageTableOffset }*,
    subLookups
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  private Block contextLookupFormat3FromXML (Element subtable, Element table,
                                            Map&lt;Element, Block&gt; blockCache,
					    Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    NodeList coverages = subtable.getElementsByTagName (&quot;coverage&quot;);
    int glyphCount = coverages.getLength ();

    NodeList applies = subtable.getElementsByTagName (&quot;apply&quot;);
    int substCount = applies.getLength ();

    me = new Block (6 + 2*glyphCount + 4*substCount, glyphCount);
    me.setuint16 (0, 3);
    me.setuint16 (2, glyphCount);
    me.setuint16 (4, substCount);

    for (int i = 0; i &lt; glyphCount; i++) {
      Element coverage = (Element) coverages.item (i);
      me.setOffset (6 + 2*i, coverageFromXML (coverage, table, blockCache)); }

    subLookupsFromXML (substCount, applies, me, 6 + 2*glyphCount, lookupIndices);

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="contextualLookup.toXMLCount_3">
  for (int c = 0; c &lt; getuint16 (stOffset + 2); c++) {
    coverageTableToXMLCount (stOffset + getOffset (stOffset + 6 + 2*c),
                             counts); }
</code-fragment>

<code-fragment id="contextualLookup.toXML_3">
  for (int c = 0; c &lt; getuint16 (stOffset + 2); c++) {
    coverageTableToXML (conf, stOffset + getOffset (stOffset + 6 + 2*c),
                        counts); }
</code-fragment>

<code-fragment id="contextualLookup.toXMLEmit_3">
    int glyphCount = getuint16 (stOffset + 2);
    for (int c = 0; c &lt; glyphCount; c++) {
      at = new AttributesImpl ();
      coverageTableOffsetToXML (conf, stOffset + getOffset (stOffset + 6 + 2*c),
                                counts, &quot;coverage&quot;, at); }

    subLookupsToXML (conf, getuint16 (stOffset + 4), stOffset + 6 + 2*glyphCount);
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="contextualLookup_format3">
  <code-title>Execute contextual lookup subtable, format 3, and return</code-title>
  { int glyphCount = getuint16 (stOffset + 2);
    int inPos = curGlyph;
    int [] matchedPositions = new int [glyphCount];

    for (int i = 0; i &lt; glyphCount; i++) {
      if (i != 0) {
        while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
          inPos++; }}

      if (-1 == getCoverageIndex (gr.glyphAt (inPos),
                                  stOffset + getOffset (stOffset + 6 + 2*i))) {
        return lookupNotApplied; }

      matchedPositions [i] = inPos;
      inPos++; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph,
          matchedPositions [matchedPositions.length-1])) {
      return lookupNotApplied; }

    int applyCount = getuint16 (stOffset + 4);
    int applyOffset = stOffset + 6 + 2*glyphCount;
    if (listener != null) {
      listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                 Tag.tag2string (tag), stOffset); }

    return applySubLookups (gr, matchedPositions, applyCount, applyOffset); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

        <section>
          <title>context3_simple</title>

          <para>Let’s start with a simple test that matches the
	  sequence [0=20] [1=21] [2=22]. At each position, we then
	  apply our standard sublookups.</para>

<aots:context-test-font id="context3_simple_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="3">
	<coverage glyphs="20" format="any"/>
	<coverage glyphs="21" format="any"/>
	<coverage glyphs="22" format="any"/>
	<apply pos="0" lookup="lookup.single"/>
	<apply pos="1" lookup="lookup.single"/>
	<apply pos="2" lookup="lookup.single"/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context3_simple_t1" font="context3_simple_f1" inputs="00, 20, 21, 22, 00" outputs="00, 60, 61, 62, 00" xdeltas=" 0, 20, 20, 20,  0" ydeltas=" 0,  0,  0,  0,  0"/>

          <para>Here is a test case on the same font that involves partial
            matches input sequence:</para>

          <aots:context-test id="context3_simple_t2" font="context3_simple_f1" inputs="00, 20, 00, 20, 21, 00, 20, 21, 22, 00" outputs="00, 20, 00, 20, 21, 00, 60, 61, 62, 00" xdeltas=" 0,  0,  0,  0,  0,  0, 20, 20, 20,  0" ydeltas=" 0,  0,  0,  0,  0,  0,  0,  0,  0,  0"/>
        </section>

        <section>
          <title>context3_next_glyph</title>

          <para>Our next test verifies that the proper glyph is
          processed after a Type 5 lookup it applied. The lookup
          matches the sequence 20, 20, and applies the standard
          sublookups.</para>

<aots:context-test-font id="context3_next_glyph_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="3">
	<coverage glyphs="20" format="any"/>
	<coverage glyphs="20" format="any"/>
	<apply pos="0" lookup="lookup.single"/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context3_next_glyph_t1" font="context3_next_glyph_f1" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  60,   20,   60,   20,   20,   00" xdeltas="0,   20,    0,   20,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>
        </section>

        <section>
          <title>context3_boundary</title>

          <para>Next, we test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id="context3_boundary_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="3">
	<coverage glyphs="20" format="any"/>
	<coverage glyphs="20" format="any"/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context3_boundary_t1" font="context3_boundary_f1" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  20,   20,   20,   20,   20,   00" xdeltas="0,    0,    0,    0,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>

          <para>Another boundary case is when GlyphCount is 1 (it is
          less interesting than in the other Type 5 subtable formats,
          but we may as well include it anyway).</para>

<aots:context-test-font id="context3_boundary_f2">
  <lookup id="lookup.test" type="contextual">
    <contextual format="3">
	<coverage glyphs="20" format="any"/>
	<apply pos="0" lookup="lookup.single"/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context3_boundary_t2" font="context3_boundary_f2" inputs="00,  20,   20,   20,   20,   20,   00" outputs="00,  60,   60,   60,   60,   60,   00" xdeltas="0,   20,   20,   20,   20,   20,    0" ydeltas="0,    0,    0,    0,    0,    0,    0"/>
        </section>


        <section>
          <title>context3_successive</title>

          <para>In this test, we verify the case described in the
	  SubstLookupRecord section. The matched sequence is 18 19
	  20 21. Glyphs 19 and 20 are replaced by glyph 23 and glyph
	  21 is replaced by glyph 24. The difficult part is that the
	  lookup that replaces 21 by 24 is applied at position 2,
	  which is counted after the ligature substitution is
	  applied.</para>

<aots:context-test-font id="context3_successive_f1">
  <lookup id="lookup.test" type="contextual">
    <contextual format="3">
	<coverage glyphs="20" format="any"/>
	<coverage glyphs="21" format="any"/>
	<coverage glyphs="22" format="any"/>
	<coverage glyphs="23" format="any"/>

	<apply pos="1" lookup="lookup.double"/>
	<apply pos="2" lookup="lookup.single"/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context3_successive_t1" font="context3_successive_f1" inputs="00,  20,   21,   22,  23,   00" outputs="00,  20,   61,        63,   00" xdeltas="0,    0,   20,   20,   0,    0" ydeltas="0,    0,    0,    0,   0,    0"/>
        </section>

        <section>
          <title>context3_lookupflag</title>

          <para>Our next test case involves lookupFlag. The input sequence
	  is 18 19 20, and at each position the glyphID is increased by
	  4. Glyph 26 is covered by lookupFlag.</para>

<aots:context-test-font id="context3_lookupflag_f1">
  <lookup id="lookup.test" type="contextual" ignoreMarks="yes">
    <contextual format="3">
	<coverage glyphs="20" format="any"/>
	<coverage glyphs="21" format="any"/>
	<coverage glyphs="22" format="any"/>

	<apply pos="0" lookup="lookup.single"/>
	<apply pos="1" lookup="lookup.single"/>
	<apply pos="2" lookup="lookup.single"/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context3_lookupflag_t1" font="context3_lookupflag_f1" inputs="00,  20,  90,  21,  91,  92,  22,   00" outputs="00,  60,  90,  61,  91,  92,  62,   00" xdeltas="0,   20,   0,  20,   0,   0,  20,    0" ydeltas="0,    0,   0,   0,   0,   0,   0,    0"/>

	  <para>The interaction between LookupFlag of the contextal
	  substitution and LookupFlag of the sublookups is not very
	  clear. It is certainly desired that any glyph covered by
	  the contextual substitution LookupFlag be invisible to the
	  sublookups; what is unclear is whether this is achieved by
	  constraining legal fonts, or whether CommonType engines have
	  to enforce that behavior. Here is a font that does have
	  consistent LookupFlag, and it should behave properly with
	  all layout engines.</para>

<aots:context-test-font id="context3_lookupflag_f2">
  <lookup id="lookup.test" type="contextual" ignoreMarks="yes">
    <contextual format="3">
	<coverage glyphs="20" format="any"/>
	<coverage glyphs="21" format="any"/>
	<coverage glyphs="22" format="any"/>

	<apply pos="1" lookup="lookup.double.nomarks"/>
    </contextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="context3_lookupflag_t2" font="context3_lookupflag_f2" inputs="00,  20,  90,  21,  91,  92,  22,   00" outputs="00,  20,  90,  61,  91,  92,        00" xdeltas="0,    0,   0,  20,   0,   0,   0,    0" ydeltas="0,    0,   0,   0,   0,   0,   0,    0"/>

	</section>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Lookup Type 6: Chaining Contextual Substitution Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>A Chaining Contextual Substitution subtable
          (ChainContextSubst) describes glyph substitutions in context
          with an ability to look back and/or look ahead in the
          sequence of glyphs. The design of the Chaining Contextual
          Substitution subtable is parallel to that of the Contextual
          Substitution subtable, including the availability of three
          formats for handling sequences of glyphs, glyph classes, or
          glyph sets. Each format can describe one or more backtrack,
          input, and lookahead sequences and one or more substitutions
          for each sequence.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

	<para>In all three formats, the sequences are represented by
	  arrays. The order in those arrays is <emphasis>away from the
	  current position</emphasis>. In other words, if
	  <emphasis>i</emphasis> is the current position, then the
	  first element of the backtrack array is matched against the
	  glyph at position <emphasis>i-1</emphasis> (ignoring glyphs
	  covered by LookupFlag, as usual), and the last element of
	  the backtrack array is matched against the glyph at position
	  <emphasis>i - BacktrackGlyphCount</emphasis>. The first
	  element of the lookahead array is matched against the glyph
	  at position <emphasis>i + InputGlyphCount</emphasis>, and
	  the last element in that array is matched against the glyph
	  as position <emphasis>i + InputGlyphCount +
	  LookaheadGlyphCount - 1</emphasis>.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a chaining contextual
	  substitution, but instead would prefer the compiler to
	  figure out the best representation.:</para>

<code-fragment id="schema">
  <code-title>ChainingContextualSubst type</code-title>
  chainingContextualTable |=
    attribute format { &quot;any&quot; },
    element subst {
      attribute in { text },
      attribute out { text },
      subLookups
    }*

  standaloneChainingContextualTable =
    element chainingContextualTable {
      attribute id { text },
      chainingContextualTable
    }

  chainingContextualTableOffset = attribute name { text }
    | chainingContextualTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  <code-title>Compile chainingContextualSubst lookups</code-title>
  protected Block chainingLookupFromXML (Element lookupSubtable,
                                         Element table,
                                         Map&lt;Element, Block&gt; blockCache,
					 Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    String format = lookupSubtable.getAttribute (&quot;format&quot;);
    if (&quot;1&quot;.equals (format)) {
      return chainingLookupFormat1FromXML (lookupSubtable, table,
                                             blockCache, lookupIndices); }
    if (&quot;2&quot;.equals (format)) {
      return chainingLookupFormat2FromXML (lookupSubtable, table,
                                             blockCache, lookupIndices); }
    if (&quot;3&quot;.equals (format)) {
      return chainingLookupFormat3FromXML (lookupSubtable, table,
                                             blockCache, lookupIndices); }
    /* cannot get there with a valid document */
    throw new InvalidFontException
            (&quot;invalid format for contextual chaining lookup (&quot; + format + &quot;)&quot;);
}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  public void chainingLookupToXMLCount (int stOffset, int[] counts) {

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend="chainingLookup.toXMLCount_1"/>; break; }
      case 2: { <code-include linkend="chainingLookup.toXMLCount_2"/>; break; }
      case 3: { <code-include linkend="chainingLookup.toXMLCount_3"/>; break; }}
  }

  public void chainingLookupToXML (DecompilerConfig conf,
                                   int stOffset, int[] counts)
     throws org.xml.sax.SAXException, InvalidFontException {

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend="chainingLookup.toXML_1"/>; break; }
      case 2: { <code-include linkend="chainingLookup.toXML_2"/>; break; }
      case 3: { <code-include linkend="chainingLookup.toXML_3"/>; break; }}
  }

  public void chainingLookupToXMLEmit (DecompilerConfig conf,
                                       int stOffset, int[] counts)
     throws org.xml.sax.SAXException, InvalidFontException {

    AttributesImpl at;

    switch (getuint16 (stOffset)) {
      case 1: { <code-include linkend="chainingLookup.toXMLEmit_1"/>; break; }
      case 2: { <code-include linkend="chainingLookup.toXMLEmit_2"/>; break; }
      case 3: { <code-include linkend="chainingLookup.toXMLEmit_3"/>; break; }}
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>As usual, all subtable formats start with the same
          field, the uint16 SubstFormat, which we use to
          dispatch:</para>

<code-fragment id="lookuptable.methods">
  <code-title>Execute GSUB 6 subtable and return</code-title>
  public LookupResult applyChainingContextualLookupSubtable
                          (int lookupIndex, int lookupType, int lookupFlag,
                           int stOffset, GlyphRun gr, int curGlyph)
      throws InvalidFontException {

    int substFormat = getuint16 (stOffset);

    switch (substFormat) {
      case 1: { <code-include linkend="chainingLookup_format1"/> }
      case 2: { <code-include linkend="chainingLookup_format2"/> }
      case 3: { <code-include linkend="chainingLookup_format3"/> }
      default:
        throw new InvalidFontException (&quot;GSUB 6/-&quot; + substFormat + &quot;-&quot;); }}
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Chaining Context Substitution Format 1: Simple Chaining
        Context Glyph Substitution</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Format 1 defines the context for a glyph substitution
          as a particular sequence of glyphs. For example, a context
          could be &lt;xyz&gt;, &lt;holiday&gt;, &lt;!?*#@&gt;, or any other glyph
          sequence.</para>

        <para>Within a context sequence, Format 1 identifies
          particular glyph positions (not glyph indices) as the
          targets for specific substitutions. When a text-processing
          client locates a context in a string of text, it finds the
          lookup data for a targeted position and makes a substitution
          by applying the lookup data at that location.</para>

        <para>To specify the context, the coverage table lists the
          first glyph in the input sequence, and the ChainSubRule
          subtable defines the rest. Once a covered glyph is found at
          position i, the client reads the corresponding
          ChainSubRuleSet table and examines each table to determine
          if it matches the surrounding glyphs in the text. There is a
          match if the string &lt;backtrack sequence&gt; + &lt;covered
          glyph&gt; + &lt;input sequence&gt;+&lt;lookahead sequence&gt; matches
          with the glyphs at position i - BacktrackGlyphCount in the
          text.</para>

	<para>To clarify the ordering of glyph arrays for input,
	  backtrack and lookahead sequences, the following
	  illustration is provided. Input sequence match begins at i
	  where the input sequence match begins. The backtrack
	  sequence is ordered beginning at i - 1 and increases in
	  offset value as one moves away from i. The lookahead
	  sequence begins after the input sequence and increases in
	  logical order.</para>

<literallayout>
Logical order      - a  b  c  d  e  f  g  h  i  j
                                 i
Input sequence -                 0  1
Backtrack sequence - 3  2  1  0
Lookahead sequence -                   0  1  2  3
</literallayout>


        <para>If there is a match, then the client finds the target
          glyph positions for substitutions and completes the
          substitutions. Please note that (just like in the
          ContextSubstFormat1 subtable) these lookups are required to
          operate within the range of text from the covered glyph to
          the end of the input sequence. No substitutions can be
          defined for the backtracking sequence or the lookahead
          sequence.</para>

        <para>Once the substitutions are complete, the client should
          move to the glyph position <emphasis>immediately following
            the matched input sequence</emphasis> and resume the
          lookup process from there.</para>

        <para>A single ChainContextSubstFormat1 subtable may define
          more than one context glyph sequence. If different context
          sequences begin with the same glyph, then the Coverage table
          should list the glyph only once because all glyphs in the
          table must be unique. For example, if three contexts each
          start with an &quot;s&quot; and two start with a &quot;t,&quot; then the
          Coverage table will list one &quot;s&quot; and one &quot;t.&quot;</para>

        <para>All of the ChainSubRule tables defining contexts that
          begin with the same first glyph are grouped together and
          defined in a ChainSubRuleSet table. For example, the
          ChainSubRule tables that define the three contexts that
          begin with an &quot;s&quot; are grouped in one ChainSubRuleSet table,
          and the ChainSubRule tables that define the two contexts
          that begin with a &quot;t&quot; are grouped in a second
          ChainSubRuleSet table. Each glyph listed in the Coverage
          table must have a ChainSubRuleSet table defining all the
          ChainSubRule tables that apply to a covered glyph.</para>


        <para>A ChainContextSubstFormat1 subtable contains a format
          identifier (SubstFormat), an offset to a Coverage table
          (Coverage), a count of defined ChainSubRuleSets
          (ChainSubRuleSetCount), and an array of offsets to the
          ChainSubRuleSet tables (ChainSubRuleSet). As mentioned, one
          ChainSubRuleSet table must be defined for each glyph listed
          in the Coverage table.</para>

        <para>In the ChainSubRuleSet array, the ChainSubRuleSet
          table offsets are ordered in the Coverage Index order. The
          first ChainSubRuleSet in the array applies to the first
          GlyphID listed in the Coverage table, the second
          ChainSubRuleSet in the array applies to the second GlyphID
          listed in the Coverage table, and so on.</para>

        <otformat>
          <title>ChainContextSubstFormat1 subtable: Simple context
            glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table – from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainSubRuleSetCount</otfieldname>
            <otfielddesc>Number of ChainSubRuleSet tables – must equal
              GlyphCount in Coverage table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainSubRuleSet [ChainSubRuleSetCount]</otfieldname>
            <otfielddesc>Array of offsets to ChainSubRuleSet tables
              – from beginning of Substitution table –
              ordered by Coverage Index</otfielddesc>
          </otfield>
        </otformat>

        <para>A ChainSubRuleSet table consists of an array of
          offsets to ChainSubRule tables (ChainSubRule), ordered by
          preference, and a count of the ChainSubRule tables defined
          in the set (ChainSubRuleCount).</para>

        <para>The order in the ChainSubRule array can be
          critical. Consider two contexts, &lt;abc&gt; and &lt;abcd&gt;. If
          &lt;abc&gt; is first in the ChainSubRule array, all instances
          of &lt;abc&gt; in the text – including all instances of
          &lt;abcd&gt; – will be changed. If &lt;abcd&gt; comes first in the
          array, however, only &lt;abcd&gt; sequences will be changed,
          without affecting any instances of &lt;abc&gt;.</para>

        <otformat>
            <title>ChainSubRuleSet table: All contexts beginning with
            the same glyph</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainSubRuleCount</otfieldname>
            <otfielddesc>Number of ChainSubRule tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainSubRule [ChainSubRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to ChainSubRule tables – from
              beginning of ChainSubRuleSet table – ordered by
              preference</otfielddesc>
          </otfield>
        </otformat>

        <para>A ChainSubRule table consists of a count of the glyphs
          to be matched in the backtrack, input, and lookahead context
          sequences, including the first glyph in each sequence, and
          an array of glyph indices that describe each portion of the
          contexts. The Coverage table specifies the index of the
          first glyph in each context, and each array begins with the
          second glyph (array index = 1) in the context
          sequence.</para>

        <blockquote>
          <para>Note: All arrays list the indices in the order the
            corresponding glyphs appear in the text. For text written
            from right to left, the right-most glyph will be first;
            conversely, for text written from left to right, the
            left-most glyph will be first.</para>
        </blockquote>

        <para>A ChainSubRule table also contains a count of the
          substitutions to be performed on the input glyph sequence
          (SubstCount) and an array of SubstitutionLookupRecords
          (SubstLookupRecord). Each record specifies a position in the
          input glyph sequence and a LookupListIndex to the
          substitution lookup that is applied at that positon. The
          array should list records in design order, or the order the
          lookups should be applied to the entire glyph
          sequence.</para>

        <otformat>
          <title>ChainSubRule subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BacktrackGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the backtrack
              sequence (number of glyphs to be matched before the
              first glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Backtrack [BacktrackGlyphCount]</otfieldname>
            <otfielddesc>Array of backtracking GlyphID's (to be
              matched before the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2+n</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>InputGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the input sequence
              (includes the first glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Input [InputGlyphCount-1]</otfieldname>
            <otfielddesc>Array of input GlyphIDs (start with second
              glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+m</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookaheadGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the look ahead
              sequence (number of glyphs to be matched after the input
              sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n+m</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>LookAhead [LookAheadGlyphCount]</otfieldname>
            <otfielddesc>Array of lookahead GlyphID's (to be matched
              after the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n+m+p</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8+n+m+p</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords (in design
              order)</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>Second paragraph: &quot;... locates a context in a string of
          text, ...&quot; shoud be replaced by &quot;... locates a context in a
          string of glyphs, ...&quot;. Similarly, in the third paragraph,
          replace the last word, &quot;text&quot;, by &quot;gyph string&quot;.</para>

        <para>Third paragraph, second sentence: add &quot;ChainSubRule&quot; in
          &quot;examines each table&quot;.</para>

        <para>To a consistent language, the last paragraph before the
          ChainContextSubtFormat1 table, and the last sentence of the
          previous paragraph, should be replaced by: &quot;The Coverage
          index of the first input glyph is used to index the
          ChainSubRuleSet array and ChainSubRuleSetCount must equal
          the number of glyphs covered by Coverage. The entries in the
          ChainSubRuleSet array cannot be NULL.&quot;</para>

        <para>The paragraph describing the impact of the order in the
          ChainSubRule array is a bit misleading. The recommendation
          is to change the last two sentences by &quot;If &lt;abc&gt; is first
          in the ChainSubRule array, the corresponding ChainSubRule
          subtable will be applied first to all instances of &lt;abc&gt;
          in the glyph string – including all instances of
          &lt;abcd&gt; –. If &lt;abcd&gt; comes first in the array,
          the corresponding ChainSubRule subtable will be applied
          applied first to all instances of &lt;abcd&gt;.&quot;</para>


        <para>It is unclear whether the ChainSubRuleCount of a
          ChainSubRuleSet table can be 0. We assume that
          ChainSubRuleCount must be at least 1 and recommend that it
          be spelled out in the specification.</para>

        <para>It is unclear whether the InputGlyphCount of a
          ChainSubRule can be 0 or 1. The value 0 is most certainly
          illegal (since a ChainSubRule table is used in the context
          of a first glyph match). We assume that the value 1 is
          legal, eventhough it is difficult to exhibit an interesting
          use of that case.</para>

        <para>It is unclear whether the SubstCount of a SubRule can be
          0. At first it seems that such a SubRule could be removed,
          since it does nothing. On the other hand, this could be
          useful to prevent the activation of following SubRules; e.g.
          if one wanted the sequence &lt;abc&gt; modified, but not the
          sequence &lt;abcd&gt;.  The recommendation is to explicitly
          mention that case as permitted.</para>

        <para>There is a little ambiguity about the next glyph to
          process: consider the case where some glyphs captured by
          LookupFlag are present between the input glyphs and the
          lookahead glyphs. Should the processing continue with the
          first glyph following with input glyphs, i.e. with the first
          glyph captured by LookupFlag, or should it continue with the
          first lookahead glyph? Whether this matters depends quite on
          bit whether the LookupFlag of a context substitution is
          inherited (either by definition or by constraint on the
          valid font files), and therefore whether a lookup in
          SubstLookupRecord can or cannot change those glyphs.</para>


	<para>The pattern matched by the ChainSubRule table t = ChainSubRuleSet
	  [m].ChainSubRule [n] is

	  B<subscript>b-1</subscript> L* ... L* B<subscript>0</subscript>
          ▶ I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> ◀
          L* A<subscript>0</subscript> L*
	  ... L* A<subscript>a-1</subscript>, where:

	  <itemizedlist>
	    <listitem>
	      <para>b is t.BacktrackGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>i is t.InputGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>a is t.LookaheadGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>B<subscript>k</subscript> is {t.Backtrack [k]} ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>0</subscript> is {Coverage[m]} ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is {t.Input[k-1]} ∖ LookupFlag, for k &gt; 0</para>
	    </listitem>
	    <listitem>
	      <para>A<subscript>k</subscript> is {t.LookAhead[k]} ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubRule table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current
	  position.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Chaining contextual substitution format 1 type</code-title>
  chainingContextualTable |=
    attribute format { &quot;1&quot; },
    element coverage { coverageTableOffset }?,
    element pattern {
      attribute back { text },
      attribute in { text },
      attribute ahead { text },
      subLookups
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  private Block chainingLookupFormat1FromXML (Element subtable, Element table,
                                              Map&lt;Element, Block&gt; blockCache,
                                              Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;
    Element firstChild = (Element) subtable.getFirstChild ();

    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith (&quot;coverage&quot;))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    NodeList rules = subtable.getChildNodes ();
    int rulesCount = rules.getLength ();

    int [] firstGlyphs = new int [rulesCount];
    for (int i = 0; i &lt; rulesCount; i++) {
      Element rule = (Element) rules.item (i);
      firstGlyphs [i] = getGlyphs (rule.getAttribute (&quot;in&quot;)) [0]; }

    if (coverage == null) {
      int [] coveredGlyphs = new int [rulesCount];
      int count = 0;
      for (int i = 0; i &lt; rulesCount; i++) {
        int glyph = firstGlyphs [i];
        boolean addIt = true;
        for (int j = 0; j &lt; count; j++) {
          if (glyph == coveredGlyphs [j]) {
            addIt = false;
            break; }}
        if (addIt) {
          coveredGlyphs [count++] = glyph; }}
      coverage = coverageFromGlyphs (coveredGlyphs, count); }

    me = new Block (6 + 2 * coverage.glyphs.length,
                    1 + coverage.glyphs.length);
    me.setuint16 (0, 1);
    me.setOffset (2, coverage);
    me.setuint16 (4, coverage.glyphs.length);

    for (int g = 0; g &lt; coverage.glyphs.length; g++) {
      // count the number of subst that start with coverage.glyph [g]
      int nodeCount = 0;
      for (int j = 0; j &lt; rulesCount; j++) {
        if (firstGlyphs [j] == coverage.glyphs [g]) {
          nodeCount++; }}

      Block subRuleSetTable = new Block (2 + 2*nodeCount, nodeCount);
      subRuleSetTable.setuint16 (0, nodeCount);
      nodeCount = 0;
      me.setOffset (6 + 2*g, subRuleSetTable);

      for (int j = 0; j &lt; rulesCount; j++) {
        if (firstGlyphs [j] == coverage.glyphs [g]) {

          Element rule = (Element) rules.item (j);
          int [] backtrack = getGlyphs (rule.getAttribute (&quot;back&quot;));
          int [] in        = getGlyphs (rule.getAttribute (&quot;in&quot;));
          int [] lookahead = getGlyphs (rule.getAttribute (&quot;ahead&quot;));

          NodeList substs = rule.getChildNodes ();
          int substCount = substs.getLength ();

          Block subRuleTable = new Block (  2 + 2 * backtrack.length
                                          + 2 + 2 * (in.length - 1)
                                          + 2 + 2 * lookahead.length
                                          + 2 + 4 * substCount, 0);
          subRuleSetTable.setOffset (2 + 2* (nodeCount++),
                                          subRuleTable);
          int offset = 0;
          subRuleTable.setuint16 (offset, backtrack.length);
          offset += 2;
          for (int k = backtrack.length - 1; k &gt;= 0; k--) {
            subRuleTable.setGlyphID (offset, backtrack [k]);
            offset += 2; }
          subRuleTable.setuint16 (offset, in.length);
          offset += 2;
          for (int k = 1; k &lt; in.length; k++) {
            subRuleTable.setGlyphID (offset, in [k]);
            offset += 2; }
          subRuleTable.setuint16 (offset, lookahead.length);
          offset += 2;
          for (int k = 0; k &lt; lookahead.length; k++) {
            subRuleTable.setGlyphID (offset, lookahead [k]);
            offset += 2; }
          subRuleTable.setuint16 (offset, substCount);
          offset += 2;

	  offset += subLookupsFromXML (substCount, substs, subRuleTable, offset,
				      lookupIndices); }}}

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="chainingLookup.toXMLCount_1">
  /* nothing */
</code-fragment>

<code-fragment id="chainingLookup.toXML_1">
  /* nothing */
</code-fragment>

<code-fragment id="chainingLookup.toXMLEmit_1">
    int ruleSetCount = getuint16 (stOffset + 4);
    int[] coveredGlyphs = getCoveredGlyphs (stOffset + getOffset (stOffset + 2));

    for (int ruleSet = 0; ruleSet &lt; ruleSetCount; ruleSet++) {
      int ruleSetOffset = stOffset + getOffset (stOffset + 6 + 2*ruleSet);
      int ruleCount = getuint16 (ruleSetOffset);

      for (int rule = 0; rule &lt; ruleCount; rule++) {
        int o = ruleSetOffset + getOffset (ruleSetOffset + 2 + 2*rule);
        at = new AttributesImpl ();

        { int backGlyphCount = getuint16 (o);
          o += 2;
          o += (backGlyphCount - 1) * 2;
          StringBuilder s = new StringBuilder ();
          for (int g = 0; g &lt; backGlyphCount; g++) {
            glyphToXML (conf, s, getuint16 (o));
            o -= 2; }
          o += (backGlyphCount + 1) * 2;
          at.addAttribute (&quot;&quot;, &quot;back&quot;, &quot;back&quot;, &quot;CDATA&quot;, s.toString ()); }

        { int inGlyphCount = getuint16 (o);
          o += 2;
          StringBuilder s = new StringBuilder ();
          glyphToXML (conf, s, coveredGlyphs [ruleSet]);
          for (int g = 0; g &lt; inGlyphCount - 1; g++) {
            glyphToXML (conf, s, getuint16 (o));
            o += 2; }
          at.addAttribute (&quot;&quot;, &quot;in&quot;, &quot;in&quot;, &quot;CDATA&quot;, s.toString ()); }

        { int aheadGlyphCount = getuint16 (o);
          o += 2;
	  StringBuilder s = new StringBuilder ();
          for (int g = 0; g &lt; aheadGlyphCount; g++) {
	    glyphToXML (conf, s, getuint16 (o));
            o += 2; }
          at.addAttribute (&quot;&quot;, &quot;ahead&quot;, &quot;ahead&quot;, &quot;CDATA&quot;, s.toString ()); }

        conf.ch.startElement (&quot;pattern&quot;, at); {
          int subCount = getuint16 (o);
          o += 2;
          subLookupsToXML (conf, subCount, o);
          conf.ch.endElement (&quot;pattern&quot;); }}}
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>We start with a procedure that performs the matching of
          a single sub rule. When this procedure is called, it is
          known that the glyph run matched
          I<subscript>0</subscript> and that I<subscript>0</subscript>
          is at <varname>inPos</varname>. If the rest of the pattern
          (i.e. the glyphs in the subrule) is not matched, then this
          procedure returns <varname>null</varname>. Otherwise, it
          returns an array of the glyph run positions for the input
          glyphs, i.e. the positions of I<subscript>0</subscript>,
          I<subscript>1</subscript>, …</para>

        <para>Note that the organization of this procedure matches the
          organization of the subtable: I<subscript>0</subscript> is
          recorded in the Coverage of the subtable, and
          I<subscript>1</subscript>, … are recorded in a
          ChainSubRule table; essentially this procedure takes care of
          one ChainSubRule table.</para>

<code-fragment id="lookuptable.methods">
  <code-title>Method to match one GSUB 6/1 ChainSubRule</code-title>
  int[] matchOneChainRule (GlyphRun gr, int inPos, int ruleOffset,
                              int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int backtrackGlyphCount = getuint16 (ruleOffset);
    int inputGlyphCount = getuint16 (ruleOffset + 2
                                     + 2*backtrackGlyphCount);
    int lookaheadGlyphCount = getuint16 (ruleOffset + 4
                                         + 2*backtrackGlyphCount
                                         + 2*(inputGlyphCount - 1));

    int backPos = inPos - 1;
    for (int b = 0;  b &lt; backtrackGlyphCount; b++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (backPos))) {
        backPos--; }

      if (gr.glyphAt (backPos) != getGlyphID (ruleOffset + 2 + 2*b)) {
        return null; }

      backPos--; }


    int [] matchedPositions = new int [inputGlyphCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int i = 1; i &lt; inputGlyphCount; i++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (gr.glyphAt (inPos) != getGlyphID (ruleOffset + 4
                                           + 2*backtrackGlyphCount + 2*(i-1))) {
        return null; }

      matchedPositions [i] = inPos;
      inPos++; }

    for (int l = 0; l &lt; lookaheadGlyphCount; l++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (gr.glyphAt (inPos) != getGlyphID (ruleOffset + 6
                                           + 2*backtrackGlyphCount
                                           + 2*(inputGlyphCount-1) + 2*l)) {
        return null; }

      inPos++; }

    return matchedPositions;
  }
</code-fragment>

        <para>With that in place, we can now implement the full
          subtable.</para>

<code-fragment id="chainingLookup_format1">
  <code-title>Execute GSUB 6/1 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    int ci = getCoverageIndex (gr.glyphAt (inPos), coverageOffset);
    if (ci == -1) {
      return lookupNotApplied; }

    int ruleSetOffset = stOffset + getOffset (stOffset + 6 + 2*ci);
    int ruleCount = getuint16 (ruleSetOffset);

    for (int s = 0; s &lt; ruleCount; s++) {
      int ruleOffset = ruleSetOffset + getOffset (ruleSetOffset + 2 + 2*s);

      int [] matchedPositions
        = matchOneChainRule (gr, inPos, ruleOffset,
                                lookupIndex, lookupFlag);

      if (matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions[matchedPositions.length-1])) {
        int backtrackGlyphCount = getuint16 (ruleOffset);
        int inputGlyphCount = getuint16 (ruleOffset + 2
                                         + 2*backtrackGlyphCount);
        int lookaheadGlyphCount = getuint16 (ruleOffset + 4
                                             + 2*backtrackGlyphCount
                                             + 2*(inputGlyphCount -1));
        int applyCountOffset = ruleOffset + 6
                                    + 2*backtrackGlyphCount
                                    + 2*(inputGlyphCount - 1)
                                    + 2*lookaheadGlyphCount;
        int applyCount = getuint16 (applyCountOffset);
        int applyOffset = applyCountOffset + 2;
        if (listener != null) {
          listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                     Tag.tag2string (tag), stOffset); }
        return applySubLookups (gr, matchedPositions, applyCount, applyOffset); }}

    return lookupNotApplied; }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Test Suite</title>

        <section>
          <title>chaining1_simple</title>

          <para>A simple test to start.</para>

<aots:context-test-font id="chaining1_simple_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="20" in="21 22" ahead="23">
	  <apply pos="0" lookup="lookup.single"/>
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining1_simple_t1" font="chaining1_simple_f1" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   62,   23,   00" xdeltas="0,    0,   20,   20,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Our next set of tests verifies partial matches. It
	  uses slightly more complicated pattern: 20 21 : 22 23 24 :
	  25 26, with a standard sublookup applied on 22.</para>

<aots:context-test-font id="chaining1_simple_f2">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="20 21" in="22 23 24" ahead="25 26">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <para>First, let’s verify that the substitution works:</para>

          <aots:context-test id="chaining1_simple_t2" font="chaining1_simple_f2" inputs="00, 20,  21,  22,  23,  24,  25,  26,  00" outputs="00, 20,  21,  62,  23,  24,  25,  26,  00" xdeltas="0,   0,   0,  20,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Partial match on the lookahead:</para>

          <aots:context-test id="chaining1_simple_t3" font="chaining1_simple_f2" inputs="00, 20,  21,  22,  23,  24,  25,  00,  00" outputs="00, 20,  21,  22,  23,  24,  25,  00,  00" xdeltas="0,   0,   0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Not enough for the lookahead:</para>

          <aots:context-test id="chaining1_simple_t4" font="chaining1_simple_f2" inputs="00, 20,  21,  22,  23,  24,  25" outputs="00, 20,  21,  22,  23,  24,  25" xdeltas="0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0"/>

          <para>No glyphs at all for lookahead:</para>

          <aots:context-test id="chaining1_simple_t5" font="chaining1_simple_f2" inputs="00, 20,  21,  22,  23,  24" outputs="00, 20,  21,  22,  23,  24" xdeltas="0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0"/>

          <para>Partial match on backtrack:</para>

          <aots:context-test id="chaining1_simple_t6" font="chaining1_simple_f2" inputs="00, 00,  21,  22,  23,  24,  25,  26,  00" outputs="00, 00,  21,  22,  23,  24,  25,  26,  00" xdeltas="0,   0,   0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Not enough for the backtrack:</para>

          <aots:context-test id="chaining1_simple_t7" font="chaining1_simple_f2" inputs=" 21,  22,  23,  24,  25,  26,  00" outputs=" 21,  22,  23,  24,  25,  26,  00" xdeltas="  0,   0,   0,   0,   0,   0,   0" ydeltas="  0,   0,   0,   0,   0,   0,   0"/>

          <para>No glyphs for backtrack at all:</para>

          <aots:context-test id="chaining1_simple_t8" font="chaining1_simple_f2" inputs="22,  23,  24,  25,  26,  00" outputs="22,  23,  24,  25,  26,  00" xdeltas=" 0,   0,   0,   0,   0,   0" ydeltas=" 0,   0,   0,   0,   0,   0"/>

          <para>Partial match on the input:</para>

          <aots:context-test id="chaining1_simple_t9" font="chaining1_simple_f2" inputs="00, 20,  21,  22,  00,  24,  25,  26,  00" outputs="00, 20,  21,  22,  00,  24,  25,  26,  00" xdeltas="0,   0,   0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Not enough glyphs for the input:</para>

          <aots:context-test id="chaining1_simple_t10" font="chaining1_simple_f2" inputs="00, 20,  21,  22,  23" outputs="00, 20,  21,  22,  23" xdeltas="0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0"/>

          <para>Only the first glyph of input matches:</para>

          <aots:context-test id="chaining1_simple_t11" font="chaining1_simple_f2" inputs="00, 20,  21,  22" outputs="00, 20,  21,  22" xdeltas="0,   0,   0,   0" ydeltas="0,   0,   0,   0"/>
        </section>

        <section>
          <title>chaining1_next_glyph</title>

          <para>The next test makes sure that after a match, the next glyph
	  being processed follows the input part of the pattern match, not
	  the lookahead part. To do this, we extend the coverage of
	  the lookup to include glyph 23, and add a ChainSubRule that
	  matches glyph 23 alone.</para>

<aots:context-test-font id="chaining1_next_glyph_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="20" in="21 22" ahead="23">
	  <apply pos="0" lookup="lookup.single"/>
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
	<pattern back="" in="23" ahead="">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining1_next_glyph_t1" font="chaining1_next_glyph_f1" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   62,   63,   00" xdeltas="0,    0,   20,   20,   20,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

        </section>

        <section>
          <title>chaining1_boundary</title>

          <para>Next, we test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id="chaining1_boundary_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="20" in="21 22" ahead="23">
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining1_boundary_t1" font="chaining1_boundary_f1" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   21,   22,   23,   00" xdeltas="0,    0,    0,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Boundary case: InputGlyphCount is 1.</para>

<aots:context-test-font id="chaining1_boundary_f2">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="20" in="21" ahead="22 23">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining1_boundary_t2" font="chaining1_boundary_f2" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   22,   23,   00" xdeltas="0,    0,   20,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Boundary case: BacktrackGlyphCount is 0.</para>

<aots:context-test-font id="chaining1_boundary_f3">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="" in="21" ahead="22 23">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining1_boundary_t3" font="chaining1_boundary_f3" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   22,   23,   00" xdeltas="0,    0,   20,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

	  <para>Boundary case: AheadGlyphCount is 0.</para>

<aots:context-test-font id="chaining1_boundary_f4">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="20 21" in="22" ahead="">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

	  <aots:context-test id="chaining1_boundary_t4" font="chaining1_boundary_f4" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   21,   62,   23,   00" xdeltas="0,    0,    0,   20,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>
        </section>

        <section>
          <title>chaining1_multiple_subrules</title>

          <para>This next two tests ensure that the ChainSubRules of a
	  ChainSubRuleSet are applied in order. In the first test,
	  the first context pattern is 20 : 21 22 : 23 24
	  and the second is 20 : 21 22 : 23.</para>

<aots:context-test-font id="chaining1_multiple_subrules_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="20" in="21 22" ahead="23 24">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
	<pattern back="20" in="21 22" ahead="23">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining1_multiple_subrules_t1" font="chaining1_multiple_subrules_f1" inputs="00,  20,  21,  22,  23,  24,  00,  20,  21,  22,  23,  00" outputs="00,  20,  61,  22,  23,  24,  00,  20,  21,  62,  23,  00" xdeltas=" 0,   0,  20,   0,   0,   0,   0,   0,   0,  20,   0,   0" ydeltas=" 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Next, we invert the order of two ChainSubRules:</para>

<aots:context-test-font id="chaining1_multiple_subrules_f2">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="20" in="21 22" ahead="23">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
	<pattern back="20" in="21 22" ahead="23 24">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining1_multiple_subrules_t2" font="chaining1_multiple_subrules_f2" inputs="00,  20,  21,  22,  23,  24,  00,  20,  21,  22,  23,  00" outputs="00,  20,  21,  62,  23,  24,  00,  20,  21,  62,  23,  00" xdeltas=" 0,   0,   0,  20,   0,   0,   0,   0,   0,  20,   0,   0" ydeltas=" 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0"/>
        </section>

        <section>
          <title>chaining1_successive</title>

          <para>In this test, we verify the case described in the
	  SubstLookupRecord section. The matched sequence is 18 19 20
	  21. Glyphs 19 and 20 are replaced by glyph 23 and glyph 21 is
	  replaced by glyph 24. The difficult part is that the lookup that
	  replaces 21 by 24 is applied at position 2, which is counted after
	  the ligature substitution is applied.</para>

<aots:context-test-font id="chaining1_successive_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="1">
	<pattern back="25" in="20 21 22 23" ahead="24">
	  <apply pos="1" lookup="lookup.double"/>
	  <apply pos="2" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining1_successive_t1" font="chaining1_successive_f1" inputs="00,  25,  20,   21,   22,   23,   24,  00" outputs="00,  25,  20,   61,         63,   24,  00," xdeltas="0,    0,   0,   20,   20,    0,    0,   0," ydeltas="0,    0,   0,    0,    0,    0,    0,   0,"/>
        </section>

        <section>
          <title>chaining1_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
	  sequence is 18 : 19 20 : 21, and at each position the
	  glyphID is increased by 4. Glyph 26 is covered by
	  lookupFlag.</para>

<aots:context-test-font id="chaining1_lookupflag_f1">
  <lookup id="lookup.test" type="chainingContextual" ignoreMarks="yes">
    <chainingContextual format="1">
	<pattern back="20 21" in="22 23 24" ahead="25 26">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining1_lookupflag_t1" font="chaining1_lookupflag_f1" inputs="00, 20, 90, 21, 91, 22, 92, 23, 93, 94, 24, 90, 25, 91, 26, 00" outputs="00, 20, 90, 21, 91, 22, 92, 63, 93, 94, 24, 90, 25, 91, 26, 00" xdeltas=" 0,  0,  0,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0,  0" ydeltas=" 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0"/>
        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Chaining Context Substitution Format 2: Class-based Chaining
        Context Glyph Substitution</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Format 2 describes class-based chaining context
          substitution. For this format, a specific integer, called a
          class value, must be assigned to each glyph component in all
          context glyph sequences. Contexts are then defined as
          sequences of glyph class values. More than one context may
          be defined at a time.</para>

        <para>To chain contexts, three classes are used in the glyph
          ClassDef table: Backtrack ClassDef, Input ClassDef, and
          Lookahead ClassDef.</para>

        <para>The ChainContextSubstFormat2 subtable also contains a
          format identifier (SubstFormat) and defines an offset to a
          Coverage table (Coverage). For this format, the Coverage
          table lists indices for the complete set of unique glyphs
          (not glyph classes) that may appear as the first glyph of
          any class-based context. In other words, the Coverage table
          contains the list of glyph indices for all the glyphs in all
          classes that may be first in any of the context class
          sequences. For example, if the contexts begin with a Class 1
          or Class 2 glyph, then the Coverage table will list the
          indices of all Class 1 and Class 2 glyphs.</para>

        <para>A ChainContextSubstFormat2 subtable also defines an
          array of offsets to the ChainSubClassSet tables
          (ChainSubClassSet) and a count of the ChainSubClassSet
          tables (ChainSubClassSetCnt). The array contains one offset
          for each class (including Class 0) in the ClassDef table. In
          the array, the class value defines an offset's index
          position, and the ChainSubClassSet offsets are ordered by
          ascending class value (from 0 to ChainSubClassSetCnt -
          1).</para>

        <para>If no contexts begin with a particular class (that is,
          if a ChainSubClassSet contains no ChainSubClassRule tables),
          then the offset to that particular ChainSubClassSet in the
          ChainSubClassSet array will be set to NULL.</para>

        <otformat>
          <title>ChainContextSubstFormat2 subtable: Class-based
            chaining context glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage</otfieldname>
            <otfielddesc>Offset to Coverage table – from beginning of
              Substitution table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>BacktrackClassDef</otfieldname>
            <otfielddesc>Offset to glyph ClassDef table containing
              backtrack sequence data – from beginning of Substitution
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>InputClassDef</otfieldname>
            <otfielddesc>Offset to glyph ClassDef table containing
              input sequence data – from beginning of Substitution
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LookaheadClassDef</otfieldname>
            <otfielddesc>Offset to glyph ClassDef table containing
              lookahead sequence data – from beginning of Substitution
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>10</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainSubClassSetCnt</otfieldname>
            <otfielddesc>Number of ChainSubClassSet
              tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainSubClassSet [ChainSubClassSetCnt]</otfieldname>
            <otfielddesc>Array of offsets to ChainSubClassSet tables
              – from beginning of Substitution table –
              ordered by input class – may be
              NULL</otfielddesc>
          </otfield>
        </otformat>

        <para>Each context is defined in a ChainSubClassRule table,
          and all ChainSubClassRules that specify contexts beginning
          with the same class value are grouped in a ChainSubClassSet
          table. Consequently, the ChainSubClassSet containing a
          context identifies a context's first class component.</para>

        <para>Each ChainSubClassSet table consists of a count of the
          ChainSubClassRule tables defined in the ChainSubClassSet
          (ChainSubClassRuleCnt) and an array of offsets to
          ChainSubClassRule tables (ChainSubClassRule). The
          ChainSubClassRule tables are ordered by preference in the
          ChainSubClassRule array of the ChainSubClassSet.</para>

        <otformat>
          <title>ChainSubClassSet subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ChainSubClassRuleCnt</otfieldname>
            <otfielddesc>Number of ChainSubClassRule
              tables</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>ChainSubClassRule [ChainSubClassRuleCount]</otfieldname>
            <otfielddesc>Array of offsets to ChainSubClassRule tables
              – from beginning of ChainSubClassSet –
              ordered by preference</otfielddesc>
          </otfield>
        </otformat>

        <para>For each context, a ChainSubClassRule table contains a
          count of the glyph classes in the context sequence
          (GlyphCount), including the first class. A Class array lists
          the classes, beginning with the second class (array index =
          1), that follow the first class in the context.</para>

        <blockquote>
          <para>Note: Text order depends on the writing direction of
            the text. For text written from right to left, the
            right-most class will be first. Conversely, for text
            written from left to right, the left-most class will be
            first.</para>
        </blockquote>

        <para>The values specified in the Class array are the values
          defined in the ClassDef table. The first class in the
          sequence, Class 2, is identified in the
          ChainContextSubstFormat2 table by the ChainSubClassSet array
          index of the corresponding ChainSubClassSet.</para>

        <para>A ChainSubClassRule also contains a count of the
          substitutions to be performed on the context (SubstCount)
          and an array of SubstLookupRecords (SubstLookupRecord) that
          supply the substitution data. For each position in the
          context that requires a substitution, a SubstLookupRecord
          specifies a LookupList index and a position in the input
          glyph sequence where the lookup is applied. The
          SubstLookupRecord array lists SubstLookupRecords in design
          order – that is, the order in which lookups should be applied
          to the entire glyph sequence.</para>

        <otformat>
          <title>ChainSubClassRule table: Chaining context definition
            for one class</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BacktrackGlyphCount</otfieldname>
            <otfielddesc>Total number of glyphs in the backtrack
              sequence (number of glyphs to be matched before the
              first glyph)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Backtrack [BacktrackGlyphCount]</otfieldname>
            <otfielddesc>Array of backtracking classes(to be matched
              before the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2+n</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>InputGlyphCount</otfieldname>
            <otfielddesc>Total number of classes in the input sequence
              (includes the first class)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Input [InputGlyphCount-1]</otfieldname>
            <otfielddesc>Array of input classes(start with second
              class; to be matched with the input glyph
              sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+m</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookaheadGlyphCount</otfieldname>
            <otfielddesc>Total number of classes in the look ahead
              sequence (number of classes to be matched after the
              input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n+m</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookAhead [LookAheadGlyphCount]</otfieldname>
            <otfielddesc>Array of lookahead classes(to be matched
              after the input sequence)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6+n+m+p</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>8+n+m+p</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords (in design
              order)</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>The first two paragraphs are somewhat contradictory. The
          recommendation is to replace them by &quot;Format 2 describes
          class-based chaining context substitution. Three class
          definitions are used: one for backtrack sequences
          (BacktrackClassDef), one for input sequences
          (InputClassDef), and one for lookahead sequences
          (LookaheadClassDef). Contexts are then defined as sequences
          of glyph class values, interpreted with respect to the
          corresponding class definitions. More than one context may
          be defined at a time.&quot;</para>

        <para>In the description of the Coverage in the third
          paragraph, the sentences starting with &quot;In other words,&quot; are
          a bit misleading: the coverage may contain more or less than
          the union of the classes that have non-NULL ChainSubClassSet
          offsets. This can be useful when the class definition is
          shared by multiple lookups. The recommendation is to replace
          the third paragraph by: &quot;The ChainContextSubstFormat2
          subtable also contains a format identifier (SubstFormat) and
          defines an offset to a Coverage table (Coverage). The lookup
          will apply only if the current glyph is covered by Coverage.
          Typically, the coverage is the union of the classes that
          appear as the first class of the input sequence of any
          context; for example, if the input sequences of the contexts
          begin with classes 1 and 2, then the Coverage will be
          exactly the glyphs in classes 1 and 2. However, this is not
          mandatory; in particular, it may be useful to have a
          Coverage which is a subset of those glyphs.&quot;</para>

        <para>To adopt a more consistent language, in the fourth
          paragraph, the sentences following the first should be
          replaced by: &quot;The class of the first input glyph under
          InputClassDef is used to index the ChainSubClassSet array and
          ChainSubClassSetCnt must equal the number of classes defined by
          InputClassDef (including class 0).&quot;</para>

        <para>It is unclear whether the ChainSubClassRuleCnt of a
          ChainSubClassSet table can be 0. We assume that
          ChainSubRuleCount must be at least 1 and recommend that it
          be spelled out in the specification.</para>

        <para>It is unclear whether the InputGlyphCount of a ChainSubClassRule
          can be 0 or 1. The value 0 is most certainly illegal (since
          a SubClassRule table is used in the context of a first glyph
          match). We assume that the value 1 is legal (because it
          makes sense for a similar LookupType 6 subtable), eventhough
          it is difficult to exhibit an interesting use of that
          case.</para>

        <para>It is unclear whether the BacktrackGlyphCount and
          Lookaheadglyphcount can be 0. We assume they can be, and
          recommend it be spelled out in the specification.</para>

        <para>It is unclear whether the SubstCount of a ChainSubClassRule
          can be 0. At first it seems that such a ChainSubClassRule could
          be removed, since it does nothing. On the other hand, this
          could be useful to prevent the activation of following
          ChainSubClassRules; e.g. if one wanted the sequence &lt;1 2 3&gt;
          modified, but not the sequence &lt;1 2 3 4&gt;. The
          recommendation is to explicitly mention that case as
          permitted.</para>

	<para>The pattern matched by the ChainSubClassRule table t = ChainSubClassSet [m].ChainSubRule [n] is

	  B<subscript>b-1</subscript> L* ... L* B<subscript>0</subscript>
          ▶ I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> ◀
          L* A<subscript>0</subscript> L*
	  ... L* A<subscript>a-1</subscript>, where:

	  <itemizedlist>
	    <listitem>
	      <para>b is t.BacktrackGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>i is t.InputGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>a is t.LookaheadGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>B<subscript>k</subscript> is BacktrackClassDef
	      [t.Backtrack [k]] ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>0</subscript> is (Coverage ∩
	      InputClassDef [m]) ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is InputClassDef
	      [t.Input [k-1]] ∖ LookupFlag, for k &gt; 0</para>
	    </listitem>
	    <listitem>
	      <para>A<subscript>k</subscript> is LookAheadClassDef
	      [t.LookAhead [k]] ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>A SubRule table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current
	  position.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Chaining contextual substitution format 2</code-title>
  chainingContextualTable |=
    attribute format { &quot;2&quot; },
    element coverage { coverageTableOffset }?,
    element backClassDef { classDefTableOffset },
    element inClassDef { classDefTableOffset },
    element aheadClassDef { classDefTableOffset },
    element pattern {
      attribute back { text },
      attribute in { text },
      attribute ahead { text },
      subLookups
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  private Block chainingLookupFormat2FromXML (Element subtable, Element table,
                                              Map&lt;Element, Block&gt; blockCache,
					      Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    CoverageTableBlock coverage = null;

    Element firstChild = (Element) subtable.getFirstChild ();
    if (   (firstChild != null)
        &amp;&amp; (firstChild.getTagName ().startsWith (&quot;coverage&quot;))) {
      coverage = coverageFromXML (firstChild, table, blockCache);
      subtable.removeChild (firstChild); }

    ClassdefTableBlock backtrackClassdef
        = classdefFromXML ((Element) subtable.getFirstChild (),
                           table, blockCache);
    subtable.removeChild (subtable.getFirstChild ());

    ClassdefTableBlock inputClassdef
        = classdefFromXML ((Element) subtable.getFirstChild (),
                           table, blockCache);
    subtable.removeChild (subtable.getFirstChild ());

    ClassdefTableBlock lookaheadClassdef
        = classdefFromXML ((Element) subtable.getFirstChild (),
                           table, blockCache);
    subtable.removeChild (subtable.getFirstChild ());

    NodeList classPatterns = subtable.getChildNodes ();

    if (coverage == null) {
      System.err.println (&quot;implicit coverage in chainingContextSubstFormat2 not yet supported&quot;); }


    me = new Block (12 + 2*inputClassdef.classCount,
                    4 + inputClassdef.classCount);
    me.setuint16 (0, 2);
    me.setOffset (2, coverage);
    me.setOffset (4, backtrackClassdef);
    me.setOffset (6, inputClassdef);
    me.setOffset (8, lookaheadClassdef);
    me.setuint16 (10, inputClassdef.classCount);

    for (int c = 0; c &lt; inputClassdef.classCount; c++) {

      // count how may classPatterns start with class c
      int count = 0;
      for (int j = 0; j &lt; classPatterns.getLength (); j++) {
        Element classPattern = (Element) classPatterns.item (j);
        int[] classes = parseIntList (classPattern.getAttribute (&quot;in&quot;));
        if (classes [0] == c) {
          count++; }}

      if (count == 0) {
        me.setOffset (12 + 2*c, null); }

      else {
        Block subClassSet = new Block (2 + 2*count, count);
        me.setOffset (12 + 2*c, subClassSet);
        subClassSet.setuint16 (0, count);

        count = 0;
        for (int j = 0; j &lt; classPatterns.getLength (); j++) {
          Element classPattern = (Element) classPatterns.item (j);
          int[] inClasses = parseIntList (classPattern.getAttribute (&quot;in&quot;));
          if (inClasses [0] == c) {
            int[] backtrackClasses
                     = parseIntList (classPattern.getAttribute (&quot;back&quot;));
            int[] lookaheadClasses
                     = parseIntList (classPattern.getAttribute (&quot;ahead&quot;));
            NodeList applies = classPattern.getChildNodes ();
            int applyCount = applies.getLength ();

            Block subClassRule = new Block (  2 + 2 * backtrackClasses.length
                                            + 2 + 2 * (inClasses.length - 1)
                                            + 2 + 2 * lookaheadClasses.length
                                            + 2 + 4 * applyCount,
                                            0);

            subClassSet.setOffset (2 + 2*(count++), subClassRule);

            int offset = 0;
            subClassRule.setuint16 (offset, backtrackClasses.length);
            offset += 2;
            for (int k = backtrackClasses.length - 1; k &gt;= 0; k--) {
              subClassRule.setuint16 (offset, backtrackClasses [k]);
              offset += 2; }
            subClassRule.setuint16 (offset, inClasses.length);
            offset += 2;
            for (int k = 1; k &lt; inClasses.length; k++) {
              subClassRule.setuint16 (offset, inClasses [k]);
              offset += 2; }
            subClassRule.setuint16 (offset, lookaheadClasses.length);
            offset += 2;
            for (int k = 0; k &lt; lookaheadClasses.length; k++) {
              subClassRule.setuint16 (offset, lookaheadClasses [k]);
              offset += 2; }

            subClassRule.setuint16 (offset, applyCount);
            offset += 2;

	    offset += subLookupsFromXML (applyCount, applies, subClassRule, offset,
					lookupIndices); }}}}
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="chainingLookup.toXMLCount_2">
  coverageTableToXMLCount (stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 4), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 6), counts);
  classDefTableToXMLCount (stOffset + getOffset (stOffset + 8), counts);
</code-fragment>

<code-fragment id="chainingLookup.toXML_2">
  coverageTableToXML (conf, stOffset + getOffset (stOffset + 2), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 4), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 6), counts);
  classDefTableToXML (conf, stOffset + getOffset (stOffset + 8), counts);
</code-fragment>

<code-fragment id="chainingLookup.toXMLEmit_2">
    int setCount = getuint16 (stOffset + 10);

    at = new AttributesImpl ();
    coverageTableOffsetToXML (conf, stOffset + getOffset (stOffset + 2), counts,
                              &quot;coverage&quot;, at);
    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, stOffset + getOffset (stOffset + 4), counts,
                              &quot;backClassDef&quot;, at);
    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, stOffset + getOffset (stOffset + 6), counts,
                              &quot;inClassDef&quot;, at);
    at = new AttributesImpl ();
    classDefTableOffsetToXML (conf, stOffset + getOffset (stOffset + 8), counts,
                              &quot;aheadClassDef&quot;, at);


    for (int set = 0; set &lt; setCount; set++) {
      int x = getOffset (stOffset + 12 + 2*set);
      if (x != 0) {
        int setOffset = stOffset + x;
        int ruleCount = getuint16 (setOffset);

        for (int rule = 0; rule &lt; ruleCount; rule++) {
          int o = setOffset + getOffset (setOffset + 2 + 2*rule);
          at = new AttributesImpl ();

          { int backGlyphCount = getuint16 (o);
            o += 2;
            o += (backGlyphCount - 1) * 2;
            StringBuilder s = new StringBuilder ();
            for (int g = 0; g &lt; backGlyphCount; g++) {
              s.append (&quot; &quot; + getuint16 (o));
              o -= 2; }
            o += (backGlyphCount + 1) * 2;
            at.addAttribute (&quot;&quot;, &quot;back&quot;, &quot;back&quot;, &quot;CDATA&quot;,
                             s.toString ()); }

          { int inGlyphCount = getuint16 (o);
            o += 2;
            StringBuilder s = new StringBuilder ();
            s.append (&quot;&quot; + set);
            for (int g = 0; g &lt; inGlyphCount - 1; g++) {
              s.append (&quot; &quot; + getuint16 (o));
              o += 2; }
            at.addAttribute (&quot;&quot;, &quot;in&quot;, &quot;in&quot;, &quot;CDATA&quot;,
                             s.toString ()); }

          { int aheadGlyphCount = getuint16 (o);
            o += 2;
            StringBuilder s = new StringBuilder ();
            for (int g = 0; g &lt; aheadGlyphCount; g++) {
              s.append (&quot; &quot; + getuint16 (o));
              o += 2; }
            at.addAttribute (&quot;&quot;, &quot;ahead&quot;, &quot;ahead&quot;, &quot;CDATA&quot;,
                             s.toString ()); }

          conf.ch.startElement (&quot;pattern&quot;, at); {
            int posCount = getuint16 (o);
            o += 2;
            subLookupsToXML (conf, posCount, o);
            conf.ch.endElement (&quot;pattern&quot;); }}}}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>We start with a procedure that performs the matching of
          a single sub rule. When this procedure is called, it is
          known that the glyph run matched
          I<subscript>0</subscript> and that I<subscript>0</subscript>
          is at <varname>inPos</varname>. If the rest of the pattern
          (i.e. the glyphs in the subrule) is not matched, then this
          procedure returns <varname>null</varname>. Otherwise, it
          returns an array of the glyph run positions for the input
          glyphs, i.e. the positions of I<subscript>0</subscript>,
          I<subscript>1</subscript>, …</para>

        <para>Note that the organization of this procedure matches the
          organization of the subtable: I<subscript>0</subscript> is
          recorded in the Coverage of the subtable, and
          I<subscript>1</subscript>, … are recorded in a
          ChainSubClassRule table; essentially this procedure takes
          care of one ChainSubClassRule table.</para>

<code-fragment id="lookuptable.methods">
  <code-title>Method to match one GSUB 6/2 ChainSubClassRule</code-title>
  int[] matchOneChainClassRule (GlyphRun gr, int inPos,
                                int ruleOffset,
                                int backtrackClassDefOffset,
                                int inputClassDefOffset,
                                int lookaheadClassDefOffset,
                                 int lookupIndex, int lookupFlag)
      throws InvalidFontException {

    int backtrackGlyphCount = getuint16 (ruleOffset);
    int inputGlyphCount = getuint16 (ruleOffset + 2
                                     + 2*backtrackGlyphCount);
    int lookaheadGlyphCount = getuint16 (ruleOffset + 4
                                         + 2*backtrackGlyphCount
                                         + 2*(inputGlyphCount - 1));

    int backPos = inPos - 1;
    for (int b = 0; b &lt; backtrackGlyphCount; b++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (backPos))) {
        backPos--; }

      if (   classIndex (gr.glyphAt (backPos), backtrackClassDefOffset)
          != getuint16 (ruleOffset + 2 + 2*b)) {
        return null; }

      backPos--; }

    int [] matchedPositions = new int [inputGlyphCount];
    matchedPositions [0] = inPos;
    inPos++;

    for (int i = 1; i &lt; inputGlyphCount; i++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (   classIndex (gr.glyphAt (inPos), inputClassDefOffset)
          != getuint16 (ruleOffset + 4
                        + 2*backtrackGlyphCount + 2*(i-1))) {
        return null; }

      matchedPositions [i] = inPos;
      inPos++; }

    for (int l = 0; l &lt; lookaheadGlyphCount; l++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (   classIndex (gr.glyphAt (inPos), lookaheadClassDefOffset)
          != getGlyphID (ruleOffset + 6
                         + 2*backtrackGlyphCount
                         + 2*(inputGlyphCount-1) + 2*l)) {
        return null; }

      inPos++; }

    return matchedPositions;
  }
</code-fragment>

        <para>With that in place, we can now implement the full
          subtable.</para>

<code-fragment id="chainingLookup_format2">
  <code-title>Execute format 2 subtable and return</code-title>
  { int coverageOffset = stOffset + getOffset (stOffset + 2);
    int inPos = curGlyph;

    if (-1 == getCoverageIndex (gr.glyphAt (inPos), coverageOffset)) {
      return lookupNotApplied; }

    int backtrackClassDefOffset = stOffset + getOffset (stOffset + 4);
    int inputClassDefOffset = stOffset + getOffset (stOffset + 6);
    int lookaheadClassDefOffset = stOffset + getOffset (stOffset + 8);

    int cl = classIndex (gr.glyphAt (inPos), inputClassDefOffset);
    if (cl &gt; getuint16 (stOffset + 10) - 1) {
      return lookupNotApplied; }
    int ruleSetOffset = getOffset (stOffset + 12 + 2*cl);
    if (ruleSetOffset == 0) {
      return lookupNotApplied; }
    ruleSetOffset += stOffset;
    int ruleCount = getuint16 (ruleSetOffset);

    for (int s = 0; s &lt; ruleCount; s++) {
      int ruleOffset
        = ruleSetOffset + getOffset (ruleSetOffset + 2 + 2*s);

      int [] matchedPositions
        = matchOneChainClassRule (gr, inPos, ruleOffset,
                                     backtrackClassDefOffset,
                                     inputClassDefOffset,
                                     lookaheadClassDefOffset,
                                     lookupIndex, lookupFlag);

      if (   matchedPositions != null
          &amp;&amp; gr.isLookupApplied (lookupIndex, curGlyph,
                                 matchedPositions[matchedPositions.length-1])) {
        int backtrackGlyphCount = getuint16 (ruleOffset);
        int inputGlyphCount = getuint16 (ruleOffset + 2
                                         + 2*backtrackGlyphCount);
        int lookaheadGlyphCount = getuint16 (ruleOffset + 4
                                             + 2*backtrackGlyphCount
                                             + 2*(inputGlyphCount -1));
        int applyCountOffset = ruleOffset + 6
                                    + 2*backtrackGlyphCount
                                    + 2*(inputGlyphCount - 1)
                                    + 2*lookaheadGlyphCount;
        int applyCount = getuint16 (applyCountOffset);
        int applyOffset = applyCountOffset + 2;
        if (listener != null) {
          listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                     Tag.tag2string (tag), stOffset); }
        return applySubLookups (gr, matchedPositions, applyCount, applyOffset); }}

    return lookupNotApplied; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Test Suite</title>

        <section>
          <title>chaining2_simple</title>

          <para>A simple test to start.</para>

<code-fragment id="chaining2.classes">
        <coverage format="any" glyphs="20:26"/>
	<backClassDef format="any">
	  <class classID="20" glyphs="20"/>
	  <class classID="21" glyphs="21"/>
	  <class classID="22" glyphs="22"/>
	  <class classID="23" glyphs="23"/>
	  <class classID="24" glyphs="24"/>
	  <class classID="25" glyphs="25"/>
	  <class classID="26" glyphs="26"/>
	</backClassDef>
	<inClassDef format="any">
	  <class classID="20" glyphs="20"/>
	  <class classID="21" glyphs="21"/>
	  <class classID="22" glyphs="22"/>
	  <class classID="23" glyphs="23"/>
	  <class classID="24" glyphs="24"/>
	  <class classID="25" glyphs="25"/>
	  <class classID="26" glyphs="26"/>
	</inClassDef>
	<aheadClassDef format="any">
	  <class classID="20" glyphs="20"/>
	  <class classID="21" glyphs="21"/>
	  <class classID="22" glyphs="22"/>
	  <class classID="23" glyphs="23"/>
	  <class classID="24" glyphs="24"/>
	  <class classID="25" glyphs="25"/>
	  <class classID="26" glyphs="26"/>
	</aheadClassDef>
</code-fragment>


<aots:context-test-font id="chaining2_simple_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="2">
      <code-include linkend="chaining2.classes"/>
      <pattern back="20" in="21 22" ahead="23">
	<apply pos="0" lookup="lookup.single"/>
	<apply pos="1" lookup="lookup.single"/>
      </pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_simple_t1" font="chaining2_simple_f1" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   62,   23,   00" xdeltas="0,    0,   20,   20,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Our next set of tests verifies partial matches. It
            uses slightly more complicated pattern: 20 21 : 22 23 24 :
            25 26, with a standard sublookup applied on 22.</para>

<aots:context-test-font id="chaining2_simple_f2">
  <lookup id="lookup.test" type="chainingContextual">
	<chainingContextual format="2">
	  <code-include linkend="chaining2.classes"/>
	  <pattern back="20 21" in="22 23 24" ahead="25 26">
	    <apply pos="0" lookup="lookup.single"/>
	  </pattern>
	</chainingContextual>
  </lookup>
</aots:context-test-font>

          <para>First, let’s verify that the substitution works:</para>

          <aots:context-test id="chaining2_simple_t2" font="chaining2_simple_f2" inputs="00, 20,  21,  22,  23,  24,  25,  26,  00" outputs="00, 20,  21,  62,  23,  24,  25,  26,  00" xdeltas="0,   0,   0,  20,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Partial match on the lookahead:</para>

          <aots:context-test id="chaining2_simple_t3" font="chaining2_simple_f2" inputs="00, 20,  21,  22,  23,  24,  25,  00,  00" outputs="00, 20,  21,  22,  23,  24,  25,  00,  00" xdeltas="0,   0,   0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Not enough for the lookahead:</para>

          <aots:context-test id="chaining2_simple_t4" font="chaining2_simple_f2" inputs="00, 20,  21,  22,  23,  24,  25" outputs="00, 20,  21,  22,  23,  24,  25" xdeltas="0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0"/>


          <para>No glyphs at all for lookahead:</para>

          <aots:context-test id="chaining2_simple_t5" font="chaining2_simple_f2" inputs="00, 20,  21,  22,  23,  24" outputs="00, 20,  21,  22,  23,  24" xdeltas="0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0"/>

          <para>Partial match on backtrack:</para>

          <aots:context-test id="chaining2_simple_t6" font="chaining2_simple_f2" inputs="00, 00,  21,  22,  23,  24,  25,  26,  00" outputs="00, 00,  21,  22,  23,  24,  25,  26,  00" xdeltas="0,   0,   0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Not enough for the backtrack:</para>

          <aots:context-test id="chaining2_simple_t7" font="chaining2_simple_f2" inputs=" 21,  22,  23,  24,  25,  26,  00" outputs=" 21,  22,  23,  24,  25,  26,  00" xdeltas="  0,   0,   0,   0,   0,   0,   0" ydeltas="  0,   0,   0,   0,   0,   0,   0"/>

          <para>No glyphs for backtrack at all:</para>

          <aots:context-test id="chaining2_simple_t8" font="chaining2_simple_f2" inputs="22,  23,  24,  25,  26,  00" outputs="22,  23,  24,  25,  26,  00" xdeltas=" 0,   0,   0,   0,   0,   0" ydeltas=" 0,   0,   0,   0,   0,   0"/>

          <para>Partial match on the input:</para>

          <aots:context-test id="chaining2_simple_t9" font="chaining2_simple_f2" inputs="00, 20,  21,  22,  00,  24,  25,  26,  00" outputs="00, 20,  21,  22,  00,  24,  25,  26,  00" xdeltas="0,   0,   0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Not enough glyphs for the input:</para>

          <aots:context-test id="chaining2_simple_t10" font="chaining2_simple_f2" inputs="00, 20,  21,  22,  23" outputs="00, 20,  21,  22,  23" xdeltas="0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0"/>

          <para>Only the first glyph of input matches:</para>

          <aots:context-test id="chaining2_simple_t11" font="chaining2_simple_f2" inputs="00, 20,  21,  22" outputs="00, 20,  21,  22" xdeltas="0,   0,   0,   0," ydeltas="0,   0,   0,   0,"/>
        </section>

        <section>
          <title>chaining2_next_glyph</title>

          <para>The next test makes sure that after a match, the next
          glyph being processed follows the input part of the pattern
          match, not the lookahead part. To do this, we extend the
          coverage of the lookup to include glyph 23, and add a
          ChainSubRule that matches glyph 23 alone.</para>

<aots:context-test-font id="chaining2_next_glyph_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="2">
	<code-include linkend="chaining2.classes"/>
	<pattern back="20" in="21 22" ahead="23">
	  <apply pos="0" lookup="lookup.single"/>
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
	<pattern back="" in="23" ahead="">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_next_glyph_t1" font="chaining2_next_glyph_f1" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   62,   63,   00" xdeltas="0,    0,   20,   20,   20,    0" ydeltas="0,    0,    0,    0,    0,    0"/>
        </section>

        <section>
          <title>chaining2_boundary</title>

          <para>Next, we test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id="chaining2_boundary_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="2">
	<code-include linkend="chaining2.classes"/>
	<pattern back="20" in="21 22" ahead="23">
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_boundary_t1" font="chaining2_boundary_f1" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   21,   22,   23,   00" xdeltas="0,    0,    0,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Boundary case: InputGlyphCount is 1.</para>

<aots:context-test-font id="chaining2_boundary_f2">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="2">
	<code-include linkend="chaining2.classes"/>
	<pattern back="20" in="21" ahead="22 23">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_boundary_t2" font="chaining2_boundary_f2" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   22,   23,   00" xdeltas="0,    0,   20,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Boundary case: BacktrackGlyphCount is 0.</para>

<aots:context-test-font id="chaining2_boundary_f3">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="2">
	<code-include linkend="chaining2.classes"/>
	<pattern back="" in="21" ahead="22 23">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_boundary_t3" font="chaining2_boundary_f3" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   22,   23,   00" xdeltas="0,    0,   20,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Boundary case: AheadGlyphCount is 0.</para>

<aots:context-test-font id="chaining2_boundary_f4">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="2">
	<code-include linkend="chaining2.classes"/>
	<pattern back="20 21" in="22" ahead="">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_boundary_t4" font="chaining2_boundary_f4" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   21,   62,   23,   00" xdeltas="0,    0,    0,   20,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>
        </section>

        <section>
          <title>chaining2_multiple_subrules</title>

          <para>This next two tests ensure that the ChainSubRules of a
            ChainSubRuleSet are applied in order. In the first test,
            the first context pattern is 20 : 21 22 : 23 24
	    and the second is 20 : 21 22 : 23.</para>

<aots:context-test-font id="chaining2_multiple_subrules_f1">
  <lookup id="lookup.test" type="chainingContextual">
	<chainingContextual format="2">
	  <code-include linkend="chaining2.classes"/>
	  <pattern back="20" in="21 22" ahead="23 24">
	    <apply pos="0" lookup="lookup.single"/>
	  </pattern>
	  <pattern back="20" in="21 22" ahead="23">
	    <apply pos="1" lookup="lookup.single"/>
	  </pattern>
	</chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_multiple_subrules_t1" font="chaining2_multiple_subrules_f1" inputs="00,  20,  21,  22,  23,  24,  00,  20,  21,  22,  23,  00" outputs="00,  20,  61,  22,  23,  24,  00,  20,  21,  62,  23,  00" xdeltas=" 0,   0,  20,   0,   0,   0,   0,   0,   0,  20,   0,   0" ydeltas=" 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Next, we invert the order of two ChainSubRules:</para>

<aots:context-test-font id="chaining2_multiple_subrules_f2">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="2">
	<code-include linkend="chaining2.classes"/>
	<pattern back="20" in="21 22" ahead="23">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
	<pattern back="20" in="21 22" ahead="23 24">
	  <apply pos="0" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_multiple_subrules_t2" font="chaining2_multiple_subrules_f2" inputs="00,  20,  21,  22,  23,  24,  00,  20,  21,  22,  23,  00" outputs="00,  20,  21,  62,  23,  24,  00,  20,  21,  62,  23,  00" xdeltas=" 0,   0,   0,  20,   0,   0,   0,   0,   0,  20,   0,   0" ydeltas=" 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0"/>
        </section>

        <section>
          <title>chaining2_successive</title>

          <para>In this test, we verify the case described in the
            SubstLookupRecord section. The matched sequence is 18 19 20
            21. Glyphs 19 and 20 are replaced by glyph 23 and glyph 21 is
            replaced by glyph 24. The difficult part is that the lookup that
            replaces 21 by 24 is applied at position 2, which is counted after
            the ligature substitution is applied.</para>

<aots:context-test-font id="chaining2_successive_f1">
  <lookup id="lookup.test" type="chainingContextual">
	<chainingContextual format="2">
	  <code-include linkend="chaining2.classes"/>
	  <pattern back="25" in="20 21 22 23" ahead="24">
	    <apply pos="1" lookup="lookup.double"/>
	    <apply pos="2" lookup="lookup.single"/>
	  </pattern>
	</chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_successive_t1" font="chaining2_successive_f1" inputs="00,  25,  20,   21,   22,   23,   24,  00" outputs="00,  25,  20,   61,         63,   24,  00" xdeltas="0,    0,   0,   20,   20,    0,    0,   0" ydeltas="0,    0,   0,    0,    0,    0,    0,   0"/>
        </section>

        <section>
          <title>chaining2_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
	  sequence is 18 : 19 20 : 21, and at each position the
	  glyphID is increased by 4. Glyph 26 is covered by
	  lookupFlag.</para>

<aots:context-test-font id="chaining2_lookupflag_f1">
  <lookup id="lookup.test" type="chainingContextual" ignoreMarks="yes">
    <chainingContextual format="2">
	<code-include linkend="chaining2.classes"/>
	<pattern back="20 21" in="22 23 24" ahead="25 26">
	  <apply pos="1" lookup="lookup.single"/>
	</pattern>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining2_lookupflag_t1" font="chaining2_lookupflag_f1" inputs="00, 20, 90, 21, 91, 22, 92, 23, 93, 94, 24, 90, 25, 91, 26, 00" outputs="00, 20, 90, 21, 91, 22, 92, 63, 93, 94, 24, 90, 25, 91, 26, 00" xdeltas=" 0,  0,  0,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0,  0" ydeltas=" 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0"/>
        </section>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Chaining Context Substitution Format 3: Coverage-based Chaining
        Context Glyph Substitution</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Format 3 defines a chaining context rule as a sequence
          of Coverage tables. Each position in the sequence may define
          a different Coverage table for the set of glyphs that
          matches the context pattern. With Format 3, the glyph sets
          defined in the different Coverage tables may intersect,
          unlike Format 2 which specifies fixed class assignments
          (identical for each position in the backtrack, input, or
          lookahead sequence) and exclusive classes (a glyph cannot be
          in more than one class at a time).</para>

        <blockquote>
          <para>Note: The order of the Coverage tables listed in the
            Coverage array must follow the writing direction. For text
            written from right to left, then the right-most glyph will
            be first. Conversely, for text written from left to right,
            the left-most glyph will be first.</para>
        </blockquote>

        <para>The subtable also contains a count of the
          substitutions to be performed on the input Coverage sequence
          (SubstCount) and an array of SubstLookupRecords
          (SubstLookupRecord) in design order: that is, the order in
          which lookups should be applied to the entire glyph
          sequence. (SubstLookupRecords are described next.)</para>

        <otformat>
            <title>ChainContextSubstFormat3 subtable: Coverage-based
            chaining context glyph substitution</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier – format = 3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>BacktrackGlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in the backtracking
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [BacktrackGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to coverage tables in
              backtracking sequence, in glyph sequence
              order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>InputGlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in input
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [InputGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to coverage tables in input
              sequence, in glyph sequence order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookaheadGlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in lookahead
              sequence</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m+2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Coverage [LookaheadGlyphCount]</otfieldname>
            <otfielddesc>Array of offsets to coverage tables in
              lookahead sequence, in glyph sequence
              order</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m+2+p</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubstCount</otfieldname>
            <otfielddesc>Number of SubstLookupRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4+n+2+m+2+p+2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>SubstLookupRecord [SubstCount]</otfieldname>
            <otfielddesc>Array of SubstLookupRecords, in design
              order</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>It is probably worth noting that InputGlyphCount should
          be non-zero, and that BacktrackGlyphCount and
          LookaheadGlyphCount can be zero.</para>

        <para>It is unclear whether the SubstCount can be 0. At first
          it seems that such a subtable is not interesting, since it
          does nothing. On the other hand, this could be useful to
          prevent the activation of following subtables. The
          recommendation is to explicitly mention that case as
          permitted.</para>

	<para>The three fields that hold arrays of offsets to
	  coverages have the same name. We assume that their names are
	  Backtrack, Input and Lookahead.</para>

	<para>The pattern matched by this subtable is
          B<subscript>b-1</subscript> L* ... L*
          B<subscript>0</subscript> L* ▶
	  I<subscript>0</subscript> L*
	  I<subscript>1</subscript> L* ... L*
	  I<subscript>i-1</subscript> ◀
          L* A<subscript>0</subscript> L* ... L*
          A<subscript>a-1</subscript>, where:

	  <itemizedlist>
	    <listitem>
	      <para>b is BacktrackGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>i is InputGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>a is LookaheadGlyphCount</para>
	    </listitem>
	    <listitem>
	      <para>B<subscript>k</subscript> is Backtrack
	      [k] ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>I<subscript>k</subscript> is
		Input [k] ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>A<subscript>k</subscript> is Lookahead
	      [k] ∖ LookupFlag</para>
	    </listitem>
	    <listitem>
	      <para>L is LookupFlag</para>
	    </listitem>
	  </itemizedlist></para>

	<para>This table does not directly modify the glyph
	  run. Instead, it invokes other lookups at the current position.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Chaning contextual substitution format 3 type</code-title>
  chainingContextualTable |=
    attribute format { &quot;3&quot; },
    element backCoverages {
      element coverage { coverageTableOffset }*
    },
    element inCoverages {
      element coverage { coverageTableOffset }*
    },
    element aheadCoverages {
      element coverage { coverageTableOffset }*
    },
    subLookups
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  private Block chainingLookupFormat3FromXML (Element subtable, Element table,
                                              Map&lt;Element, Block&gt; blockCache,
					      Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    NodeList backtrack = subtable.getFirstChild ().getChildNodes ();
    int backtrackCount = backtrack.getLength ();
    subtable.removeChild (subtable.getFirstChild ());

    NodeList input = subtable.getFirstChild ().getChildNodes ();
    int inputCount = input.getLength ();
    subtable.removeChild (subtable.getFirstChild ());

    NodeList lookahead = subtable.getFirstChild ().getChildNodes ();
    int lookaheadCount = lookahead.getLength ();
    subtable.removeChild (subtable.getFirstChild ());

    NodeList applies = subtable.getChildNodes ();
    int substCount = applies.getLength ();

    me = new Block (10 + 2*backtrackCount + 2*inputCount + 2*lookaheadCount
                       + 4*substCount,
                    backtrackCount + inputCount + lookaheadCount);
    me.setuint16 (0, 3);

    int offset = 2;
    me.setuint16 (offset, backtrackCount);
    offset += 2;
    for (int i = backtrackCount - 1; i &gt;= 0; i--) {
      Element coverage = (Element) backtrack.item (i);
      me.setOffset (offset, coverageFromXML (coverage, table, blockCache));
      offset += 2; }

    me.setuint16 (offset, inputCount);
    offset += 2;
    for (int i = 0; i &lt; inputCount; i++) {
      Element coverage = (Element) input.item (i);
      me.setOffset (offset, coverageFromXML (coverage, table, blockCache));
      offset += 2; }

    me.setuint16 (offset, lookaheadCount);
    offset += 2;
    for (int i = 0; i &lt; lookaheadCount; i++) {
      Element coverage = (Element) lookahead.item (i);
      me.setOffset (offset, coverageFromXML (coverage, table, blockCache));
      offset += 2; }

    me.setuint16 (offset, substCount);
    offset += 2;
    subLookupsFromXML (substCount, applies, me, offset, lookupIndices);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="chainingLookup.toXMLCount_3">
  int o = stOffset + 2;

  int backCount = getuint16 (o);
  o += 2;
  for (int c = 0; c &lt; backCount; c++) {
    coverageTableToXMLCount (stOffset + getOffset (o), counts);
    o += 2; }

  int inCount = getuint16 (o);
  o += 2;
  for (int c = 0; c &lt; inCount; c++) {
    coverageTableToXMLCount (stOffset + getOffset (o), counts);
    o += 2; }

  int aheadCount = getuint16 (o);
  o += 2;
  for (int c = 0; c &lt; aheadCount; c++) {
    coverageTableToXMLCount (stOffset + getOffset (o), counts);
    o += 2; }
</code-fragment>

<code-fragment id="chainingLookup.toXML_3">
    int o = stOffset + 2;

    int backCount = getuint16 (o);
    o += 2;
    for (int c = 0; c &lt; backCount; c++) {
      coverageTableToXML (conf, stOffset + getOffset (o), counts);
      o += 2; }

    int inCount = getuint16 (o);
    o += 2;
    for (int c = 0; c &lt; inCount; c++) {
      coverageTableToXML (conf, stOffset + getOffset (o), counts);
      o += 2; }

    int aheadCount = getuint16 (o);
    o += 2;
    for (int c = 0; c &lt; aheadCount; c++) {
      coverageTableToXML (conf, stOffset + getOffset (o), counts);
      o += 2; }
</code-fragment>

<code-fragment id="chainingLookup.toXMLEmit_3">
    int o = stOffset + 2;

    conf.ch.startElement (&quot;backCoverages&quot;, new AttributesImpl ()); {
      int backCount = getuint16 (o);
      o += 2;
      o += (backCount - 1) * 2;
      for (int c = 0; c &lt; backCount; c++) {
        at = new AttributesImpl ();
        coverageTableOffsetToXML (conf, stOffset + getOffset (o), counts,
                                  &quot;coverage&quot;, at);
        o -= 2; }
      o += (backCount + 1) * 2;
      conf.ch.endElement (&quot;backCoverages&quot;); }

    conf.ch.startElement (&quot;inCoverages&quot;, new AttributesImpl ()); {
      int inCount = getuint16 (o);
      o += 2;
      for (int c = 0; c &lt; inCount; c++) {
        at = new AttributesImpl ();
        coverageTableOffsetToXML (conf, stOffset + getOffset (o), counts,
                                  &quot;coverage&quot;, at);
        o += 2; }
      conf.ch.endElement (&quot;inCoverages&quot;); }

    conf.ch.startElement (&quot;aheadCoverages&quot;, new AttributesImpl ()); {
      int aheadCount = getuint16 (o);
      o += 2;
      for (int c = 0; c &lt; aheadCount; c++) {
        at = new AttributesImpl ();
        coverageTableOffsetToXML (conf, stOffset + getOffset (o), counts,
                                  &quot;coverage&quot;, at);
        o += 2; }
      conf.ch.endElement (&quot;aheadCoverages&quot;); }

    int posCount = getuint16 (o);
    o += 2;
    subLookupsToXML (conf, posCount, o);
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>


<code-fragment id="chainingLookup_format3">
  <code-title>Execute chaining format 3 subtable and return</code-title>
  { int backtrackGlyphCount = getuint16 (stOffset + 2);
    int inputGlyphCount = getuint16 (stOffset + 4 + 2*backtrackGlyphCount);
    int lookaheadGlyphCount = getuint16 (stOffset + 6 + 2*backtrackGlyphCount
                                         + 2*inputGlyphCount);

    int backPos = curGlyph - 1;

    for (int b = 0 ; b &lt; backtrackGlyphCount; b++) {
      while (lookupFlagCovers (lookupFlag, gr.glyphAt (backPos))) {
        backPos--; }

      if (-1 == getCoverageIndex (gr.glyphAt (backPos),
                                  stOffset + getOffset (stOffset + 4 + 2*b))) {
        return lookupNotApplied; }

      backPos--; }

    int [] matchedPositions = new int [inputGlyphCount];
    int inPos = curGlyph;

    for (int i = 0; i &lt; inputGlyphCount; i++) {
      if (i != 0) {
        while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
          inPos++; }}

      if (-1 == getCoverageIndex (gr.glyphAt (inPos),
                                  stOffset + getOffset (  stOffset + 6
                                                        + 2*backtrackGlyphCount
                                                        + 2*i))) {
        return lookupNotApplied; }

      matchedPositions [i] = inPos;
      inPos++; }

    if (! gr.isLookupApplied (lookupIndex, curGlyph, inPos - 1)) {
      return lookupNotApplied; }

    for (int l = 0; l &lt; lookaheadGlyphCount; l++) {

      while (lookupFlagCovers (lookupFlag, gr.glyphAt (inPos))) {
        inPos++; }

      if (-1 == getCoverageIndex (gr.glyphAt (inPos),
                                  stOffset + getOffset (  stOffset + 8
                                                        + 2*backtrackGlyphCount
                                                        + 2*inputGlyphCount
                                                        + 2*l))) {
        return lookupNotApplied; }

      inPos++; }

    int applyCountOffset = stOffset + 8
                                + 2*backtrackGlyphCount
                                + 2*inputGlyphCount
                                + 2*lookaheadGlyphCount;
    int applyCount = getuint16 (applyCountOffset);
    int applyOffset = applyCountOffset + 2;
    if (listener != null) {
      listener.applyingSubtable (lookupIndex, gr, curGlyph,
                                 Tag.tag2string (tag), stOffset); }
    return applySubLookups (gr, matchedPositions, applyCount, applyOffset); }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

        <section>
          <title>chaining3_simple</title>

          <para>A simple test to start.</para>

<aots:context-test-font id="chaining3_simple_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="3">
	<backCoverages>
	  <coverage glyphs="20" format="any"/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs="21" format="any"/>
	  <coverage glyphs="22" format="any"/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs="23" format="any"/>
	</aheadCoverages>

	<apply pos="0" lookup="lookup.single"/>
	<apply pos="1" lookup="lookup.single"/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining3_simple_t1" font="chaining3_simple_f1" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   62,   23,   00" xdeltas="0,    0,   20,   20,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Our next set of tests verifies partial matches. It
            uses slightly more complicated pattern: 20 21 : 22 23 24 :
            25 26, with a standard sublookup applied on 22.</para>

<aots:context-test-font id="chaining3_simple_f2">
  <lookup id="lookup.test" type="chainingContextual">
	<chainingContextual format="3">
	  <backCoverages>
	    <coverage glyphs="20" format="any"/>
	    <coverage glyphs="21" format="any"/>
	  </backCoverages>
	  <inCoverages>
	    <coverage glyphs="22" format="any"/>
	    <coverage glyphs="23" format="any"/>
	    <coverage glyphs="24" format="any"/>
	  </inCoverages>
	  <aheadCoverages>
	    <coverage glyphs="25" format="any"/>
	    <coverage glyphs="26" format="any"/>
	  </aheadCoverages>

	  <apply pos="0" lookup="lookup.single"/>
	</chainingContextual>
  </lookup>
</aots:context-test-font>

          <para>First, let’s verify that the substitution works:</para>

          <aots:context-test id="chaining3_simple_t2" font="chaining3_simple_f2" inputs="00, 20,  21,  22,  23,  24,  25,  26,  00" outputs="00, 20,  21,  62,  23,  24,  25,  26,  00" xdeltas="0,   0,   0,  20,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Partial match on the lookahead:</para>

          <aots:context-test id="chaining3_simple_t3" font="chaining3_simple_f2" inputs="00, 20,  21,  22,  23,  24,  25,  00,  00" outputs="00, 20,  21,  22,  23,  24,  25,  00,  00" xdeltas="0,   0,   0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Not enough for the lookahead:</para>

          <aots:context-test id="chaining3_simple_t4" font="chaining3_simple_f2" inputs="00, 20,  21,  22,  23,  24,  25" outputs="00, 20,  21,  22,  23,  24,  25" xdeltas="0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0"/>


          <para>No glyphs at all for lookahead:</para>

          <aots:context-test id="chaining3_simple_t5" font="chaining3_simple_f2" inputs="00, 20,  21,  22,  23,  24" outputs="00, 20,  21,  22,  23,  24" xdeltas="0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0"/>

          <para>Partial match on backtrack:</para>

          <aots:context-test id="chaining3_simple_t6" font="chaining3_simple_f2" inputs="00, 00,  21,  22,  23,  24,  25,  26,  00" outputs="00, 00,  21,  22,  23,  24,  25,  26,  00" xdeltas="0,   0,   0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Not enough for the backtrack:</para>

          <aots:context-test id="chaining3_simple_t7" font="chaining3_simple_f2" inputs=" 21,  22,  23,  24,  25,  26,  00" outputs=" 21,  22,  23,  24,  25,  26,  00" xdeltas="  0,   0,   0,   0,   0,   0,   0" ydeltas="  0,   0,   0,   0,   0,   0,   0"/>

          <para>No glyphs for backtrack at all:</para>

          <aots:context-test id="chaining3_simple_t8" font="chaining3_simple_f2" inputs="22,  23,  24,  25,  26,  00" outputs="22,  23,  24,  25,  26,  00" xdeltas=" 0,   0,   0,   0,   0,   0" ydeltas=" 0,   0,   0,   0,   0,   0"/>

          <para>Partial match on the input:</para>

          <aots:context-test id="chaining3_simple_t9" font="chaining3_simple_f2" inputs="00, 20,  21,  22,  00,  24,  25,  26,  00" outputs="00, 20,  21,  22,  00,  24,  25,  26,  00" xdeltas="0,   0,   0,   0,   0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0,   0,   0,   0,   0"/>

          <para>Not enough glyphs for the input:</para>

          <aots:context-test id="chaining3_simple_t10" font="chaining3_simple_f2" inputs="00, 20,  21,  22,  23" outputs="00, 20,  21,  22,  23" xdeltas="0,   0,   0,   0,   0" ydeltas="0,   0,   0,   0,   0"/>

          <para>Only the first glyph of input matches:</para>

          <aots:context-test id="chaining3_simple_t11" font="chaining3_simple_f2" inputs="00, 20,  21,  22" outputs="00, 20,  21,  22" xdeltas="0,   0,   0,   0" ydeltas="0,   0,   0,   0"/>
        </section>

        <section>
          <title>chaining3_next_glyph</title>

          <para>The next test makes sure that after a match, the next glyph
	  being processed follows the input part of the pattern match, not
	  the lookahead part.</para>

<aots:context-test-font id="chaining3_next_glyph_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="3">
	<backCoverages>
	  <coverage glyphs="22" format="any"/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs="21" format="any"/>
	  <coverage glyphs="22" format="any"/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs="21" format="any"/>
	</aheadCoverages>

	<apply pos="0" lookup="lookup.single"/>

    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining3_next_glyph_t1" font="chaining3_next_glyph_f1" inputs="00,  22,   21,   22,   21,   22,  21,  00" outputs="00,  22,   61,   22,   61,   22,  21,  00" xdeltas="0,    0,   20,    0,   20,    0,   0,   0" ydeltas="0,    0,    0,    0,    0,    0,   0,   0"/>

        </section>

        <section>
          <title>chaining3_boundary</title>

          <para>Next, we test the boundary case of SubstCount equal to 0.</para>

<aots:context-test-font id="chaining3_boundary_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="3">
	<backCoverages>
	  <coverage glyphs="20" format="any"/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs="21" format="any"/>
	  <coverage glyphs="22" format="any"/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs="23" format="any"/>
	</aheadCoverages>

    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining3_boundary_t1" font="chaining3_boundary_f1" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   21,   22,   23,   00" xdeltas="0,    0,    0,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Boundary case: InputGlyphCount is 1.</para>

<aots:context-test-font id="chaining3_boundary_f2">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="3">
	<backCoverages>
	  <coverage glyphs="20" format="any"/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs="21" format="any"/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs="22" format="any"/>
	  <coverage glyphs="23" format="any"/>
	</aheadCoverages>

	<apply pos="0" lookup="lookup.single"/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining3_boundary_t2" font="chaining3_boundary_f2" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   22,   23,   00" xdeltas="0,    0,   20,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>

          <para>Boundary case: BacktrackGlyphCount is 0.</para>

<aots:context-test-font id="chaining3_boundary_f3">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="3">
	<backCoverages/>
	<inCoverages>
	  <coverage glyphs="21" format="any"/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs="22" format="any"/>
	  <coverage glyphs="23" format="any"/>
	</aheadCoverages>

	<apply pos="0" lookup="lookup.single"/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining3_boundary_t3" font="chaining3_boundary_f3" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   61,   22,   23,   00" xdeltas="0,    0,   20,    0,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>


          <para>Boundary case: AheadGlyphCount is 0.</para>

<aots:context-test-font id="chaining3_boundary_f4">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="3">
	<backCoverages>
	  <coverage glyphs="20" format="any"/>
	  <coverage glyphs="21" format="any"/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs="22" format="any"/>
	</inCoverages>
	<aheadCoverages>
	</aheadCoverages>

	<apply pos="0" lookup="lookup.single"/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining3_boundary_t4" font="chaining3_boundary_f4" inputs="00,  20,   21,   22,   23,   00" outputs="00,  20,   21,   62,   23,   00" xdeltas="0,    0,    0,   20,    0,    0" ydeltas="0,    0,    0,    0,    0,    0"/>
        </section>


        <section>
          <title>chaining3_successive</title>

          <para>In this test, we verify the case described in the
          SubstLookupRecord section. The matched sequence is 18 19 20
          21. Glyphs 19 and 20 are replaced by glyph 23 and glyph 21
          is replaced by glyph 24. The difficult part is that the
          lookup that replaces 21 by 24 is applied at position 2,
          which is counted after the ligature substitution is
          applied.</para>

<aots:context-test-font id="chaining3_successive_f1">
  <lookup id="lookup.test" type="chainingContextual">
    <chainingContextual format="3">
	<backCoverages>
	  <coverage glyphs="25" format="any"/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs="20" format="any"/>
	  <coverage glyphs="21" format="any"/>
	  <coverage glyphs="22" format="any"/>
	  <coverage glyphs="23" format="any"/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs="24" format="any"/>
	</aheadCoverages>

	<apply pos="1" lookup="lookup.double"/>
	<apply pos="2" lookup="lookup.single"/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining3_successive_t1" font="chaining3_successive_f1" inputs="00,  25,  20,   21,   22,   23,   24,  00" outputs="00,  25,  20,   61,         63,   24,  00" xdeltas="0,    0,   0,   20,   20,    0,    0,   0" ydeltas="0,    0,   0,    0,    0,    0,    0,   0"/>
        </section>

        <section>
          <title>chaining3_lookupflag</title>

          <para>Our next test case involves LookupFlag. The input
          sequence is 18 : 19 20 : 21, and at each position the
          glyphID is increased by 4. Glyph 26 is covered by
          lookupFlag.</para>

<aots:context-test-font id="chaining3_lookupflag_f1">
  <lookup id="lookup.test" type="chainingContextual" ignoreMarks="yes">
    <chainingContextual format="3">
	<backCoverages>
	  <coverage glyphs="20" format="any"/>
	  <coverage glyphs="21" format="any"/>
	</backCoverages>
	<inCoverages>
	  <coverage glyphs="22" format="any"/>
	  <coverage glyphs="23" format="any"/>
	  <coverage glyphs="24" format="any"/>
	</inCoverages>
	<aheadCoverages>
	  <coverage glyphs="25" format="any"/>
	  <coverage glyphs="26" format="any"/>
	</aheadCoverages>

	<apply pos="1" lookup="lookup.single"/>
    </chainingContextual>
  </lookup>
</aots:context-test-font>

          <aots:context-test id="chaining3_lookupflag_t1" font="chaining3_lookupflag_f1" inputs="00, 20, 90, 21, 91, 22, 92, 23, 93, 94, 24, 90, 25, 91, 26, 00" outputs="00, 20, 90, 21, 91, 22, 92, 63, 93, 94, 24, 90, 25, 91, 26, 00" xdeltas=" 0,  0,  0,  0,  0,  0,  0, 20,  0,  0,  0,  0,  0,  0,  0,  0" ydeltas=" 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0"/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>LookupType 7: Extension Substitution</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>This lookup provides a mechanism whereby any other
          lookup type's subtables are stored at a 32-bit offset
          location in the <ottable>GSUB</ottable> table. This is
          needed if the total size of the subtables exceeds the 16-bit
          limits of the various other offsets in the
          <ottable>GSUB</ottable> table. In this specification, the
          subtable stored at the 32-bit offset location is termed the
          “extension” subtable.</para>

        <otformat>
          <title>ExtensionSubstFormat1 subtable</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>SubstFormat</otfieldname>
            <otfielddesc>Format identifier. Set to 1.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>ExtensionLookupType</otfieldname>
            <otfielddesc>Lookup type of subtable referenced by
              ExtensionOffset (i.e. the extension
              subtable).</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>ExtensionOffset</otfieldname>
            <otfielddesc>Offset to the extension subtable, of lookup
              type ExtensionLookupType, relative to the start of the
              ExtensionSubstFormat1 subtable.</otfielddesc>
          </otfield>
        </otformat>

        <para>ExtensionLookupType must be set to any lookup type other
          than 7. All subtables in a LookupType 7 lookup must have the
          same ExtensionLookupType. All offsets in the extension
          subtables are set in the usual way, i.e. relative to the
          extension subtables themselves.</para>

        <para>When an CommonType layout engine encounters a LookupType 7
          Lookup table, it shall:</para>

        <itemizedlist>
          <listitem>
            <para>Proceed as though the Lookup table's LookupType
              field were set to the ExtensionLookupType of the
              subtables.</para>
          </listitem>
          <listitem>
            <para>Proceed as though each extension subtable referenced
              by ExtensionOffset replaced the LookupType 7 subtable
              that referenced it.</para>
          </listitem>
        </itemizedlist>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

	<para>This subtable does not match a pattern by itself, nor
	  does it have an action by itself.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Coverage tables</code-title>
  extensionTable |=
    attribute format { &quot;1&quot; },
    element ext {
      attribute type { text },
      attribute name { text }
    }

  standaloneExtensionTable =
    element extensionTable { attribute id { text }, extensionTable }

  extensionTableOffset = attribute name { text } | extensionTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  protected Block extensionFormat1FromXML (Element subtable, Element table,
                                           Map&lt;Element, Block&gt; blockCache,
					   Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    Block me;

    Element ext = (Element) subtable.getFirstChild ();

    int targetType = Integer.parseInt (ext.getAttribute (&quot;type&quot;));
    String t = ext.getAttribute (&quot;name&quot;);
    Element targetElem = resolveXMLid (table, t);
    Block target = lookupSubtableFromXML (targetElem, table,
                                          blockCache, targetType, lookupIndices);

    me = new Block (8, 1);
    me.setuint16 (0, 1);
    me.setuint16 (2, targetType);
    me.setBigOffset (4, target);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  public void extensionLookupToXMLCount (int stOffset, int[] counts) {
    int targetType = getuint16 (stOffset + 2);
    int extensionOffset = stOffset + (int) getuint32 (stOffset + 4);

    lookupSubtableToXMLCount (extensionOffset, counts, targetType);

    // This will force the target to be emitted on its own
    counts [extensionOffset] += 2;
  }

  public void extensionLookupToXML (DecompilerConfig conf,
                                   int stOffset, int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    int targetType = getuint16 (stOffset + 2);
    int extensionOffset = stOffset + (int) getuint32 (stOffset + 4);

    lookupSubtableToXML (conf, extensionOffset, counts, targetType);
  }

  public void extensionLookupToXMLEmit (DecompilerConfig conf,
                                        int stOffset, int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    int targetType = getuint16 (stOffset + 2);
    int extensionOffset = stOffset + (int) getuint32 (stOffset + 4);

    AttributesImpl at = new AttributesImpl ();

    at.addAttribute (&quot;&quot;, &quot;type&quot;, &quot;type&quot;, &quot;CDATA&quot;, &quot;&quot; + targetType);

    counts [extensionOffset] += 2;
    lookupSubtableOffsetToXML (conf, extensionOffset, counts, targetType);

    conf.ch.element (&quot;ext&quot;, at);
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="lookuptable.methods">
  <code-title>Execute GSUB 7 subtable and return</code-title>
  public LookupResult applyExtensionLookupSubtable
                          (int lookupIndex, int lookupType, int lookupFlag,
                           int stOffset, GlyphRun gr, int curGlyph)
      throws InvalidFontException {

    int extensionLookupType = getuint16 (stOffset + 2);
    int extensionOffset = stOffset + (int)getuint32 (stOffset + 4);

    return applyLookupSubtable (lookupIndex, extensionLookupType,
                                lookupFlag, extensionOffset, gr,
                                curGlyph);
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Test Suite</title>

        <section>
          <title>gsub7_font1/2: basic tests</title>

	  <para>Our first font has a single subtable.</para>

<aots:test-font id="gsub7_font1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="7">
	<extensionSubst format="1">
	  <ext type="1" name="singlesubst"/>
	</extensionSubst>
      </lookup>
    </lookupList>

    <singleSubstTable id="singlesubst" format="1">
      <coverage glyphs="18 19" format="any"/>
      <delta v="5"/>
    </singleSubstTable>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub7_test1" font="gsub7_font1" inputs="17, 18, 19, 20, 21" outputs="17, 23, 24, 20, 21"/>

	  <para>Let’s have multiple subtables.</para>

<aots:test-font id="gsub7_font2">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <lookup id="lookup.test" type="7">
	<extensionSubst format="1">
	  <ext type="1" name="singlesubst1"/>
	</extensionSubst>
	<extensionSubst format="1">
	  <ext type="1" name="singlesubst2"/>
	</extensionSubst>
      </lookup>
    </lookupList>

    <singleSubstTable id="singlesubst1" format="1">
      <coverage glyphs="18" format="any"/>
      <delta v="5"/>
    </singleSubstTable>

    <singleSubstTable id="singlesubst2" format="1">
      <coverage glyphs="19" format="any"/>
      <delta v="10"/>
    </singleSubstTable>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="gsub7_test2" font="gsub7_font2" inputs="17, 18, 19, 20, 21" outputs="17, 23, 29, 20, 21"/>

        </section>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Lookup Type 8: Reverse Chaining Contextual Single
	Substitution</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

	<para>Reverse Chaining Contextual Single Substitution subtable
	  (ReverseChainSingleSubst) describes single glyph
	  substitutions in context with an ability to look back and/or
	  look ahead in the sequence of glyphs. The major difference
	  between this and other lookup types is that processing of
	  input glyph sequence goes from end to start. Comparing to
	  Chaining Contextual Sustitution this format is restricted to
	  only coverage based subtable format, input sequence could
	  contain only single glyph and only single substitution
	  allowed on this glyph. This substitution rule is integrated
	  into subtable format.</para>

	<para>This lookup type is designed specifically for the Arabic
	  script writing styles, like nastaliq, where the shape of the
	  glyph is determined by the following glyph, beginning at the
	  last glyph of the &quot;joor&quot;, or set of connected glyphs. An
	  example of this lookup type is defined in Example 10 at the
	  end of this chapter.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Reverse Chaining Contextual Single Substitution Format 1:
	Coverage Based Reverse Chaining Contextual Single Glyph
	Substitution.</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

	<para>Format 1 defines a chaining context rule as a sequence
	  of Coverage tables. Each position in the sequence may define
	  a different Coverage table for the set of glyphs that
	  matches the context pattern. With Format 1, the glyph sets
	  defined in the different Coverage tables may
	  intersect.</para>

	<para>Note: Despite reverse order processing, the order of the
	  Coverage tables listed in the Coverage array must be in
	  logical order (follow the writing direction). The backtrack
	  sequence is as illustrated in the LookupType 6: Chaining
	  Contextual Substitution subtable. The input sequence is one
	  glyph located at i in the logical string. The backtrack
	  begins at i - 1 and increases in offset value as one moves
	  toward the logical beginning of the string. The lookahead
	  sequence begins at i + 1 and increases in offset value as
	  one moves toward the logical end of the string. In the
	  reverse chaining process i began at the logical end of the
	  string and moves to the beginning.</para>

	<para>The subtable contains Coverage table for input glyph and
	  Coverage table arrays for lookahead and backtrack sequences,
	  also count of output glyph indices in the Substitute array
	  (GlyphCount), and a list of the output glyph indices
	  (Substitute array). The Substitute array must contain the
	  same number of glyph indices as the Coverage table. To
	  locate the corresponding output glyph index in the
	  Substitute array, this format uses the Coverage Index
	  returned from the Coverage table.</para>

	<otformat>
	  <title>ReverseChainSingleSubstFormat1 subtable:
	    Coverage-based Reverse Chaining Contextual Single Glyph
	    substitution.</title>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>uint16</otfieldtype>
	    <otfieldname>SubstFormat</otfieldname>
	    <otfielddesc>Format identifier ’ format = 1</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>Offset</otfieldtype>
	    <otfieldname>Coverage</otfieldname>
	    <otfielddesc>Offset to Coverage table - from beginning of
	      Substitution table</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>uint16</otfieldtype>
	    <otfieldname>BacktrackGlyphCount</otfieldname>
	    <otfielddesc>Number of glyphs in the backtracking
	      sequence</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>Offset</otfieldtype>
	    <otfieldname>Coverage [BacktrackGlyphCount]</otfieldname>
	    <otfielddesc>Array of offsets to coverage tables in
	      backtracking sequence, in glyph sequence order</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>uint16</otfieldtype>
	    <otfieldname>LookaheadGlyphCount</otfieldname>
	    <otfielddesc>Number of glyphs in lookahead sequence</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>Offset</otfieldtype>
	    <otfieldname>Coverage[LookaheadGlyphCount]</otfieldname>
	    <otfielddesc>Array of offsets to coverage tables in
	      lookahead sequence, in glyph sequence order</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>uint16</otfieldtype>
	    <otfieldname>GlyphCount</otfieldname>
	    <otfielddesc>Number of GlyphIDs in the Substitute array</otfielddesc>
	  </otfield>

	  <otfield>
	    <otfieldoffs>0</otfieldoffs>
	    <otfieldtype>GlyphID</otfieldtype>
	    <otfieldname>Substitute[GlyphCount]</otfieldname>
	    <otfielddesc>Array of substitute GlyphIDs-ordered by
	      Coverage Index</otfielddesc>
	  </otfield>
	</otformat>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Substitution Lookup Record</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>All contextual substitution subtables specify the
          substitution data in a Substitution Lookup Record
          (SubstLookupRecord). Each record contains a SequenceIndex,
          which indicates the position where the substitution will
          occur in the glyph sequence. In addition, a LookupListIndex
          identifies the lookup to be applied at the glyph position
          specified by the SequenceIndex.</para>

        <para>The contextual substitution subtables defined in
          Examples 7, 8, and 9 at the end of this chapter show
          SubstLookupRecords.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>As noted earlier, the description of a SubstLookupRecord
          should be moved back in this section.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>subLookups</code-title>
  subLookups =
    element apply {
      attribute pos { text },
      attribute lookup { text }
    }*
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  private int subLookupsFromXML (int count, NodeList nl, Block b, int offset,
                                 Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {
    for (int k = 0; k &lt; count; k++) {
      Element apply = (Element) nl.item (k);
      b.setuint16 (offset,
                   Integer.parseInt (apply.getAttribute (&quot;pos&quot;)));

      String lookupName = apply.getAttribute (&quot;lookup&quot;);
      int index = 0;
      try {
        index = Integer.parseInt (lookupName); }
      catch (java.lang.NumberFormatException e) {
        Integer ii = lookupIndices.get (lookupName);
        if (ii == null) {
          warning (&quot;cannot resolve '&quot; + lookupName + &quot;'&quot;); }
        index = ii.intValue (); }

      b.setuint16 (offset + 2, index);

      offset += 4; }

    return offset;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  protected void subLookupsToXML (DecompilerConfig conf, int count, int offset)
      throws org.xml.sax.SAXException, InvalidFontException {

    for (int i = 0; i &lt; count; i++) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;pos&quot;, &quot;pos&quot;, &quot;CDATA&quot;, &quot;&quot; + getuint16 (offset));
      at.addAttribute (&quot;&quot;, &quot;lookup&quot;, &quot;lookup&quot;, &quot;CDATA&quot;,
                       &quot;lookup_&quot; + getuint16 (offset + 2));
      conf.ch.element (&quot;apply&quot;, at);
      offset += 4; }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="lookuptable.methods">
  <code-title>Apply subLookups</code-title>
  public LookupResult applySubLookups (GlyphRun gr, int[] matchedPositions,
                                       int count, int offset)
      throws InvalidFontException {

    LookupResult result
      = new LookupResult (true,
                          matchedPositions [matchedPositions.length -1] + 1,
                          0);

    for (int su = 0; su &lt; count; su++) {
      int sequenceIndex = getuint16 (offset);
      int lookupListIndex = getuint16 (offset + 2);
      offset += 4;
      LookupResult r = applyLookup (lookupListIndex, gr,
                                    matchedPositions [sequenceIndex]);
      if (r.applied) {
        result.nextToProcess += r.countAdjust;
        result.countAdjust += r.countAdjust; }}

    return result;
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>GSUB Subtable Examples</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The rest of this chapter describes and illustrates
          examples of all the <ottable>GSUB</ottable> subtables,
          including each of the three formats available for contextual
          substitutions. All the examples reflect unique parameters
          described below, but the samples provide a useful reference
          for building subtables specific to other situations.</para>

        <para>All the examples have three columns showing hex data,
          source, and comments.</para>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 1: GSUB Header Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 1 shows a typical <ottable>GSUB</ottable> Header table
          definition.</para>

        <otexample>
          <title>Example 1</title>
          <otexline>
            <otexdata/>
            <otexsrc>GSUBHeader</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>TheGSUBHeader</otexsrc>
            <otexcom>GSUBHeader table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>00010000</otexdata>
            <otexsrc>0x00010000</otexsrc>
            <otexcom>version</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>TheScriptList</otexsrc>
            <otexcom>offset to ScriptList table</otexcom>
          </otexline>
          <otexline>
            <otexdata>001E</otexdata>
            <otexsrc>TheFeatureList</otexsrc>
            <otexcom>offset to FeatureList table</otexcom>
          </otexline>
          <otexline>
            <otexdata>002C</otexdata>
            <otexsrc>TheLookupList</otexsrc>
            <otexcom>offset to LookupList table</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 2: SingleSubstFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 2 illustrates the SingleSubstFormat1 subtable,
          which uses ranges to replace single input glyphs with their
          corresponding output glyphs. The indices of the output
          glyphs are calculated by adding a constant delta value to
          the indices of the input glyphs. In this example, the
          Coverage table has a format identifier of 1 to indicate the
          range format, which is used because the input glyph indices
          are in consecutive order in the font. The Coverage table
          specifies one range that contains a StartGlyphID for the &quot;0&quot;
          (zero) glyph and an EndGlyphID for the &quot;9&quot; glyph.</para>


        <otexample>
          <title>Example 2</title>
          <otexline>
            <otexdata/>
            <otexsrc>SingleSubstFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>LiningNumeralSubtable</otexsrc>
            <otexcom>SingleSubst subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat, ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>LiningNumeralCoverage</otexsrc>
            <otexcom>offset to Coverage table for input
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>00C0</otexdata>
            <otexsrc>192</otexsrc>
            <otexcom>DeltaGlyphID = 192, add to each input glyph
                  index to produce output glyph inde</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat2</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>LiningNumeralCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CoverageFormat, ranges   1 RangeCount
                  RangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004E</otexdata>
            <otexsrc>78</otexsrc>
            <otexcom>Start GlyphID for numeral zero glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0058</otexdata>
            <otexsrc>87</otexsrc>
            <otexcom>End GlyphID for numeral nine glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>StartCoverageIndex first CoverageIndex =
                  0</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 3: SingleSubstFormat2 Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 3 uses the SingleSubstFormat2 subtable for lists
          to substitute punctuation glyphs in Japanese text that is
          written vertically. Horizontally oriented parentheses and
          square brackets (the input glyphs) are replaced with
          vertically oriented parentheses and square brackets (the
          output glyphs).</para>
        <para>The Coverage table, Format 1, identifies each input
          glyph index. The number of input glyph indices listed in the
          Coverage table matches the number of output glyph indices
          listed in the subtable. For correct substitution, the order
          of the glyph indices in the Coverage table (input glyphs)
          must match the order in the Substitute array (output
          glyphs).</para>


        <otexample>
          <title>Example 3</title>
          <otexline>
            <otexdata/>
            <otexsrc>SingleSubstFormat2</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>VerticalPunctuationSubtable</otexsrc>
            <otexcom>SingleSubst
                  subtable definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SubstFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>VerticalPunctuationCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>GlyphCount, equals GlyphCount in Coverage
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0131</otexdata>
            <otexsrc>VerticalOpenBracketGlyph</otexsrc>
            <otexcom>Substitute[0], ordered by Coverage
                  Index</otexcom>
          </otexline>
          <otexline>
            <otexdata>0135</otexdata>
            <otexsrc>VerticalClosedBracketGlyph</otexsrc>
            <otexcom>Substitute[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>013E</otexdata>
            <otexsrc>VerticalOpenParenthesisGlyph</otexsrc>
            <otexcom>Substitute[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0143</otexdata>
            <otexsrc>VerticalClosedParenthesisGlyph</otexsrc>
            <otexcom>Substitute[3</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>VerticalPunctuationCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>003C</otexdata>
            <otexsrc>HorizontalOpenBracketGlyph</otexsrc>
            <otexcom>GlyphArray[0], ordered by GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>HorizontalClosedBracketGlyph</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004B</otexdata>
            <otexsrc>HorizontalOpenParenthesisGlyph</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004F</otexdata>
            <otexsrc>HorizontalClosedParenthesisGlyph</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 4: MultipleSubstFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 4 uses a MultipleSubstFormat1 subtable to
          replace a single &quot;ffi&quot; ligature with three individual glyphs
          that form the string &lt;ffi&gt;. The subtable defines a format
          identifier of 1, an offset to a Coverage table that
          specifies the glyph index of the &quot;ffi&quot; ligature (the input
          glyph), an offset to a Sequence table that specifies the
          sequence of glyph indices for the &lt;ffi&gt; string in its
          substitute array (the output glyph sequence), and a count of
          Sequence table offsets.</para>


        <otexample>
          <title>Example 4</title>
          <otexline>
            <otexdata/>
            <otexsrc>MultipleSubstFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>FfiDecompSubtable</otexsrc>
            <otexcom>MultipleSubst subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>FfiDecompCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceCount, equals GlyphCount in Coverage
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>FfiDecompSequence</otexsrc>
            <otexcom>offset to Sequence[0] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>FfiDecompCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>00F1</otexdata>
            <otexsrc>ffiGlyphID</otexsrc>
            <otexcom>ligature glyp</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Sequence</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>FfiDecompSequence</otexsrc>
            <otexcom>Sequence table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>first glyph in sequence order</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>second glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>001D</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>third glyph</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 5: AlternateSubstFormat 1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 5 uses the AlternateSubstFormat1 subtable to
          replace the default ampersand glyph (input glyph) with one
          of two alternative ampersand glyphs (output glyph).</para>
        <para>In this case, the Coverage table specifies the index of
          a single glyph, the default ampersand, because it is the
          only glyph covered by this lookup. The AlternateSet table
          for this covered glyph identifies the alternative glyphs:
          AltAmpersand1GlyphID and AltAmpersand2GlyphID.</para>
        <para>In Example 5, the index position of the AlternateSet
          table offset in the AlternateSet array is zero (0), which
          correlates with the index position (also zero) of the
          default ampersand glyph in the Coverage table.</para>


        <otexample>
          <title>Example 5</title>
          <otexline>
            <otexdata/>
            <otexsrc>AlternateSubstFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>AltAmpersandSubtable</otexsrc>
            <otexcom>AlternateSubstFormat1
                  subtable definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>AltAmpersandCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>AlternateSetCnt, equals GlyphCount in Coverage
                  table</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>AltAmpersandSet</otexsrc>
            <otexcom>offset to AlternateSet[0] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>AltAmpersandCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>003A</otexdata>
            <otexsrc>DefaultAmpersandGlyphID</otexsrc>
            <otexcom>GlyphArray[0</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>AlternateSet</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>AltAmpersandSet</otexsrc>
            <otexcom>AlternateSet table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>00C9</otexdata>
            <otexsrc>AltAmpersand1GlyphID</otexsrc>
            <otexcom>offset to Alternate[0], in arbitrary
                  order</otexcom>
          </otexline>
          <otexline>
            <otexdata>00CA</otexdata>
            <otexsrc>AltAmpersand2GlyphID</otexsrc>
            <otexcom>offset to Alternate[1]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 6: LigatureSubstFormat1 Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 6 shows a LigatureSubstFormat1 subtable that
          defines data to replace a string of glyphs with a single
          ligature glyph. Because a LigatureSubstFormat1 subtable can
          specify glyph substitutions for more than one ligature, this
          subtable defines three ligatures: &quot;etc,&quot; &quot;ffi,&quot; and &quot;fi.&quot;
        </para>
        <para>The sample subtable contains a format identifier (4) and
          an offset to a Coverage table. The Coverage table, which
          lists an index for each first glyph in the ligatures, lists
          indices for the &quot;e&quot; and &quot;f&quot; glyphs. The Coverage table range
          format is used here because the &quot;e&quot; and &quot;f&quot; glyph indices
          are numbered consecutively.</para>
        <para>In the LigatureSubst subtable, LigSetCount specifies two
          LigatureSet tables, one for each covered glyph, and the
          LigatureSet array stores offsets to them. In this array, the
          &quot;e&quot; LigatureSet precedes the &quot;f&quot; LigatureSet, matching the
          order of the corresponding first-glyph components in the
          Coverage table.</para>
        <para>Each LigatureSet table identifies all ligatures that
          begin with a covered glyph. The sample LigatureSet table
          defined for the &quot;e&quot; glyph contains only one ligature, &quot;etc.&quot;
          A LigatureSet table defined for the &quot;f&quot; glyph contains two
          ligatures, &quot;ffi&quot; and &quot;fi.&quot;</para>
        <para>The sample FLigaturesSet table has offsets to two
          Ligature tables, one for &quot;ffi&quot; and one for &quot;fi.&quot; The
          Ligature array lists the &quot;ffi&quot; Ligature table first to
          indicate that the &quot;ffi&quot; ligature is preferred to the &quot;fi&quot;
          ligature.</para>


        <otexample>
          <title>Example 6</title>
          <otexline>
            <otexdata/>
            <otexsrc>LigatureSubstFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>LigaturesSubtable</otexsrc>
            <otexcom>LigatureSubstFormat1 subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>LigaturesCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LigSetCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>ELigaturesSet</otexsrc>
            <otexcom>offset to LigatureSet[0] table in Coverage
                  Index order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0020</otexdata>
            <otexsrc>FLigaturesSet</otexsrc>
            <otexcom>offset to LigatureSet[1] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat2</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>LigaturesCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CoverageFormat, ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>RangeCount RangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0019</otexdata>
            <otexsrc>eGlyphID</otexsrc>
            <otexcom>Start, first GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>End, last GlyphID in range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>StartCoverageIndex, coverage index of start
                  glyphI</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>LigatureSet</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>ELigaturesSet</otexsrc>
            <otexcom>LigatureSet table definition all
                  ligatures that start with e</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LigatureCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>etcLigature</otexsrc>
            <otexcom>offset to Ligature[0] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Ligature</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>etcLigature</otexsrc>
            <otexcom>Ligature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>015B</otexdata>
            <otexsrc>etcGlyphID</otexsrc>
            <otexcom>LigGlyph, output GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>CompCount number of components</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>tGlyphID</otexsrc>
            <otexcom>Component[1], second component in
                  ligature</otexcom>
          </otexline>
          <otexline>
            <otexdata>0017</otexdata>
            <otexsrc>cGlyphID</otexsrc>
            <otexcom>Component[2], third component in
                  ligatur</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>LigatureSet</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>FLigaturesSet</otexsrc>
            <otexcom>LigatureSet table definition all
                  ligatures start with f</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LigatureCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0006</otexdata>
            <otexsrc>ffiLigature</otexsrc>
            <otexcom>offset to Ligature[0] table, listed first
                  because ffi ligature is preferred to fi
                  ligature</otexcom>
          </otexline>
          <otexline>
            <otexdata>000E</otexdata>
            <otexsrc>fiLigature</otexsrc>
            <otexcom>offset to Ligature[1] tabl</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Ligature</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>ffiLigature</otexsrc>
            <otexcom>Ligature table definitio</otexcom>
          </otexline>
          <otexline>
            <otexdata>00F1</otexdata>
            <otexsrc>ffiGlyphID</otexsrc>
            <otexcom>LigGlyph, output GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>CompCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>Component[1], second component in
                  ligature</otexcom>
          </otexline>
          <otexline>
            <otexdata>001D</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>Component[2], third component in
                  ligatur</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Ligature</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>fiLigature</otexsrc>
            <otexcom>Ligature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>00F0</otexdata>
            <otexsrc>fiGlyphID</otexsrc>
            <otexcom>LigGlyph, output GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CompCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>001D</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>Component[1] second component in
                  ligature</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 7: ContextSubstFormat1 Subtable and
        SubstLookupRecord</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 7 uses a ContextSubstFormat1 subtable for glyph
          sequences to replace a string of three glyphs with another
          string. For the French language system, the subtable defines
          a contextual substitution that replaces the input sequence,
          space-dash-space, with the output sequence, thin
          space-dash-thin space.</para>
        <para>The contextual substitution, called Dash Lookup in this
          example, contains one ContextSubstFormat1 subtable called
          the DashSubtable. The subtable specifies two contexts: a
          SpaceGlyph followed by a DashGlyph, and a DashGlyph followed
          by a SpaceGlyph. In each sequence, a single substitution
          replaces the SpaceGlyph with a ThinSpaceGlyph.</para>
        <para>The Coverage table, labeled DashCoverage, lists two
          GlyphIDs for the first glyphs in the SpaceGlyph and
          DashGlyph sequences. One SubRuleSet table is defined for
          each covered glyph.</para>
        <para>SpaceAndDashSubRuleSet lists all the contexts that begin
          with a SpaceGlyph. It contains an offset to one SubRule
          table (SpaceAndDashSubRule), which specifies two glyphs in
          the context sequence, the second of which is a DashGlyph.
          The SubRule table contains an offset to a SubstLookupRecord
          that lists the position in the sequence where the glyph
          substitution should occur (position 0) and the index of the
          SpaceToThinSpaceLookup applied there to replace the
          SpaceGlyph with a ThinSpaceGlyph. DashAndSpaceSubRuleSet
          lists all the contexts that begin with a DashGlyph. An
          offset to a SubRule table (DashAndSpaceSubRule) specifies
          two glyphs in the context sequence, and the second one is a
          SpaceGlyph. The SubRule table contains an offset to a
          SubstLookupRecord, which lists the position in the sequence
          where the glyph substitution should occur, and an index to
          the same lookup used in the SpaceAndDashSubRule. The lookup
          replaces the SpaceGlyph with a ThinSpaceGlyph.</para>


        <otexample>
          <title>Example 7</title>
          <otexline>
            <otexdata/>
            <otexsrc>ContextSubstFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>DashSubtable</otexsrc>
            <otexcom>ContextSubstFormat1 subtable
                  definition for Lookup[0], DashLookup</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>DashCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SubRuleSetCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0012</otexdata>
            <otexsrc>SpaceAndDashSubRuleSet</otexsrc>
            <otexcom>offset to SubRuleSet[0], ordered by Coverage
                  Index</otexcom>
          </otexline>
          <otexline>
            <otexdata>0020</otexdata>
            <otexsrc>DashAndSpaceSubRuleSet</otexsrc>
            <otexcom>offset to SubRuleSet[1</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>DashCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>SpaceGlyph</otexsrc>
            <otexcom>GlyphArray[0], in numeric order</otexcom>
          </otexline>
          <otexline>
            <otexdata>005D</otexdata>
            <otexsrc>DashGlyph</otexsrc>
            <otexcom>GlyphArray[1], dash GlyphI</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SubRuleSet</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SpaceAndDashSubRuleSet</otexsrc>
            <otexcom>SubRuleSet[0] table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubRuleCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>SpaceAndDashSubRule</otexsrc>
            <otexcom>offset to SubRule[0], ordered by
                  preferenc</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SubRule</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SpaceAndDashSubRule</otexsrc>
            <otexcom>SubRule[0] table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount number in input sequence</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>005D</otexdata>
            <otexsrc>DashGlyph</otexsrc>
            <otexcom>Input[1], starting with second glyph SpaceGlyph
                  in Coverage table is first glyph
                  SubstLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>SequenceIndex substitution at first glyph
                  position (0)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex index for
                  SpaceToThinSpaceLookup in LookupLis</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SubRuleSet</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>DashAndSpaceSubRuleSet</otexsrc>
            <otexcom>SubRuleSet[0] table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubRuleCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>DashAndSpaceSubRule</otexsrc>
            <otexcom>offset to SubRule[0], ordered by
                  preferenc</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SubRule</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>DashAndSpaceSubRule</otexsrc>
            <otexcom>SubRule[0] table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount number in the input glyph
                  sequence</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>SpaceGlyph</otexsrc>
            <otexcom>Input[1], starting with second glyph
                  SubstLookupRecord definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceIndex substitution at second glyph
                  position(1)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex for
                  SpaceToThinSpaceLookup</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 8: ContextSubstFormat2 Subtable </title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 8 uses a ContextSubstFormat2 subtable with glyph
          classes to replace default mark glyphs with their
          alternative forms. Glyph alternatives are selected depending
          upon the height of the base glyph that they combine
          with-that is, the mark glyph used above a high base glyph
          differs from the mark glyph above a very high base
          glyph.</para>
        <para>In the example, SetMarksHighSubtable contains a Class
          table that defines four glyph classes: medium-height glyphs
          (Class 0), all default mark glyphs (Class 1), high glyphs
          (Class 2), and very high glyphs (Class 3). The subtable also
          contains a Coverage table that lists each base glyph that
          functions as a first component in a context, ordered by
          glyph index.</para>
        <para>Two SubClassSets are defined, one for substituting high
          marks and one for very high marks. No SubClassSets are
          specified for Class 0 and Class 1 glyphs because no contexts
          begin with glyphs from these classes. The SubClassSet array
          lists SubClassSets in numerical order, so SubClassSet 2
          precedes SubClassSet 3.</para>
        <para>Within each SubClassSet, a SubClassRule is defined. In
          SetMarksHighSubClassSet2, the SubClassRule table specifies
          two glyphs in the context, the first glyph in Class 2 (a
          high glyph) and the second in Class 1 (a mark glyph). The
          SubstLookupRecord specifies applying
          SubstituteHighMarkLookup at the second position in the
          sequence-that is, a high mark glyph will replace the default
          mark glyph.</para>
        <para>In SetMarksVeryHighSubClassSet3, the SubClassRule
          specifies two glyphs in the context, the first in Class 3 (a
          very high glyph) and the second in Class 1 (a mark glyph).
          The SubstLookupRecord specifies applying
          SubstituteVeryHighMarkLookup at the second position in the
          sequence-that is, a very high mark glyph will replace the
          default mark glyph.</para>


        <otexample>
          <title>Example 8</title>
          <otexline>
            <otexdata/>
            <otexsrc>ContextSubstFormat2</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SetMarksHighSubtable</otexsrc>
            <otexcom>ContextSubstFormat2
                  subtable definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0010</otexdata>
            <otexsrc>SetMarksHighCoverage</otexsrc>
            <otexcom>offset to Coverage table</otexcom>
          </otexline>
          <otexline>
            <otexdata>001C</otexdata>
            <otexsrc>SetMarksHighClassDef</otexsrc>
            <otexcom>offset to Class Def table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>SubClassSetCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to SubClassSet[0] table, no contexts
                  that begin with Class 0 glyphs are defined</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>offset to SubClassSet[1] table no contexts that
                  begin with Class 1 glyphs are defined</otexcom>
          </otexline>
          <otexline>
            <otexdata>0032</otexdata>
            <otexsrc>SetMarksHighSubClassSet2</otexsrc>
            <otexcom>offset to SubClassSet[2] table for contexts
                  that begin with Class 2 glyphs (high base
                  glyphs)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>SetMarksVeryHighSubClassSet3</otexsrc>
            <otexcom>offset to SubClassSet[3] table for contexts
                  that begin with Class 3 glyphs (very high base
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SetMarksHighCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat, lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>tahGlyphID</otexsrc>
            <otexcom>GlyphArray[0], high base glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0031</otexdata>
            <otexsrc>dhahGlyphID</otexsrc>
            <otexcom>GlyphArray[1], high base glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>cafGlyphID</otexsrc>
            <otexcom>GlyphArray[2], very high base glyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>gafGlyphID</otexsrc>
            <otexcom>GlyphArray[3], very high base glyp</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>ClassDefFormat2</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SetMarksHighClassDef</otexsrc>
            <otexcom>Class table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class Format, ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ClassRangeCount ClassRange[0] ordered by
                  StartGlyphID for Class 2, high base glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>tahGlyphID</otexsrc>
            <otexcom>Start, first Glyph ID in range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0031</otexdata>
            <otexsrc>dhahGlyphID</otexsrc>
            <otexcom>End, last Glyph ID in range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class ClassRange[1] for Class 3, very high base
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>cafGlyphID</otexsrc>
            <otexcom>Start, first Glyph ID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>gafGlyphID</otexsrc>
            <otexcom>End, last Glyph ID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class ClassRange[2] for Class 1, mark
                  gyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D2</otexdata>
            <otexsrc>fathatanDefaultGlyphID</otexsrc>
            <otexcom>Start, first Glyph ID in range default fathatan
                  mark</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D3</otexdata>
            <otexsrc>dammatanDefaultGlyphID</otexsrc>
            <otexcom>End, last Glyph ID in the range default
                  dammatan mark</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Clas</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SubClassSet</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SetMarksHighSubClassSet2</otexsrc>
            <otexcom>SubClassSet[2] table
                  definition all contexts that begin with Class 2
                  glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubClassRuleCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>SetMarksHighSubClassRule2</otexsrc>
            <otexcom>offset to SubClassRule[0] table ordered by
                  preferenc</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SubClassRule</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SetMarksHighSubClassRule2</otexsrc>
            <otexcom>SubClassRule[0] table
                  definition, Class 2 glyph (high base) glyph followed
                  by a Class 1 glyph (mark)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>offset to Class[1], beginning with the second
                  Class in the context sequence (mark = Class 1) begin
                  SubstLookupRecord array in design order
                  SubstLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceIndex, apply substitution to position
                  2, a mark</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SubClassSet</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SetMarksVeryHighSubClassSet3</otexsrc>
            <otexcom>SubClassSet[3]
                  table definition all contexts that begin with Class
                  3 glyphs</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubClassRuleCnt</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>SetMarksVeryHighSubClassRule3</otexsrc>
            <otexcom>offset to SubClassRule[0] table ordered by
                  preferenc</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SubClassRule</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SetMarksVeryHighSubClassRule3</otexsrc>
            <otexcom>SubClassRule[0]
                  table definition Class 3 glyph (very high base
                  glyph) followed by a Class 1 glyph (mark)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>offset to Class[1], beginning with the second
                  Class in the context sequence = marks, Class 1 begin
                  SubstLookupRecord array in design order
                  SubstLookupRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SequenceIndex, apply substitution to position
                  2, second glyph class (mark)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LookupListIndex</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 9: ContextualSubstFormat3 Subtable</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 9 uses the ContextSubstFormat3 subtable with
          Coverage tables to describe a context sequence of three
          lowercase glyphs in the pattern: any ascender or descender
          glyph in position 0 (zero), any x-height glyph in position
          1, and any descender glyph in position 2. The overlapping
          sets of covered glyphs for positions 0 and 2 make Format 3
          better for this context than the class-based Format
          2.</para>
        <para>In positions 0 and 2, swash versions of the glyphs
          replace the default glyphs. The contextual-substitution
          lookup is SwashLookup (LookupList index = 0), and its
          subtable is SwashSubtable. The SwashSubtable defines three
          Coverage tables: AscenderDescenderCoverage, XheightCoverage,
          and DescenderCoverage-one for each glyph position in the
          context sequence, respectively.</para>
        <para>The SwashSubtable also defines two SubstLookupRecords:
          one that applies to position 0, and one for position 2. (No
          substitutions are applied to position 1.) The record for
          position 0 uses a single substitution lookup called
          AscDescSwashLookup to replace the current ascender or
          descender glyph with a swash ascender or descender glyph.
          The record for position 2 uses a single substitution lookup
          called DescSwashLookup to replace the current descender
          glyph with a swash descender glyph.</para>


        <otexample>
          <title>Example 9</title>
          <otexline>
            <otexdata/>
            <otexsrc>ContextSubstFormat3</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>SwashSubtable</otexsrc>
            <otexcom>ContextSubstFormat3 subtable
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>SubstFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>GlyphCount in input glyph sequence</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SubstCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>AscenderDescenderCoverage</otexsrc>
            <otexcom>offset to Coverage[0] table in context sequence
                  order</otexcom>
          </otexline>
          <otexline>
            <otexdata>004C</otexdata>
            <otexsrc>XheightCoverage</otexsrc>
            <otexcom>offset to Coverage[1] table</otexcom>
          </otexline>
          <otexline>
            <otexdata>006E</otexdata>
            <otexsrc>DescenderCoverage</otexsrc>
            <otexcom>offset to Coverage[2] table
                  SubstLookupRecord[0] in glyph position order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>SequenceIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex, single substitution to output
                  ascender or descender swash
                  SubstLookupRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>SequenceIndex</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LookupListIndex single substitution to output
                  descender swas</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>AscenderDescenderCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat, lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>12</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0033</otexdata>
            <otexsrc>bGlyphID</otexsrc>
            <otexcom>GlyphArray[0] in GlyphID order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0035</otexdata>
            <otexsrc>dGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0037</otexdata>
            <otexsrc>fGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0038</otexdata>
            <otexsrc>gGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0039</otexdata>
            <otexsrc>hGlyphID</otexsrc>
            <otexcom>GlyphArray[4]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003B</otexdata>
            <otexsrc>jGlyphID</otexsrc>
            <otexcom>GlyphArray[5]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003C</otexdata>
            <otexsrc>kGlyphID</otexsrc>
            <otexcom>GlyphArray[6]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003D</otexdata>
            <otexsrc>lGlyphID</otexsrc>
            <otexcom>GlyphArray[7]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>pGlyphID</otexsrc>
            <otexcom>GlyphArray[8]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0042</otexdata>
            <otexsrc>qGlyphID</otexsrc>
            <otexcom>GlyphArray[9]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0045</otexdata>
            <otexsrc>tGlyphID</otexsrc>
            <otexcom>GlyphArray[10]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004A</otexdata>
            <otexsrc>yGlyphID</otexsrc>
            <otexcom>GlyphArray[11</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>XheightCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat, lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>000F</otexdata>
            <otexsrc>15</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0032</otexdata>
            <otexsrc>aGlyphID</otexsrc>
            <otexcom>GlyphArray[0] in GlyphID order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0034</otexdata>
            <otexsrc>cGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0036</otexdata>
            <otexsrc>eGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003A</otexdata>
            <otexsrc>iGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003E</otexdata>
            <otexsrc>mGlyphID</otexsrc>
            <otexcom>GlyphArray[4]</otexcom>
          </otexline>
          <otexline>
            <otexdata>003F</otexdata>
            <otexsrc>nGlyphID</otexsrc>
            <otexcom>GlyphArray[5]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>oGlyphID</otexsrc>
            <otexcom>GlyphArray[6]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0043</otexdata>
            <otexsrc>rGlyphID</otexsrc>
            <otexcom>GlyphArray[7]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0044</otexdata>
            <otexsrc>sGlyphID</otexsrc>
            <otexcom>GlyphArray[8]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0045</otexdata>
            <otexsrc>tGlyphID</otexsrc>
            <otexcom>GlyphArray[9]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0046</otexdata>
            <otexsrc>uGlyphID</otexsrc>
            <otexcom>GlyphArray[10]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0047</otexdata>
            <otexsrc>vGlyphID</otexsrc>
            <otexcom>GlyphArray[11]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0048</otexdata>
            <otexsrc>wGlyphID</otexsrc>
            <otexcom>GlyphArray[12]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0049</otexdata>
            <otexsrc>xGlyphID</otexsrc>
            <otexcom>GlyphArray[13]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004B</otexdata>
            <otexsrc>zGlyphID</otexsrc>
            <otexcom>GlyphArray[14</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>DescenderCoverage</otexsrc>
            <otexcom>Coverage table
                  definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat, lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0005</otexdata>
            <otexsrc>5</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0038</otexdata>
            <otexsrc>gGlyphID</otexsrc>
            <otexcom>GlyphArray[0] in GlyphID order</otexcom>
          </otexline>
          <otexline>
            <otexdata>003B</otexdata>
            <otexsrc>jGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>pGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0042</otexdata>
            <otexsrc>qGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004A</otexdata>
            <otexsrc>yGlyphID</otexsrc>
            <otexcom>GlyphArray[4]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 10: ReverseChainSingleSubstFormat1 Subtable
	and SubstLookupRecord</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

	<para>Example 10 uses a ReverseChainSingleSubstFormat1
	  subtable for glyph sequences to glyph with the correct form
	  that has a thick connection to the left (thick exit). This
	  allow the glyph to correctly connect to the letter form to
	  the left of it.</para>

	<para>The ThickExitCoverage table is the listing of glyphs to
	  be matched for substitution.</para>

	<para>The LookaheadCoverage table, labeled ThickEntryCoverage,
	  lists four GlyphIDs for the glyph following a substitution
	  coverage glyph. This lookahead coverage attempts to match
	  the context that will cause the substitution to take
	  place.</para>

	<para>The Substitute table maps the glyphs to replace those in
	  the ThickConnectCoverage table.</para>

	<otexample>
	  <title>Example 10</title>
	  <otexline>
	    <otexdata/>
	    <otexsrc>ReverseChainSingleSubstFormat1</otexsrc>
	    <otexcom/>
	  </otexline>
	  <otexline>
	    <otexdata>ThickConnect</otexdata>
	    <otexsrc>ReverseChainSingleSubstFormat1</otexsrc>
	    <otexcom>subtable definition</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0001</otexdata>
	    <otexsrc>1</otexsrc>
	    <otexcom>SubstFormat</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0068</otexdata>
	    <otexsrc>ThickExitCoverage</otexsrc>
	    <otexcom>offset to Coverage table</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0000</otexdata>
	    <otexsrc>0</otexsrc>
	    <otexcom>BacktrackGlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0000</otexdata>
	    <otexsrc>null</otexsrc>
	    <otexcom>not used offset to BacktrackCoverage[0]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0001</otexdata>
	    <otexsrc>1</otexsrc>
	    <otexcom>LookaheadGlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0026</otexdata>
	    <otexsrc>ThickEntryCoverage</otexsrc>
	    <otexcom>offset to LookaheadCoverage[0]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>000C</otexdata>
	    <otexsrc>12</otexsrc>
	    <otexcom>GlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00A7</otexdata>
	    <otexsrc>BEm2</otexsrc>
	    <otexcom>Substitute[0], ordered by Coverage Index</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00B9</otexdata>
	    <otexsrc>BEi3</otexsrc>
	    <otexcom>Substitute[1]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00C5</otexdata>
	    <otexsrc>JIMm3</otexsrc>
	    <otexcom>Substitute[2]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00D4</otexdata>
	    <otexsrc>JIMi2</otexsrc>
	    <otexcom>Substitute[3]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00EA</otexdata>
	    <otexsrc>SINm2</otexsrc>
	    <otexcom>Substitute[4]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00F2</otexdata>
	    <otexsrc>SINi2</otexsrc>
	    <otexcom>Substitute[5]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00FD</otexdata>
	    <otexsrc>SADm2</otexsrc>
	    <otexcom>Substitute[6]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>010D</otexdata>
	    <otexsrc>SADi2</otexsrc>
	    <otexcom>Substitute[7]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>011B</otexdata>
	    <otexsrc>TOEm3</otexsrc>
	    <otexcom>Substitute[8]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>012B</otexdata>
	    <otexsrc>TOEi3</otexsrc>
	    <otexcom>Substitute[9]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>013B</otexdata>
	    <otexsrc>AINm2</otexsrc>
	    <otexcom>Substitute[10]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0141</otexdata>
	    <otexsrc>AINi2</otexsrc>
	    <otexcom>Substitute[11]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata/>
	    <otexsrc>CoverageFormat1</otexsrc>
	    <otexcom/>
	  </otexline>
	  <otexline>
	    <otexdata>ThickEntryCoverage</otexdata>
	    <otexsrc>Coverage</otexsrc>
	    <otexcom>table definition</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0001</otexdata>
	    <otexsrc>1</otexsrc>
	    <otexcom>CoverageFormat, lists</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>001F</otexdata>
	    <otexsrc>31</otexsrc>
	    <otexcom>GlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00A5</otexdata>
	    <otexsrc>ALEFf1</otexsrc>
	    <otexcom>GlyphArray[0], in GlyphID order</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00A9</otexdata>
	    <otexsrc>BEm4</otexsrc>
	    <otexcom>GlyphArray[1]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00AA</otexdata>
	    <otexsrc>BEm5</otexsrc>
	    <otexcom>GlyphArray[2]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00E2</otexdata>
	    <otexsrc>DALf1</otexsrc>
	    <otexcom>GlyphArray[3]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0167</otexdata>
	    <otexsrc>KAFf1</otexsrc>
	    <otexcom>GlyphArray[4]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0168</otexdata>
	    <otexsrc>KAFfs1</otexsrc>
	    <otexcom>GlyphArray[5]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0169</otexdata>
	    <otexsrc>KAFm1</otexsrc>
	    <otexcom>GlyphArray[6]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>016D</otexdata>
	    <otexsrc>KAFm5</otexsrc>
	    <otexcom>GlyphArray[7]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>016E</otexdata>
	    <otexsrc>KAFm6</otexsrc>
	    <otexcom>GlyphArray[8]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0170</otexdata>
	    <otexsrc>KAFm8</otexsrc>
	    <otexcom>GlyphArray[9]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0183</otexdata>
	    <otexsrc>GAFf1</otexsrc>
	    <otexcom>GlyphArray[10]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0184</otexdata>
	    <otexsrc>GAFfs1</otexsrc>
	    <otexcom>GlyphArray[11]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0185</otexdata>
	    <otexsrc>GAFm1</otexsrc>
	    <otexcom>GlyphArray[12]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0189</otexdata>
	    <otexsrc>GAFm5</otexsrc>
	    <otexcom>GlyphArray[13]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>018A</otexdata>
	    <otexsrc>GAFm6</otexsrc>
	    <otexcom>GlyphArray[14]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>018C</otexdata>
	    <otexsrc>GAFm8</otexsrc>
	    <otexcom>GlyphArray[15]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>019F</otexdata>
	    <otexsrc>LAMf1</otexsrc>
	    <otexcom>GlyphArray[16]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A0</otexdata>
	    <otexsrc>LAMm1</otexsrc>
	    <otexcom>GlyphArray[17]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A1</otexdata>
	    <otexsrc>LAMm2</otexsrc>
	    <otexcom>GlyphArray[18]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A2</otexdata>
	    <otexsrc>LAMm3</otexsrc>
	    <otexcom>GlyphArray[19]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A3</otexdata>
	    <otexsrc>LAMm4</otexsrc>
	    <otexcom>GlyphArray[20]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A4</otexdata>
	    <otexsrc>LAMm5</otexsrc>
	    <otexcom>GlyphArray[21]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A5</otexdata>
	    <otexsrc>LAMm6</otexsrc>
	    <otexcom>GlyphArray[22]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A6</otexdata>
	    <otexsrc>LAMm7</otexsrc>
	    <otexcom>GlyphArray[23]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A7</otexdata>
	    <otexsrc>LAMm8</otexsrc>
	    <otexcom>GlyphArray[24]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A8</otexdata>
	    <otexsrc>LAMm9</otexsrc>
	    <otexcom>GlyphArray[25]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01A9</otexdata>
	    <otexsrc>LAMm10</otexsrc>
	    <otexcom>GlyphArray[26]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01AA</otexdata>
	    <otexsrc>LAMm11</otexsrc>
	    <otexcom>GlyphArray[27]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01AB</otexdata>
	    <otexsrc>LAMm12</otexsrc>
	    <otexcom>GlyphArray[28]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01AC</otexdata>
	    <otexsrc>LAMm13</otexsrc>
	    <otexcom>GlyphArray[29]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>01EC</otexdata>
	    <otexsrc>HAYf2</otexsrc>
	    <otexcom>GlyphArray[30]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata/>
	    <otexsrc>CoverageFormat1</otexsrc>
	    <otexcom/>
	  </otexline>
	  <otexline>
	    <otexdata>ThickExitCoverage</otexdata>
	    <otexsrc>Coverage</otexsrc>
	    <otexcom>table definition</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0001</otexdata>
	    <otexsrc>1</otexsrc>
	    <otexcom>CoverageFormat, lists</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>000C</otexdata>
	    <otexsrc>12</otexsrc>
	    <otexcom>GlyphCount</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00A6</otexdata>
	    <otexsrc>BEm1</otexsrc>
	    <otexcom>GlyphArray[0], ordered by GlyphID</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00B7</otexdata>
	    <otexsrc>BEi1</otexsrc>
	    <otexcom>GlyphArray[1]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00C3</otexdata>
	    <otexsrc>JIMm1</otexsrc>
	    <otexcom>GlyphArray[2]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00D2</otexdata>
	    <otexsrc>JIMi1</otexsrc>
	    <otexcom>GlyphArray[3]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00E9</otexdata>
	    <otexsrc>SINm1</otexsrc>
	    <otexcom>GlyphArray[4]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00F1</otexdata>
	    <otexsrc>SINi1</otexsrc>
	    <otexcom>GlyphArray[5]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>00FC</otexdata>
	    <otexsrc>SADm1</otexsrc>
	    <otexcom>GlyphArray[6]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>010C</otexdata>
	    <otexsrc>SADi1</otexsrc>
	    <otexcom>GlyphArray[7]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0119</otexdata>
	    <otexsrc>TOEm1</otexsrc>
	    <otexcom>GlyphArray[8]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0129</otexdata>
	    <otexsrc>TOEi1</otexsrc>
	    <otexcom>GlyphArray[9]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>013A</otexdata>
	    <otexsrc>AINm1</otexsrc>
	    <otexcom>GlyphArray[10]</otexcom>
	  </otexline>
	  <otexline>
	    <otexdata>0140</otexdata>
	    <otexsrc>AINi1</otexsrc>
	    <otexcom>GlyphArray[11]</otexcom>
	  </otexline>
	</otexample>
      </section>
    </section>
  </section>
