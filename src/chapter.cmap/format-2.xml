<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <section role="fragment">
    <title>Format 2: High-byte mapping through table </title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>This subtable is designed to faciliate mapping characters to glyphs
          within the encoding mechanisms which use a mixed 8/16-bit encoding,
          such as the legacy national character code standards used for Japanese,
          Chinese, and Korean characters.
      </para>
      <para>In a mixed encoding, codepoints may be represented either by a one
          byte integer or a two byte integer, with certain values of the initial
          byte acting as a continuation signal.</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Format number is set to 2.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>Length in bytes of the subtable.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>language</otfieldname>
          <otfielddesc>Language ID (for Macintosh language-specific mappings)</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>6</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>subHeaderKeys [256]</otfieldname>
          <otfielddesc>Array that maps high bytes to subHeaders:
              value is subHeader index * 8.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>518</otfieldoffs>
          <otfieldtype>4 words struct</otfieldtype>
          <otfieldname>subHeaders []</otfieldname>
          <otfielddesc>Variable-length array of subHeader
              structures.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs></otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>glyphIndexArray []</otfieldname>
          <otfielddesc>Variable-length array containing subarrays
              used for mapping the low byte of 2-byte
              characters.</otfielddesc>
        </otfield>
      </otformat>

      <para>A subHeader is structured as follows:</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>firstCode</otfieldname>
          <otfielddesc>First valid low byte for this
              subHeader.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>entryCount</otfieldname>
          <otfielddesc>Number of valid low bytes for this
              subHeader.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>SHORT</otfieldtype>
          <otfieldname>idDelta</otfieldname>
          <otfielddesc>See text below.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>6</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>idRangeOffset</otfieldname>
          <otfielddesc>See text below.</otfielddesc>
        </otfield>
      </otformat>

      <para>The firstCode and entryCount values specify the range of low-byte
          values handled by this subheader. Bytes outside of this range are
          mapped to glyph index 0.
      </para>
      <para>
          The value of idRangeOffset points to the element of the
          glyphElement array corresponding to the firstCode. Note that
          unlike most offset values in this standard, the idRangeOffset
          counts the number of bytes from <emphasis>the byte position of
          the idRangeOffset record itself</emphasis> to the target element,
          rather than from the start of the subtable header.
      </para>
      <para>
          The value of idDelta specifies a delta to be added the glyph ID,
          modulo 65536, to permit the same range to be used for several
          different subheaders.
      </para>

      <para>subHeader 0 must contain the following values:</para>
      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row><entry>firstCode</entry><entry>0</entry></row>
            <row><entry>entryCount</entry><entry>256</entry></row>
            <row><entry>idDelta</entry><entry>0</entry></row>
            <row><entry>idRangeOffset</entry><entry>offset to start of glyphIndexArray</entry></row>
          </tbody>
        </tgroup>
      </informaltable>

      <section>
        <title>Mapping Process for Font Consumers</title>
        <para>
          To map codepoints to glyph IDs in a format 0 subtable, the font
          consumer should consume the input character stream one byte at a time,
          and perform the following sequence of operations.
        </para>
        <para>
          First, the input byte is used to index the subHeaderKeys array to
          obtain a <emphasis>subheader key</emphasis>.
        </para>
        <para>
          Where the subheader key is 0, this indicates that the
          input byte is the only byte in this codepoint. The input byte is
          then directly looked up in the glyphIndexArray to obtain the glyph ID.
        </para>
        <para>
          Where the subheader key is greater than 0, this indicates a two-byte
          character. First, the subheader key should be divided by 8,
          and the font consumer should then use this to index into the subheader
          array to obtain the appropriate subheader.
        </para>
        <para>
          Next, the font consumer should consume another input byte, the <emphasis>low byte</emphasis>, and ensure that the value of the low byte is within
          the range of this subheader - that is, that the low byte is more than or
          equal to firstCode and less than firstCode+entryCount. If the low byte
          is not within the range of the subheader, glyph ID 0 is returned.
        </para>
        <para>firstCode is then subtracted from the low byte to determine the
          <emphasis>index offset</emphasis>. The font consumer will then advance
          idRangeOffset bytes from the position of the idRangeOffset element in
          the subheader to find the beginning of the glyph mapping subrange, and
          then also advance by the index offset to determine the glyph ID.</para>
        <para>Finally, if the glyph ID is non-zero and idDelta is non-zero,
          idDelta is added to the glyph ID module 65536 to return the final glyph ID.
        </para>
      </section>
    </section>
    <!--____________________________________________________________________-->
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="validation-3.xml"/>
  </section>
