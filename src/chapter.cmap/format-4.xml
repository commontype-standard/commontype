<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
  <!--======================================================================-->
  <section role="fragment">
    <title>Format 4: Segment mapping to delta values</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>This format is used to map Unicode characters in the Basic
          Multilingual Plane. It is used when the codepoints to be mapped
          can be divided into several contiguous ranges or <emphasis>segments</emphasis>. The segments may include codepoints which are not mapped
          to glyphs.
        </para>
      <para>
          The subtable has three parts. First, a header which includes parameters
          for an optimized search of the segment list:</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Format number is set to 4.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>Length in bytes of the subtable.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>language</otfieldname>
          <otfielddesc>Language ID (for Macintosh language-specific mappings)</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>6</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>segCountX2</otfieldname>
          <otfielddesc>2 x segCount.</otfielddesc>
        </otfield>
        <otfield role="deprecated">
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>searchRange</otfieldname>
          <otfielddesc>2 x (2**floor(log2(segCount)))</otfielddesc>
        </otfield>
        <otfield role="deprecated">
          <otfieldoffs>10</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>entrySelector</otfieldname>
          <otfielddesc>log2(searchRange/2)</otfielddesc>
        </otfield>
        <otfield role="deprecated">
          <otfieldoffs>12</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>rangeShift</otfieldname>
          <otfielddesc>2 x segCount - searchRange</otfielddesc>
        </otfield>
      </otformat>
            <para>The number of segments is specified by segCount, which
          is not explicitly in the header; however, all of the header
          parameters are derived from it. The searchRange value is
          twice the largest power of 2 that is less than or equal to
          segCount.</para>

          <para>After the header, four parallel arrays describe the segments:</para>

      <otformat>
        <otfield>
          <otfieldoffs>14</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>endCode [segCount]</otfieldname>
          <otfielddesc>End characterCode for each segment,
              last=0xFFFF.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>14+ 2 *segCount</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>reservedPad</otfieldname>
          <otfielddesc>Set to 0.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>16+ 2 *segCount</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>startCode [segCount]</otfieldname>
          <otfielddesc>Start character code for each
              segment.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>16+ 4 *segCount</otfieldoffs>
          <otfieldtype>SHORT</otfieldtype>
          <otfieldname>idDelta [segCount]</otfieldname>
          <otfielddesc>Delta for all character codes in
              segment.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>16+ 6 *segCount</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>idRangeOffset [segCount]</otfieldname>
          <otfielddesc>Offsets into glyphIdArray or 0</otfielddesc>
        </otfield>
      </otformat>
      <para>
          Note that
          unlike most offset values in this standard, the idRangeOffset
          counts the number of bytes from <emphasis>the byte position of
          the idRangeOffset record itself</emphasis> to the target element,
          rather than from the start of the subtable header.
        </para>
        <para>
          The final segment must have an endCode value of 0xFFFF.
          This segment need not contain any valid mappings, but must be present.
        </para>
          <para>Finally, there is a variable-length array of glyph IDs.</para>
      <otformat>
        <otfield>
          <otfieldoffs>16+ 8 *segCount</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>glyphIdArray []</otfieldname>
          <otfielddesc>Glyph index array (arbitrary length)
            </otfielddesc>
        </otfield>
      </otformat>
      <para>
          The segment values are specified in four parallel arrays.
          Each segment is described by a startCode and endCode,
          along with an idDelta and an idRangeOffset, which are used
          for mapping the character codes in the segment. The segments
          are sorted in order of increasing endCode values.
      </para>
    </section>
          <section>
        <title>Mapping Process for Font Consumers</title>
        <para>
          To map codepoints to glyph IDs in a format 4 subtable, the font
          consumer should first search the segment arrays for the first endCode
          that is greater than or equal to the codepoint to be mapped. If the
          corresponding startCode is less than or equal to the character code,
          then the segment contains a mapping for this codepoint. Otherwise,
          the missing glyph ID 0 is returned.
        </para>
        <para>
          XXX this para and next still needs rewriting.
          If the idRangeOffset value for the segment is not 0, the
          mapping of character codes relies on glyphIdArray. The
          character code offset from startCode is added to the
          idRangeOffset value. This sum is used as an offset from the
          current location within idRangeOffset itself to index out
          the correct glyphIdArray value. This obscure indexing trick
          works because glyphIdArray immediately follows idRangeOffset
          in the font file. The C expression that yields the glyph
          index is:</para>
      <literallayout>
  *(idRangeOffset[i]/2
    + (c - startCode[i])
    + &amp;idRangeOffset[i])
    </literallayout>
      <para>The value c is the character code in question, and i is
          the segment index in which c appears. If the value obtained
          from the indexing operation is not 0 (which indicates
          missingGlyph), idDelta[i] is added to it to get the glyph
          index. The idDelta arithmetic is modulo 65536.</para>
      <para>If the idRangeOffset is 0, the idDelta value is added
          directly to the codepoint modulo 65536 (i.e. (idDelta[i] + c)%65536)
          and the value is returned as the glyph ID.</para>
    </section>
    <!--____________________________________________________________________-->
    <section role="discussion">
      <title>Discussion</title>
      <para>Here is an example of filling in the header information for a table
        with 39 segments:
      </para>
      <informaltable>
        <tgroup cols="3">
          <tbody>
            <row>
              <entry>segCountX2</entry>
              <entry>78</entry>
              <entry/>
            </row>
            <row>
              <entry>searchRange</entry>
              <entry>64</entry>
              <entry>(2 * largest power of 2 &lt;=39)</entry>
            </row>
            <row>
              <entry>entrySelector</entry>
              <entry>5</entry>
              <entry>log2 (32)</entry>
            </row>
            <row>
              <entry>rangeShift</entry>
              <entry>14</entry>
              <entry>2 x 39 - 64</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
            <para>
        That said, the searchRange, entrySelector and rangeShift fields are
        ignored by all current implementations, and should be treated as unused.
      </para>
            <para>
        Uniscribe will fail if the final segment does not have an endCode
        of 0xFFFF, but other implementations will succeed.
      </para>
            <para>As an example of the mapping process, a subtable which maps
          codepoints 10-20, 30-90, and 153-480 onto a contiguous range
          of glyph indices may look like this:</para>
      <informaltable>
        <tgroup cols="5">
          <tbody>
            <row>
              <entry>segCountX2:</entry>
              <entry>8</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>searchRange:</entry>
              <entry>8</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>entrySelector:</entry>
              <entry>4</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>rangeShift:</entry>
              <entry>0</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>endCode:</entry>
              <entry>20</entry>
              <entry>90</entry>
              <entry>480</entry>
              <entry>0Xffff</entry>
            </row>
            <row>
              <entry>reservedPad:</entry>
              <entry>0</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>startCode:</entry>
              <entry>10</entry>
              <entry>30</entry>
              <entry>153</entry>
              <entry>0Xffff</entry>
            </row>
            <row>
              <entry>idDelta:</entry>
              <entry>-9</entry>
              <entry>-18</entry>
              <entry>-80</entry>
              <entry>1</entry>
            </row>
            <row>
              <entry>idRangeOffset:</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>This table performs the following mappings:</para>
      <literallayout>
10 -&gt; 10 - 9 = 1
20 -&gt; 20 - 9 = 11
30 -&gt; 30 - 18 = 12
90 -&gt; 90 - 18 = 72
153 -&gt; 153 - 80 = 73
...and so on.
</literallayout>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="validation-4.xml"/>
  </section>
