<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section xmlns:web="http://aots.adobe.com/2001/web" xmlns:rng="http://relaxng.org/ns/structure/1.0" xmlns:ots="http://aots.adobe.com/2001/ots" xmlns:aots="http://aots.adobe.com/2001/aots" id="chapter.cmap">
  <title>cmap - Character to Glyph Index Mapping Table</title>
  <!--======================================================================-->
  <section role="fragment">
    <title>Introduction</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>This table defines the mapping of character codes to the
          glyph index values used in the font. It may contain more
          than one subtable, in order to support more than one
          character encoding scheme. Character codes that do not
          correspond to any glyph in the font should be mapped to
          glyph index 0. The glyph at this location must be a special
          glyph representing a missing character, commonly known as
          .notdef.</para>
      <para>The table header indicates the character encodings for
          which subtables are present. Each subtable is in one of seven
          possible formats and begins with a format code indicating
          the format used.</para>
      <para>The platform ID and platform-specific encoding ID in the
          header entry (and, in the case of the Macintosh platform,
          the language field in the subtable itself) are used to
          specify a particular <ottable>cmap</ottable>
          encoding.The header entries must be sorted first by platform
          ID, then by platform-specific encoding ID, and then by the
          version field in the corresponding subtable. Each platform
          ID, platform-specific encoding ID, and subtable language
          combination may appear only once in the
          <ottable>cmap</ottable> table.</para>
      <para>When building a Unicode font for Windows, the platform
          ID should be 3 and the encoding ID should be 1. When
          building a symbol font for Windows, the platform ID should
          be 3 and the encoding ID should be 0. When building a font
          that will be used on the Macintosh, the platform ID should
          be 1 and the encoding ID should be 0.</para>
      <para>All Microsoft Unicode encodings (Platform ID = 3,
          Encoding ID = 1) must provide at least a Format 4
          <ottable>cmap</ottable> subtable. If the font is meant to
          support supplementary Unicode characters, it will additionally
          need a Format 12 subtable with a platform encoding ID 10.
          The contents of the Format 12 subtable need to be a superset
          of the contents of the Format 4 subtable. Microsoft
          <emphasis>strongly</emphasis> recommends using a Unicode
          <ottable>cmap</ottable> for all fonts. However, some other
          encodings that appear in current fonts follow:</para>
      <table>
        <title>Microsoft Encodings</title>
        <tgroup cols="3">
          <thead>
            <row>
              <entry>Platform ID</entry>
              <entry>Encoding ID</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>3</entry>
              <entry>0</entry>
              <entry>Symbol</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>1</entry>
              <entry>Unicode</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>2</entry>
              <entry>ShiftJIS</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>3</entry>
              <entry>PRC</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>4</entry>
              <entry>Big5</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>5</entry>
              <entry>Wansung</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>6</entry>
              <entry>Johab</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>7</entry>
              <entry>Reserved</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>9</entry>
              <entry>Reserved</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>9</entry>
              <entry>Reserved</entry>
            </row>
            <row>
              <entry>3</entry>
              <entry>10</entry>
              <entry>UCS-4</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>Unicode Variation Sequences supported by the font may be
        specified in the cmap table under platform ID 0 and encoding
        ID 5, using a format 14 cmap subtable.</para>
      <para>The Character To Glyph Index Mapping Table is organized
          as follows:</para>
      <otformat>
        <title>cmap Header</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>version</otfieldname>
          <otfielddesc>Table version number (0).</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>numTables</otfieldname>
          <otfielddesc>Number of encoding tables that follow.</otfielddesc>
        </otfield>
      </otformat>
      <para>The cmap table header is followed by an array of
	  encoding records that specify the particular encoding and
	  the offset to the subtable for that encoding. The number of
	  encoding records is numTables. An encoding record entry
	  looks like:</para>
      <otformat>
        <title>Encoding Record</title>
        <otfield>
          <otfieldoffs>4+8i</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>platformID</otfieldname>
          <otfielddesc>Platform ID.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4+8i+2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>encodingID</otfieldname>
          <otfielddesc>Platform-specific encoding ID.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4+8i+4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>offset</otfieldname>
          <otfielddesc>Byte offset from beginning of table to the
                  subtable for this encoding.</otfielddesc>
        </otfield>
      </otformat>
    </section>
    <!--____________________________________________________________________-->
    <section role="annotation">
      <title>Annotation</title>
      <para>The first paragraph covers three cases of missing
          glyphs: (1) there is a cmap subtable for the encoding but
          the character code is not covered by the subtable; (2) there
          is no subtable for the encoding; (3) there is a cmap for the
          encoding, but the format of that subtable is not 0, 2, 4 or
          6, 8, 10, or 12 (the currently defined formats). It is quite
          clear that the described behaviour applies to the first
          case, but it is not clear that this is the mandated
          behaviour in the second or third case. We assume it is.
          Recommendation: make that clear, by rephrasing: "Character
          codes that do not correspond to any glyph in the font
          (either because there is no subtable for their encoding or
          or because the subtable in a format not supported by the
          application or because the subtable does not map them)
          should be mapped to glyph index 0."</para>
      <para>The case of unknown formats is a bit more complicated.
          The recommendation is to mandate that all characters codes
          should map to glyph 0 for subtables in unknown
          formats.</para>
      <para>The descriptions of the fields of this table do not include
          names for them, as most other tables do. The recommendation
          is to include them: version, numTables, platformID,
          encodingID, offset.</para>
      <para>In the fifth paragraph, "UCS-4 (surrogate) characters"
          should be replaced by "Unicode supplemental characters" or
          "Unicode supplemental (non-BMP) characters". BMP characters are also
          UCS-4 characters. And anyways, UCS-4 is an encoding, not a
          character collection.</para>
      <para>It is legal to have a single subtable which is referenced
          from multiple entries? This is useful when a given character
          encoding is present on multiple platforms. For example, if
          there is a Unicode cmap subtable, it can be referenced from
          one entry with platformID/encodingID (0, 3), and from
          another entry with (3, 1).</para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-1.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-1.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-1.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-1.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-1.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="validation-1.xml"/>
  </section>
  <!--======================================================================-->
  <section role="fragment" id="cmap_cust">
    <title>OTF Windows NT compatibility mapping</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>If a platform ID 4 (custom), encoding ID 0-255 (OTF
          Windows NT compatibility mapping) <ottable>cmap</ottable>
          encoding is present in an CommonType font with CFF outlines,
          then the OTF font driver in Windows NT will: (a) superimpose
          the glyphs encoded at character codes 0-255 in the encoding
          on the corresponding Windows ANSI (code page 1252) Unicode
          values in the Unicode encoding it reports to the system; (b)
          add Windows ANSI (CharSet 0) to the list of CharSets
          supported by the font; and (c) consider the value of the
          encoding ID to be a Windows CharSet value and add it to the
          list of CharSets supported by the font. Note: The
          <ottable>cmap</ottable> subtable must use Format 0 or 6 for
          its subtable, and the encoding must be identical to the
          CFF's encoding.</para>
      <para>This <ottable>cmap</ottable> encoding is not required.
          It provides a compatibility mechanism for non-Unicode
          applications that use the font as if it were Windows ANSI
          encoded. Non-Windows ANSI Type 1 fonts, such as Cyrillic and
          Central European fonts, that Adobe shipped in the past had
          "0" (Windows ANSI) recorded in the CharSet field of the .PFM
          file; ATM for Windows 9x ignores the CharSet altogether.
          Adobe provides this compatibility <ottable>cmap</ottable>
          encoding in every OTF converted from a Type1 font in which
          the Encoding is not StandardEncoding.</para>
    </section>
  </section>
  <!--======================================================================-->
  <section role="fragment" id="language_note">
    <title>Note on the language field in <ottable>cmap</ottable>
        subtables</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>This field must be set to zero for all
          <ottable>cmap</ottable> subtables whose platform IDs are
          other than Macintosh (platform ID 1). For
          <ottable>cmap</ottable> subtables whose platform IDs are
          Macintosh, set this field to the Macintosh language ID of
          the <ottable>cmap</ottable> subtable plus one, or to zero if
          the <ottable>cmap</ottable> subtable is not
          language-specific. For example, a Mac OS Turkish
          <ottable>cmap</ottable> subtable must set this field to 18,
          since the Macintosh language ID for Turkish is 17. A Mac OS
          Roman <ottable>cmap</ottable> subtable must set this field
          to 0, since Mac OS Roman is not a language-specific
          encoding.</para>
    </section>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Format 0: Byte encoding table</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>This is the Apple standard character to glyph index
          mapping table.</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Format number is set to 0.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>This is the length in bytes of the
              subtable.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>language</otfieldname>
          <otfielddesc>Please see <link linkend="language_note">Note
                on the language field in cmap subtables</link> in this
              document.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>6</otfieldoffs>
          <otfieldtype>BYTE</otfieldtype>
          <otfieldname>glyphIdArray[256]</otfieldname>
          <otfielddesc>An array that maps character codes to glyph
              index values.</otfielddesc>
        </otfield>
      </otformat>
      <para>This is a simple 1 to 1 mapping of character codes to
          glyph indices. The glyph set is limited to 256. Note that if
          this format is used to index into a larger glyph set, only
          the first 256 glyphs will be accessible.</para>
    </section>
    <!--____________________________________________________________________-->
    <section role="annotation">
      <title>Annotation</title>
      <para>As the declaration stands, the length field seems
          superfluous, since the table appears to always be 262 bytes
          long. This can be explained in one of two ways:

          <itemizedlist>
          <listitem>
            <para>the length field is included to make the first three
                words of all cmap subtables similar; it must always be
                262.</para>
          </listitem>
          <listitem>
            <para>the glyphIdArray does not need to be always 256
                elements long, it can be shorter.</para>
          </listitem>
        </itemizedlist>
      </para>
      <para>In the spirit of "generate conservatively, accept
          liberally", we recommend that font designers always put 256
          entries in glyphIdArray (and consequently set length to 262), and
          that font consumers be ready to handle fonts where the
          glyphIdArray contains length - 6 entries (but no more than
          256).</para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-2.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-2.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-2.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-2.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-2.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="validation-2.xml"/>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Format 2: High-byte mapping through table </title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>This subtable is useful for the national character code
          standards used for Japanese, Chinese, and Korean characters.
          These code standards use a mixed 8/16-bit encoding, in which
          certain byte values signal the first byte of a 2-byte
          character (but these values are also legal as the second
          byte of a 2-byte character).</para>
      <para>In addition, even for the 2-byte characters, the mapping
          of character codes to glyph index values depends heavily on
          the first byte. Consequently, the table begins with an array
          that maps the first byte to a 4-word subHeader. For 2-byte
          character codes, the subHeader is used to map the second
          byte's value through a subArray, as described below. When
          processing mixed 8/16-bit text, subHeader 0 is special: it
          is used for single-byte character codes. When subHeader zero
          is used, a second byte is not needed; the single byte value
          is mapped through the subArray.</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Format number is set to 2.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>This is the length in bytes of the
              subtable.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>language</otfieldname>
          <otfielddesc>Please see <link linkend="language_note">Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>6</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>subHeaderKeys [256]</otfieldname>
          <otfielddesc>Array that maps high bytes to subHeaders:
              value is subHeader index * 8.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>518</otfieldoffs>
          <otfieldtype>4 words struct</otfieldtype>
          <otfieldname>subHeaders []</otfieldname>
          <otfielddesc>Variable-length array of subHeader
              structures.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>?</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>glyphIndexArray []</otfieldname>
          <otfielddesc>Variable-length array containing subarrays
              used for mapping the low byte of 2-byte
              characters.</otfielddesc>
        </otfield>
      </otformat>
      <para>A subHeader is structured as follows:</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>firstCode</otfieldname>
          <otfielddesc>First valid low byte for this
              subHeader.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>entryCount</otfieldname>
          <otfielddesc>Number of valid low bytes for this
              subHeader.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>SHORT</otfieldtype>
          <otfieldname>idDelta</otfieldname>
          <otfielddesc>See text below.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>6</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>idRangeOffset</otfieldname>
          <otfielddesc>See text below.</otfielddesc>
        </otfield>
      </otformat>
      <para>The firstCode and entryCount values specify a subrange
          that begins at firstCode and has a length equal to the value
          of entryCount. This subrange stays within the 0-255 range of
          the byte being mapped. Bytes outside of this subrange are
          mapped to glyph index 0 (missing glyph). The offset of the
          byte within this subrange is then used as index into a
          corresponding subarray of glyphIndexArray. This subarray is
          also of length entryCount. The value of the idRangeOffset is
          the number of bytes past the actual location of the
          idRangeOffset word where the glyphIndexArray element
          corresponding to firstCode appears.</para>
      <para>Finally, if the value obtained from the subarray is not
          0 (which indicates the missing glyph), you should add
          idDelta to it in order to get the glyphIndex. The value
          idDelta permits the same subarray to be used for several
          different subheaders. The idDelta arithmetic is modulo
          65536.</para>
    </section>
    <!--____________________________________________________________________-->
    <section role="annotation">
      <title>Annotation</title>
      <para>How about an intelligible description of the use of this
        format? Assuming that it intends to describe the same
        structure as the Apple True Type format, simply switching to
        their version would already be a vast improvement.</para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-3.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="validation-3.xml"/>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Format 4: Segment mapping to delta values</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>This is the Microsoft standard character to glyph index
          mapping table for fonts that support Unicode ranges other
          than the range [U+D800 - U+DFFF] (defined as Surrogates
          Area, in Unicode v 3.0) which is used for UCS-4
          characters. If a font supports this character range (i.e. in
          turn supports the UCS-4 characters) a subtable in this
          format with a platform specific encoding ID 1 is yet needed,
          in addition to a subtable in format 12 with a platform
          specific encoding ID 10. Please see details on format 12
          below, for fonts that support UCS-4 characters on
          Windows.</para>
      <para>This format is used when the character codes for the
          characters represented by a font fall into several
          contiguous ranges, possibly with holes in some or all of the
          ranges (that is, some of the codes in a range may not have a
          representation in the font). The format-dependent data is
          divided into three parts, which must occur in the following
          order:</para>
      <orderedlist>
        <listitem>
          <para>A four-word header gives parameters for an optimized
              search of the segment list;</para>
        </listitem>
        <listitem>
          <para>Four parallel arrays describe the segments (one
              segment for each contiguous range of codes);</para>
        </listitem>
        <listitem>
          <para>A variable-length array of glyph IDs (unsigned
              words).</para>
        </listitem>
      </orderedlist>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Format number is set to 4.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>This is the length in bytes of the
              subtable.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>language</otfieldname>
          <otfielddesc>Please see <link linkend="language_note">Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>6</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>segCountX2</otfieldname>
          <otfielddesc>2 x segCount.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>searchRange</otfieldname>
          <otfielddesc>2 x (2**floor(log2(segCount)))</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>10</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>entrySelector</otfieldname>
          <otfielddesc>log2(searchRange/2)</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>12</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>rangeShift</otfieldname>
          <otfielddesc>2 x segCount - searchRange</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>14</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>endCount [segCount]</otfieldname>
          <otfielddesc>End characterCode for each segment,
              last=0xFFFF.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>14+2i</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>reservedPad</otfieldname>
          <otfielddesc>Set to 0.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>16+2i</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>startCount [segCount]</otfieldname>
          <otfielddesc>Start character code for each
              segment.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>16+4i</otfieldoffs>
          <otfieldtype>SHORT</otfieldtype>
          <otfieldname>idDelta [segCount]</otfieldname>
          <otfielddesc>Delta for all character codes in
              segment.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>16+6i</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>idRangeOffset [segCount]</otfieldname>
          <otfielddesc>Offsets into glyphIdArray or 0</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>16+8i</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>glyphIdArray []</otfieldname>
          <otfielddesc>Glyph index array (arbitrary length)
            </otfielddesc>
        </otfield>
      </otformat>
      <para>The number of segments is specified by segCount, which
          is not explicitly in the header; however, all of the header
          parameters are derived from it. The searchRange value is
          twice the largest power of 2 that is less than or equal to
          segCount. For example, if segCount=39, we have the
          following:</para>
      <informaltable>
        <tgroup cols="3">
          <tbody>
            <row>
              <entry>segCountX2</entry>
              <entry>78</entry>
              <entry/>
            </row>
            <row>
              <entry>searchRange</entry>
              <entry>64</entry>
              <entry>(2 * largest power of 2 &lt;=39)</entry>
            </row>
            <row>
              <entry>entrySelector</entry>
              <entry>5</entry>
              <entry>log2 (32)</entry>
            </row>
            <row>
              <entry>rangeShift</entry>
              <entry>14</entry>
              <entry>2 x 39 - 64</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Each segment is described by a startCode and endCode,
          along with an idDelta and an idRangeOffset, which are used
          for mapping the character codes in the segment. The segments
          are sorted in order of increasing endCode values, and the
          segment values are specified in four parallel arrays. You
          search for the first endCode that is greater than or equal
          to the character code you want to map. If the corresponding
          startCode is less than or equal to the character code, then
          you use the corresponding idDelta and idRangeOffset to map
          the character code to a glyph index (otherwise, the
          missingGlyph is returned). For the search to terminate, the
          final endCode value must be 0xFFFF. This segment need not
          contain any valid mappings. (It can just map the single
          character code 0xFFFF to missingGlyph). However, the segment
          must be present.</para>
      <para>If the idRangeOffset value for the segment is not 0, the
          mapping of character codes relies on glyphIdArray. The
          character code offset from startCode is added to the
          idRangeOffset value. This sum is used as an offset from the
          current location within idRangeOffset itself to index out
          the correct glyphIdArray value. This obscure indexing trick
          works because glyphIdArray immediately follows idRangeOffset
          in the font file. The C expression that yields the glyph
          index is:</para>
      <literallayout>
  *(idRangeOffset[i]/2
    + (c - startCount[i])
    + &amp;idRangeOffset[i])
    </literallayout>
      <para>The value c is the character code in question, and i is
          the segment index in which c appears. If the value obtained
          from the indexing operation is not 0 (which indicates
          missingGlyph), idDelta[i] is added to it to get the glyph
          index. The idDelta arithmetic is modulo 65536.</para>
      <para>If the idRangeOffset is 0, the idDelta value is added
          directly to the character code offset (i.e. idDelta[i] + c)
          to get the corresponding glyph index. Again, the idDelta
          arithmetic is modulo 65536.</para>
      <para>As an example, the variant part of the table to map
          characters 10-20, 30-90, and 153-480 onto a contiguous range
          of glyph indices may look like this:</para>
      <informaltable>
        <tgroup cols="5">
          <tbody>
            <row>
              <entry>segCountX2:</entry>
              <entry>8</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>searchRange:</entry>
              <entry>8</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>entrySelector:</entry>
              <entry>4</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>rangeShift:</entry>
              <entry>0</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>endCode:</entry>
              <entry>20</entry>
              <entry>90</entry>
              <entry>480</entry>
              <entry>0Xffff</entry>
            </row>
            <row>
              <entry>reservedPad:</entry>
              <entry>0</entry>
              <entry/>
              <entry/>
              <entry/>
            </row>
            <row>
              <entry>startCode:</entry>
              <entry>10</entry>
              <entry>30</entry>
              <entry>153</entry>
              <entry>0Xffff</entry>
            </row>
            <row>
              <entry>idDelta:</entry>
              <entry>-9</entry>
              <entry>-18</entry>
              <entry>-27</entry>
              <entry>1</entry>
            </row>
            <row>
              <entry>idRangeOffset:</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
              <entry>0</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>This table performs the following mappings:</para>
      <literallayout>
10 -&gt; 10 - 9 = 1
20 -&gt; 20 - 9 = 11
30 -&gt; 30 - 18 = 12
90 -&gt; 90 - 18 = 72
...and so on.
</literallayout>
      <para>Note that the delta values could be reworked so as to
          reorder the segments.</para>
    </section>
    <!--____________________________________________________________________-->
    <section role="annotation">
      <title>Annotation</title>
      <para>The first sentence should probably be changed to
        "... for fonts that support Unicode BMP characters".</para>
      <para>In the table that describes the fields, it seems that
          the fields startCount and endCount should instead be
          startCode and endCode. These are better names, and are the
          names used in the text.</para>
      <para>In the example, the idDelta of the third range should
          probably be -80, so that the character code 153 is mapped to
          the glyphID 153-80 = 73.</para>
      <para>The meaning of the last sentence escapes me. May be it
        should be removed?</para>
      <para>It seems a necessary property of this format that the
          segments be disjoint, yet it is not mentionned
          explicitly.</para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-4.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="validation-4.xml"/>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Format 6: Trimmed table mapping </title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Format number is set to 6.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>This is the length in bytes of the
              subtable.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>language</otfieldname>
          <otfielddesc>Please see <link linkend="language_note">Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>6</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>firstCode</otfieldname>
          <otfielddesc>First character code of
              subrange.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>entryCount</otfieldname>
          <otfielddesc>Number of character codes in
              subrange.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>10</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>glyphIdArray [entryCount]</otfieldname>
          <otfielddesc>Array of glyph index values for character
              codes in the range. </otfielddesc>
        </otfield>
      </otformat>
      <para>The firstCode and entryCount values specify a subrange
          (beginning at firstCode, length = entryCount) within the
          range of possible character codes. Codes outside of this
          subrange are mapped to glyph index 0. The offset of the code
          (from the first code) within this subrange is used as index
          to the glyphIdArray, which provides the glyph index
          value.</para>
    </section>
    <!--____________________________________________________________________-->
    <section role="annotation">
      <title>Annotation</title>
      <para>It is unclear whether the entryCount can be 0. We assume
          it can and recommend to add a sentence to that
          effect.</para>
      <para>This format is very similar to format 0, in that there
          is an explicit list of glyph indices for a contiguous range
          of character code. However, there are two intersting
          properties: the range can be bigger than 256; and more
          importantly, the glyph indices are USHORT instead of
          BYTE. So this format can be used for byte encodings to reach
          glyphs other than the first 256 glyphs.</para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-5.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-5.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-5.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-5.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-5.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="validation-5.xml"/>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Supporting 4-byte character codes</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>While the four existing <ottable>cmap</ottable> subtable formats which
          currently exist have served us well, the introduction of the
          Surrogates Area in Unicode 2.0 has stressed them past the
          point of utility. This section specifies three formats,
          format 8, 10 and 12; which directly support 4-byte character
          codes. A major change introduced with these three formats is
          a more pure 32-bit orientation. The <ottable>cmap</ottable> table version
          number will continue to be 0x0000, for those fonts that make
          use of these formats.</para>
    </section>
    <!--____________________________________________________________________-->
    <section role="annotation">
      <title>Annotation</title>
      <para>A better formulation in the first sentence could be
        "... the introduction of supplemental characters in Unicode
        2.0..."</para>
      <para>The semicolon after "12" should be changed to a
        comma.</para>
    </section>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Format 8: mixed 16-bit and 32-bit coverage</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>Format 8 is a bit like format 2, in that it provides for
          mixed-length character codes. If a font contains characters
          from the Unicode Surrogates Area (U+D800-U+DFFF), which are
          UCS-4 characters; it's likely that it will also include
          other, regular 16-bit Unicodes as well. We therefore need a
          format to map a mixture of 16-bit and 32-bit character
          codes, just as format 2 allows a mixture of 8-bit and 16-bit
          codes. A simplifying assumption is made: namely, that there
          are no 32-bit character codes which share the same first 16
          bits as any 16-bit character code. This means that the
          determination as to whether a particular 16-bit value is a
          standalone character code or the start of a 32-bit character
          code can be made by looking at the 16-bit value directly,
          with no further information required.</para>
      <para>Here's the format 8 subtable format:</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Subtable format; set to 8.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>reserved</otfieldname>
          <otfielddesc>Reserved; set to 0</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>Byte length of this subtable (including the
              header)</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>language</otfieldname>
          <otfielddesc>Please see <link linkend="language_note">Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>12</otfieldoffs>
          <otfieldtype>BYTE</otfieldtype>
          <otfieldname>is32 [8192]</otfieldname>
          <otfielddesc>Tightly packed array of bits (8K bytes total)
              indicating whether the particular 16-bit (index) value
              is the start of a 32-bit character code
                </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8204</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname> nGroups</otfieldname>
          <otfielddesc> Number of groupings which follow
            </otfielddesc>
        </otfield>
      </otformat>
      <para>Here follow the individual groups. Each group has the
          following format:</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname> startCharCode</otfieldname>
          <otfielddesc> First character code in this group; note
              that if this group is for one or more 16-bit character
              codes (which is determined from the is32 array), this
              32-bit value will have the high 16-bits set to zero
            </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname> endCharCode</otfieldname>
          <otfielddesc> Last character code in this group; same
              condition as listed above for the startCharCode
                </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname> startGlyphID</otfieldname>
          <otfielddesc> Glyph index corresponding to the starting
              character code </otfielddesc>
        </otfield>
      </otformat>
      <para>A few notes here. The endCharCode is used, rather than a
          count, because comparisons for group matching are usually
          done on an existing character code, and having the
          endCharCode be there explicitly saves the necessity of an
          addition per group. Groups must be sorted by increasing
          startCharCode. A group's endCharCode must be less than the
          startCharCode of the following group, if any.</para>
      <para>To determine if a particular word (cp) is the first half
          of 32-bit code points, one can use an expression such as (
          is32[ cp / 8 ] &amp; ( 1 &lt;&lt; ( 7 - ( cp % 8 ) ) ) ). If this is
          non-zero, then the word is the first half of a 32-bit code
          point.</para>
      <para>0 is not a special value for the high word of a 32-bit
          code point. A font may not have both a glyph for the code
          point 0x0000 and glyphs for code points with a high word of
          0x0000.</para>
      <para>The presence of the packed array of bits indicating
          whether a particular 16-bit value is the start of a 32-bit
          character code is useful even when the font contains no
          glyphs for a particular 16-bit start value. This is because
          the system software often needs to know how many bytes ahead
          the next character begins, even if the current character
          maps to the missing glyph. By including this information
          explicitly in this table, no "secret" knowledge needs to be
          encoded into the OS.</para>
      <para>Although this format might work advantageously on some
          platforms for non-Unicode encodings, Microsoft does not
          support it for Unicode encoded UCS-4 characters.</para>
    </section>
    <!--____________________________________________________________________-->
    <section role="annotation">
      <title>Annotation</title>
      <para>First paragraph, second sentence, should be: "If a font
          maps Unicode supplemental characters, it's likely to map
          Unicode BMP characters as well."</para>
      <para>For coherence with the other formats, the description of
          the format field should be "Format number is set to 8" and
          the description of the length field should be "This is the
          length in bytes of the subtable."</para>
      <para>This format is dubious and would probably best be
          deprecated. If For Unicode encodings, it is useful only for
          UTF-16 (the only version that has 16 bit code units), so
          spending 8K bytes to is

If the intent is really for a Unicode encodings,
          then it is known </para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-6.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-6.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-6.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-6.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-6.xml"/>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Format 10: Trimmed array</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>Format 10 is a bit like format 6, in that it defines a
        trimmed array for a tight range of 32-bit character
        codes:</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Subtable format; set to 10.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>reserved</otfieldname>
          <otfielddesc>Reserved; set to 0</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>Byte length of this subtable (including the
              header) </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>language</otfieldname>
          <otfielddesc>Please see <link linkend="language_note">Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>12</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname> startCharCode</otfieldname>
          <otfielddesc> First character code covered </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>16</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname> numChars</otfieldname>
          <otfielddesc> Number of character codes covered
            </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>20</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname> glyphs []</otfieldname>
          <otfielddesc> Array of glyph indices for the character
              codes covered </otfielddesc>
        </otfield>
      </otformat>
      <para>This format is not supported by Microsoft.</para>
    </section>
    <!--____________________________________________________________________-->
    <section role="annotation">
      <title>Annotation</title>
      <para>For coherence with the other formats, the description of
        the format field should be "Format number is set to 10" and the
        description of the length field should be "This is the length
        in bytes of the subtable."</para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-7.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-7.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-7.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-7.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-7.xml"/>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Format 12: Segmented coverage</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>This is the Microsoft standard character to glyph index
          mapping table for fonts supporting the UCS-4 characters in
          the Unicode Surrogates Area (U+D800 - U+DFFF). It is a bit
          like format 4, in that it defines segments for sparse
          representation in 4-byte character space. Here's the
          subtable format:</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Subtable format; set to 12.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>reserved</otfieldname>
          <otfielddesc>Reserved; set to 0</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>Byte length of this subtable (including the
              header) </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>language</otfieldname>
          <otfielddesc>Please see <link linkend="language_note">Note
                on the language field in <ottable>cmap</ottable> subtables</link> in
              this document.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>12</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>nGroups</otfieldname>
          <otfielddesc>Number of groupings which follow
            </otfielddesc>
        </otfield>
      </otformat>
      <para>Fonts providing Unicode encoded UCS-4 character support
          for Windows 2000 and later, need to have a subtable with
          platform ID 3, platform specific encoding ID 1 in format 4;
          and in addition, need to have a subtable for platform ID 3,
          platform specific encoding ID 10 in format 12. Please note,
          that the content of format 12 subtable, needs to be a super
          set of the content in the format 4 subtable. The format 4
          subtable needs to be in the cmap table to enable backward
          compatibility needs.</para>
      <para>Here follow the individual groups, each of which has the
          following format:</para>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>startCharCode</otfieldname>
          <otfielddesc>First character code in this group
            </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>endCharCode</otfieldname>
          <otfielddesc>Last character code in this group
            </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>startGlyphID</otfieldname>
          <otfielddesc>Glyph index corresponding to the starting
              character code </otfielddesc>
        </otfield>
      </otformat>
      <para>Groups must be sorted by increasing startCharCode. A
          group's endCharCode must be less than the startCharCode of
          the following group, if any. The endCharCode is used, rather
          than a count, because comparisons for group matching are
          usually done on an existing character code, and having the
          endCharCode be there explicitly saves the necessity of an
          addition per group.</para>
    </section>
    <!--____________________________________________________________________-->
    <section role="annotation">
      <title>Annotation</title>
      <para>First paragraph, first sentence should be reworded: "...
          for fonts supporting Unicode supplemental characters."
          Similarly, second paragraph, first sentence should be
          reworded: "Fonts providing support for Unicode supplemental
          characters..."</para>
      <para>For coherence with the other formats, the description of
          the format field should be "Format number is set to 12" and
          the description of the length field should be "This is the
          length in bytes of the subtable."</para>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-8.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-8.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-8.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-8.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-8.xml"/>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Format 14: Unicode Variation Sequences</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>Subtable format 14 specifies the Unicode Variation
        Sequences (UVSes) supported by the font. A Variation Sequence,
        according to the Unicode Standard, comprises a base character
        followed by a variation selector; e.g. &lt;U+82A6,
        U+E0101&gt;.</para>
      <para>The subtable partitions the UVSes supported by the font
        into two categories: default and
        non-default UVSes. Given a UVS, if the glyph
        obtained by looking up the base character of that sequence in
        the Unicode cmap subtable (i.e. the UCS-4 or the BMP cmap
        subtable) is the glyph to use for that sequence, then the
        sequence is a default UVS; otherwise it is a
        non-defaultJ=f UVS, and the glyph to use for that
        sequence is specified in the format 14 subtable itself.</para>
      <para>The example below shows how a font vendor can use format
        14 for a JIS-2004-aware font.</para>
      <otformat>
        <title>Format 14 header</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>format</otfieldname>
          <otfielddesc>Subtable format; set to 14.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>length</otfieldname>
          <otfielddesc>Byte length of this subtable (including the
              header) </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>6</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>numVarSelectorRecords</otfieldname>
          <otfielddesc>Number of Variation Selector Records</otfielddesc>
        </otfield>
      </otformat>
      <para>This is immediately followed by 'numVarSelectorRecords'
        Variation Selector Records.</para>
      <otformat>
        <title>Variation Selector Record</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>UINT24</otfieldtype>
          <otfieldname>varSelector</otfieldname>
          <otfielddesc>Variation selector</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>3</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>defaultUVSOffset</otfieldname>
          <otfielddesc>Offset to Default UVS Table. May be 0. </otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>nonDefaultUVSOffset</otfieldname>
          <otfielddesc>Offset to Non-Default UVS Table. May be 0.</otfielddesc>
        </otfield>
      </otformat>
      <para>The Variation Selector Records are sorted in increasing
        order of 'varSelector'. No two records may have the same
        'varSelector'. All offsets in a record are relative to the
        beginning of the format 14 cmap subtable.</para>
      <para>A Variation Selector Record and the data its offsets
        point to specify those UVSes supported by the font for which
        the variation selector is the 'varSelector' value of the
        record. The base characters of the UVSes are stored in the
        tables pointed to by the offsets. The UVSes are partitioned by
        whether they are default or non-default UVSes.</para>
      <para>Glyph IDs to be used for non-default UVSes are specified
        in the Non-Default UVS table.</para>
      <para>Default UVS Table</para>
      <para>A Default UVS Table is simply a range-compressed list of
        Unicode scalar values, representing the base characters of the
        default UVSes which use the 'varSelector' of the associated
        Variation Selector Record.</para>
      <otformat>
        <title>Default UVS Table header</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>numUnicodeValueRanges</otfieldname>
          <otfielddesc>Number of ranges that follow</otfielddesc>
        </otfield>
      </otformat>
      <para>This is immediately followed by 'numUnicodeValueRanges'
        Unicode Value Ranges, each of which represents a contiguous
        range of Unicode values.</para>
      <otformat>
        <title>Unicode Value Range</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>UINT24</otfieldtype>
          <otfieldname>startUnicodeValue</otfieldname>
          <otfielddesc>First value in this range</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>3</otfieldoffs>
          <otfieldtype>BYTE</otfieldtype>
          <otfieldname>additionalCount</otfieldname>
          <otfielddesc>Number of <emphasis>additional</emphasis>
            values in this range</otfielddesc>
        </otfield>
      </otformat>
      <para>For example, the range U+4E4D...U+4E4F (3 values) will
        set 'startUnicodeValue' to 0x004E4D and 'additionalCount' to
        2. A singleton range will set 'additionalCount' to 0.</para>
      <para>('startUnicodeValue' + 'additionalCount') must not
        exceed 0xFFFFFF.</para>
      <para>The Unicode Value Ranges are sorted in increasing order
        of 'startUnicodeValue'. The ranges must not overlap; i.e.,
        ('startUnicodeValue' + 'additionalCount') must be less than
        the 'startUnicodeValue' of the following range (if
        any).</para>
      <para>Non-Default UVS Table</para>
      <para>A Non-Default UVS Table is a list of pairs of Unicode
        scalar values and glyph IDs. The Unicode values represent the
        base characters of all non-default UVSes which use the
        'varSelector' of the associated Variation Selector Record, and
        the glyph IDs specify the glyph IDs to use for the
        UVSes.</para>
      <otformat>
        <title>Non-Default UVS Table header</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>ULONG</otfieldtype>
          <otfieldname>numUVSMappings</otfieldname>
          <otfielddesc>Number of UVS Mappings that follow</otfielddesc>
        </otfield>
      </otformat>
      <para>This is immediately followed by 'numUVSMappings' UVS
        Mappings.</para>
      <otformat>
        <title>UVS Mapping</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>UINT24</otfieldtype>
          <otfieldname>unicodeValue</otfieldname>
          <otfielddesc>Base Unicode value of the UVS</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>3</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>glyphID</otfieldname>
          <otfielddesc>Glyph ID of the UVS</otfielddesc>
        </otfield>
      </otformat>
      <para>The UVS Mappings are sorted in increasing order of
        'unicodeValue'. No two mappings in this table may have the
        same 'unicodeValue' values.</para>
      <para>Example</para>
      <para>Here is an example of how a format 14 cmap subtable may
        be used in a font that is aware of JIS-2004 variant
        glyphs. The CIDs (character IDs) in this example refer to
        those in the Adobe Character Collection 'Adobe-Japan1', and
        may be assumed to be identical to the glyph IDs in the font in
        our example.</para>
      <para>JIS-2004 changed the default glyph variants for some of
        its code points. For example:</para>
      <para>JIS-90: U+82A6 -&gt; CID 1142</para>
      <para>JIS-2004: U+82A6 -&gt; CID 7961</para>
      <para>Both of these glyph variants are supported through the
        use of UVSes, as the following examples from Unicode's UVS
        registry show:</para>
      <para>U+82A6 U+E0100 -&gt; CID 1142</para>
      <para>U+82A6 U+E0101 -&gt; CID 7961</para>
      <para>If the font wants to support the JIS-2004 variants by
        default, it will:</para>
      <itemizedlist>
        <listitem>
          <para>encode glyph ID 7961 at U+82A6 in the Unicode cmap
            subtable,</para>
        </listitem>
        <listitem>
          <para>specify &lt;U+82A6, U+E0101&gt; in the UVS cmap
            subtable's Default UVS Table ('varSelector' will be
            0x0E0101 and 'defaultUVSOffset' will point to data
            containing a 0x0082A6 Unicode value)</para>
        </listitem>
        <listitem>
          <para>specify &lt;U+82A6, U+E0100&gt; -&gt; glyph ID 1142 in the
            UVS cmap subtable's Non-Default UVS Table ('varSelector'
            will be 0x0E0100 and 'nonDefaultBaseUVOffset' will point
            to data containing a 'unicodeValue' 0x82A6 and 'glyphID'
            1142). </para>
        </listitem>
      </itemizedlist>
      <para>If, however, the font wants to support the JIS-90
        variants by default, it will:</para>
      <itemizedlist>
        <listitem>
          <para>encode glyph ID 1142 at U+82A6 in the Unicode cmap
            subtable,</para>
          <para>specify &lt;U+82A6, U+E0100&gt; in the
            UVS cmap subtable's Default UVS Table</para>
        </listitem>
        <listitem>
          <para>specify &lt;U+82A6, U+E0101&gt; -&gt; glyph ID 7961 in the
            UVS cmap subtables Non-Default UVS Table </para>
        </listitem>
      </itemizedlist>
    </section>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="xml-representation-9.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="compiler-9.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="decompiler-9.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="implementation-9.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-9.xml"/>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Various test fonts</title>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="test-suite-10.xml"/>
  </section>
</section>
