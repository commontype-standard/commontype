<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section role="compiler">
      <title>Compiler</title>
      <code-fragment id="layouttable.methods">
  protected Block deviceTableFromXML (Element t, Element table,
                                      Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute ("name");
      if (name != null &amp;&amp; ! "".equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    int startSize = Integer.parseInt (t.getAttribute ("startSize"));
    int endSize = Integer.parseInt (t.getAttribute ("endSize"));
    int[] values = parseIntList (t.getAttribute ("values"));

    if (endSize &lt; startSize) {
      warning ("device/@endSize must be bigger than device/@startSize"); }

    if (values.length != (endSize - startSize + 1)) {
      warning ("device/@values must have one value for each ppem "
               + "between " + startSize + " and " + endSize
               + " (included)" ); }

    int minValue = 0;
    int maxValue = 0;
    for (int i = 0; i &lt; values.length; i++) {
      minValue = Math.min (minValue, values [i]);
      maxValue = Math.max (maxValue, values [i]); }

    int[] min =             {0,  -2,  -8, -128};
    int[] max =             {0,   1,   7,  127};
    int[] valuesPerUint =   {0,   8,   4,    2};
    int[] bitsPerValue =    {0,   2,   4,    8};
    int[] mask =            {0, 0x3, 0xF, 0xFF};

    int minFormat = -1;
    for (int i = 1; i &lt; min.length; i++) {
      if (min[i] &lt;= minValue &amp;&amp; maxValue &lt;= max[i]) {
        minFormat = i;
        break; }}
    if (minFormat == -1) {
      warning ("device/@value must be in the range [-128, +127];"
               + " values will be truncated");
      minFormat = 3; }

    int format;
    String f = t.getAttribute ("format");
    if (f != null &amp;&amp; ! "".equals (f)) {
      int desiredFormat = Integer.parseInt (f);
      if (desiredFormat &lt; minFormat) {
        warning ("device/@format is too small; will use " + minFormat);
        format = minFormat; }
      else {
        format = desiredFormat; }}
    else {
      format = minFormat; }

    int nbUints = (values.length + valuesPerUint [format] - 1)
                  / valuesPerUint [format];
    int nbValues = valuesPerUint [format] * nbUints;

    if (nbValues != values.length) {
      int[] temp = new int [nbValues];
      System.arraycopy (values, 0, temp, 0, values.length);
      for (int i = values.length; i &lt; nbValues; i++) {
        temp [i] = 0; }
      values = temp; }

    Block me = new Block (6 + 2*nbUints, 0);
    me.setuint16 (0, startSize);
    me.setuint16 (2, endSize);
    me.setuint16 (4, format);

    for (int i = 0; i &lt; nbValues; i += valuesPerUint [format]) {
      int v = 0;
      for (int j = 0; j &lt; valuesPerUint [format]; j++) {
        v = (v &lt;&lt; bitsPerValue [format])
            | (values [i + j] &amp; mask [format]); }
      me.setuint16 (6 + 2 *(i / valuesPerUint [format]), v); }

    blockCache.put (t, me);

    return me;
  }
</code-fragment>
    </section>
    
