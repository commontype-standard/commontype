<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section id="chapter.common_tables"  xmlns:web="http://aots.adobe.com/2001/web" xmlns:rng="http://relaxng.org/ns/structure/1.0" xmlns:ots="http://aots.adobe.com/2001/ots" xmlns:aots="http://aots.adobe.com/2001/aots">
    <title>CommonType Layout Common Table Formats</title>

    <!--======================================================================-->
    <section role="fragment">
      <title>Overview</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>CommonType Layout consists of five tables: the Glyph
          Substitution table (<ottable>GSUB</ottable>), the Glyph
          Positioning table (<ottable>GPOS</ottable>), the Baseline
          table (<ottable>BASE</ottable>), the Justification table
          (<ottable>JSTF</ottable>), and the Glyph Definition table
          (<ottable>GDEF</ottable>). These tables use some of the same
          data formats.</para>

        <para>This chapter explains the conventions used in all
          CommonType Layout tables, and it describes the common table
          formats. Separate chapters provide complete details about
          the <ottable>GSUB</ottable>, <ottable>GPOS</ottable>,
          <ottable>BASE</ottable>, <ottable>JSTF</ottable>, and
          <ottable>GDEF</ottable> tables.</para>

        <para>The CommonType Layout tables provide typographic
          information for properly positioning and substituting
          glyphs, operations that are required for accurate typography
          in many language environments. CommonType Layout data is
          organized by script, language system, typographic feature,
          and lookup.</para>

        <para>Scripts are defined at the top level. A script is a
          collection of glyphs used to represent one or more languages
          in written form (see Figure 2a). For instance, a single
          script-Latin-is used to write English, French, German, and
          many other languages. In contrast, three scripts-Hiragana,
          Katakana, and Kanji-are used to write Japanese. With
          CommonType Layout, multiple scripts may be supported by a
          single font.</para>

        <figure>
          <title>Figure 2a. Glyphs in the Latin, Kanji, and Arabic
          scripts</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../../fig2a.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>A language system may modify the functions or appearance
          of glyphs in a script to represent a particular
          language. For example, the eszet ligature is used in the
          German language system, but not in French or English (see
          Figure 2b). And the Arabic script contains different glyphs
          for writing the Farsi and Urdu languages. In CommonType
          Layout, language systems are defined within scripts.</para>

        <figure>
          <title>Figure 2b. Differences in the English, French, and
          German language systems</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../../fig2b.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>A language system defines features, which are
          typographic rules for using glyphs to represent a
          language. Sample features are a &quot;vert&quot; feature that
          substitutes vertical glyphs in Japanese, a &quot;liga&quot; feature
          for using ligatures in place of separate glyphs, and a
          &quot;mark&quot; feature that positions diacritical marks with respect
          to base glyphs in Arabic (see Figure 2c). In the absence of
          language-specific rules, default language system features
          apply to the entire script. For instance, a default language
          system feature for the Arabic script substitutes initial,
          medial, and final glyph forms based on a glyph's position in
          a word.</para>


        <figure>
          <title>Figure 2c. A ligature glyph feature substitutes the
          &lt;etc&gt; ligature for individual glyphs, and a mark
          feature positions diacritical marks above an Arabic ligature
          glyph.</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../../fig2c.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Features are implemented with lookup data that the
          text-processing client uses to substitute and position
          glyphs. Lookups describe the glyphs affected by an
          operation, the type of operation to be applied to these
          glyphs, and the resulting glyph output.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

	<para>The layout tables heavily use subtables, that is blocks
	of data that points one to the other. In general, the shape of
	this graph of blocks is mostly a tree, but it is possible for
	a subtable to be referenced from multiple subtables. A typical
	example is that of a coverage, which may be used in multiple
	lookup subtables.</para>

	<para>We are using a consistent approach to represent those
	subtables and the pointers between them. The rest of this
	section describes this approach, and illustrates it with (a
	simplified version of) coverage subtables.</para>

	<para>We have one definition with the same name as the
	table. This definition contains the attributes and elements
	that represent the content of the table. A typical example
	is:</para>

<literallayout>
  coverageTable =
    ... attributes and elements representing the content of a coverage table
</literallayout>

        <para>When a subtable is pointed from multiple places, we just
        describe it in its one element, which has the same name as the
        subtable. This element will typically be a direct child of the
        element representing the CommonType table. It has an
        <sgmltag>id</sgmltag> attribute, to allow the various places
        that point to the subtable to refer to it:</para>

<literallayout>
  standaloneCoverageTable =
    element coverageTable { attribute id { text}, coverageTable }
</literallayout>

        <para>Whenever a subtable points to another, the former
        contains an offset to the latter. If there is a single pointer
        to the latter, we just include its representation
        “in-line”; otherwise, we use the
        <sgmltag>name</sgmltag> attribute to refer to the standalone
        table. This is supported by a declaration of the style:</para>

<literallayout>
  coverageTableOffset = attribute name { text } | coverageTable
</literallayout>

	<para>In a subtable that references coverages, such as a
	MarkToMark subtable which contains two references to
	coverage subtables, we would then use something like:</para>

<literallayout>
  markToMarkTable =
    ...
    element mark1Coverage { coverageTableOfset }
    element mark2Coverage { coverageTableOfset }
    ...
</literallayout>

	<para>This allows the following font contents::</para>

<literallayout><![CDATA[
  <coverageTable id='c' format='2'>
    <range start='10' end='20'/>
    <range start='30' end='40'/>
  </coverageTable>

  <markToMarkTable id='m'>
    ...
    <mark1Coverage name='c'/>

    <mark2Coverage format='2'>
      <range start='50' end='60'/>
      <range start='70' end='80'/>
    </mark2Coverage>
    ...
  </markToMarkTable>
]]>
</literallayout>

        <para>Often, the content of a subtable can take one of a few
        formats. For those cases, we have a bunch of definitions
        combined as choices, with the attribute <sgmltag>format</sgmltag>
        used to distinguish them:</para>

<literallayout>
  coverageTable |=
    attribute format { &quot;1&quot; }
    ... attributes and elements for a format 1 coverage table

  coverageTable |=
    attribute format { &quot;2&quot; }
    ... attributes and elements for a format 2 coverage table
</literallayout>

	<para>furthermore, we often will create an &quot;abstract&quot;
	  representation, which captures the essence of the subtable,
	  but does not imply a choice of format. In that case, we use
	  have one more <sgmltag>define</sgmltag> and we use the value
	  <sgmltag>any</sgmltag> for the format.</para>

<literallayout>
  coverageTable |=
    attribute format { &quot;any&quot; }
    ... attributes and elements for a coverage in any format
</literallayout>

      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>The five layout tables do indeed share subtable formats,
          but only <ottable>GSUB</ottable> and <ottable>GPOS</ottable>
          have Script, Language and Lookups. Consequently, we have two
          base classes for these layout tables: LayoutTable for all of
          them, and LookupTable for <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable>.</para>

<code-fragment package="com.adobe.aots.CommonType" class="LayoutTable">
  <code-title>LayoutTable class</code-title>
package com.adobe.aots.CommonType;

import java.util.TreeSet;
import java.util.SortedSet;
import java.util.Iterator;
import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public abstract class LayoutTable extends Table {

  public LayoutTable (long tag, Font font) {
    super (tag, font);
  }

  <code-include linkend="layouttable.methods"/>
}
</code-fragment>

<code-fragment package="com.adobe.aots.CommonType" class="LookupTableListener">
  <code-title>LookupTableListener interface</code-title>
package com.adobe.aots.CommonType;

import java.net.URL;

public interface LookupTableListener {
  public void init (Font font, URL fontURL,
                    java.io.PrintStream out, boolean positioned)
      throws InvalidFontException;

  public void selectedLookups (int[] lookupIndices);

  public void applyingLookup (int lookupIndex, GlyphRun gr);
    public void applyingLookupAtPos (int lookupIndex, GlyphRun gr, int position);
      public void replace (int oldGlyphId, int newGlyphId);
      public void replace (int oldGlyphId, int[] newGlyphIds);
      public void replace (int[] oldGlyphId, int newGlyphId);
      public void adjust (ValueRecord vr, int format);
      public void move (int x, int y);
      public void applyingSubtable (int lookupIndex, GlyphRun gr,
                                    int position, String table, int stOffset);
      public void noSubtableApplied (int lookupIndex, GlyphRun gr, int position);
    public void applyingLookupAtPosDone (int lookupIndex, GlyphRun gr, int position);
  public void applyingLookupDone (int lookupIndex, GlyphRun gr);

  public void shutdown ();
}
</code-fragment>



<code-fragment package="com.adobe.aots.CommonType" class="TextLookupTableListener">
  <code-title>TextLookupTableListener class</code-title>
package com.adobe.aots.CommonType;

import java.net.URL;

public class TextLookupTableListener implements LookupTableListener {

  java.io.PrintStream out;

  TextLookupTableListener (int details) {
  }

  public void init (Font font, URL fontURL,
                    java.io.PrintStream out, boolean positioned) {
    this.out = out;
  }

  public void selectedLookups (int[] lookupIndices) {
    out.print (&quot;lookups selected: &quot;);
    for (int k = 0; k &lt; lookupIndices.length; k++) {
      out.print (&quot; &quot; + lookupIndices [k]); }
    out.println (&quot;&quot;);
  }

  public void applyingLookup (int lookupIndex, GlyphRun gr) {
    out.println (&quot;Applying lookup &quot; + lookupIndex);
  }

  String action = &quot;&quot;;
  public void applyingLookupAtPos (int lookupIndex, GlyphRun gr, int position) {
    out.println (&quot;Applying lookup &quot; + lookupIndex
                        + &quot; at &quot; + position + &quot; (gid=&quot; + gr.glyphAt (position) + &quot;)&quot;);
    action = &quot;&quot;;
  }

  public void replace (int oldGlyphId, int newGlyphId) {
    action = &quot;&quot; + oldGlyphId + &quot;-&gt;&quot; + newGlyphId;
  }

  public void replace (int oldGlyphId, int[] newGlyphIds) {
    action = &quot;&quot; + oldGlyphId + &quot;-&gt;&quot;;
    for (int i = 0; i &lt; newGlyphIds.length; i++) {
      action += &quot;&quot; + newGlyphIds[i] + &quot; &quot;; }
  }

  public void replace (int[] oldGlyphIds, int newGlyphId) {
    action = &quot;&quot;;
    for (int i = 0; i &lt; oldGlyphIds.length; i++) {
      action += &quot;&quot; + oldGlyphIds[i] + &quot; &quot;; }
    action += &quot;-&gt;&quot; + newGlyphId;
  }


  public void adjust (ValueRecord vr, int format) {
    action = &quot;&quot;;
    if ((format &amp; 0x001) != 0) {
      action += &quot;xp &quot; + vr.xPlacement + &quot; &quot;; }
    if ((format &amp; 0x002) != 0) {
      action += &quot;yp &quot; + vr.yPlacement + &quot; &quot;; }
    if ((format &amp; 0x004) != 0) {
      action += &quot;xa &quot; + vr.xAdvance + &quot; &quot;; }
    if ((format &amp; 0x008) != 0) {
      action += &quot;ya &quot; + vr.yAdvance + &quot; &quot;; }
  }

  public void move (int x, int y) {
    action = &quot;x &quot; + x + &quot;  y &quot; + y;
  }

  public void applyingSubtable (int lookupIndex, GlyphRun gr,
                                int position, String table, int stOffset) {
    out.println (&quot;Apply subtable at &quot; + table + &quot;.&quot; + stOffset
                 + &quot; (&quot; + action + &quot;)&quot;);
  }

  public void noSubtableApplied (int lookupIndex, GlyphRun gr,
                                 int position) {
  }

  public void applyingLookupAtPosDone (int lookupIndex, GlyphRun gr,
                                       int position) {
    out.println (&quot;Applying lookup at pos done&quot;);
  }

  public void applyingLookupDone (int lookupIndex, GlyphRun gr) {
    out.println (&quot;Applying lookup done&quot;);
  }

  public void shutdown () {
    out.close ();
  }
}
</code-fragment>

<code-fragment package="com.adobe.aots.CommonType" class="SVGLookupTableListener">
  <code-title>SVGLookupTableListener class</code-title>
package com.adobe.aots.CommonType;

import java.net.URL;

public class SVGLookupTableListener implements LookupTableListener {
  protected int y;
  protected Font font;
  protected boolean positioned;
  protected int details;
  protected java.io.PrintStream out;

  public SVGLookupTableListener (int details) {
    this.details = details;
  }

  protected int scale (int x) {
    return (x * 1000) / 18;
  }

  public void init (Font font, URL fontURL,
                    java.io.PrintStream out,
                    boolean positioned)
      throws InvalidFontException {
    init (font, fontURL, out, positioned, false);
  }
  public void init (Font font, URL fontURL,
                    java.io.PrintStream out, boolean positioned,
                    boolean useSystemFonts) {
    this.font = font;
    this.out = out;
    this.positioned = positioned;

    out.println (&quot;&lt;?xml version='1.0'?&gt;&quot;);
    out.println (&quot;&lt;!--_____________________________________________________________________________&quot;);
    out.println (&quot;&quot;);
    out.println (&quot;  Copyright 2000-2016 Adobe Systems Incorporated. All Rights Reserved.&quot;);
    out.println (&quot;&quot;);
    out.println (&quot;  Licensed under the Apache License, Version 2.0 (the 'License');&quot;);
    out.println (&quot;  you may not use these files except in compliance with the License.&quot;);
    out.println (&quot;  You may obtain a copy of the License at&quot;);
    out.println (&quot;&quot;);
    out.println (&quot;   http://www.apache.org/licenses/LICENSE-2.0&quot;);
    out.println (&quot;&quot;);
    out.println (&quot;  Unless required by applicable law or agreed to in writing, software&quot;);
    out.println (&quot;  distributed under the License is distributed on an 'AS IS' BASIS,&quot;);
    out.println (&quot;  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.&quot;);
    out.println (&quot;  See the License for the specific language governing permissions and&quot;);
    out.println (&quot;  limitations under the License.&quot;);
    out.println (&quot;  ____________________________________________________________________________--&gt;&quot;);
    out.println (&quot;&quot;);

    out.println (&quot;&lt;svg xml:space='preserve' &gt;&quot;);
    out.println (&quot;  &lt;style type='text/css'&gt;&quot;);

    if (useSystemFonts) {
      out.println (&quot;   .st1{font-family:'Courier';font-size:700}&quot;);
      out.println (&quot;   .st2{font-family:'ZapfDingbats';font-size:700}&quot;);
      out.println (&quot;   .st0{font-family:'&quot; + font.name.getName (0x409, 1) + &quot;'&quot;);
      String subFamily = font.name.getName (0x409, 2);
      if (&quot;Bold&quot;.equals (subFamily)) {
        out.println (&quot;;font-weight: bold&quot;); }
      else if (&quot;Italic&quot;.equals (subFamily)) {
        out.println (&quot;;font-style: italic&quot;); }
      else if (&quot;Bold Italic&quot;.equals (subFamily)) {
        out.println (&quot;;font-weight: bold&quot;);
        out.println (&quot;;font-style: italic&quot;); }
      out.println (&quot;;font-subfamily:'&quot; + subFamily + &quot;'&quot;);
      out.println (&quot;;font-size:1000}&quot;); }
    else {
      out.println (&quot;   .st0{font-family:'t';font-size:1000}&quot;);
      out.println (&quot;   .st1{font-family:'c';font-size:700}&quot;);
      out.println (&quot;   .st2{font-family:'z';font-size:700}&quot;);
      out.println (&quot;   @font-face{font-family:'c';src:url(c.cef)}&quot;);
      out.println (&quot;   @font-face{font-family:'z';src:url(z.cef)}&quot;);
      out.println (&quot;   @font-face{font-family:'t';src:url('&quot; + fontURL + &quot;')}&quot;); }

    out.println (&quot;  &lt;/style&gt;&quot;);
    out.println (&quot;  &lt;g class='st0'&gt;&quot;);

    out.println (&quot;&lt;g transform='scale(0.018)'&gt;&quot;);

    out.print (&quot;  &lt;text x='&quot; + scale(10) + &quot;' y='&quot; + scale(20) + &quot;' class='st1'&gt;&quot;);
    out.print (font.name.getName (0x409, 4));
    out.println (&quot;&lt;/text&gt;&quot;);

    out.print (&quot;  &lt;text x='&quot; + scale (10) + &quot;' y='&quot; + scale(35) + &quot;' class='st1'&gt;&quot;);
    out.print (font.name.getName (0x409, 5));
    out.println (&quot;&lt;/text&gt;&quot;);

    y = 50;

  }


  public void outputLine (String s) {
    out.print (&quot;&lt;text x='&quot; + scale(10 + 20*depth)
                      + &quot;' y='&quot; + scale(y+22) + &quot;' class='st0'&gt;&quot;
                      + s + &quot;&lt;/text&gt;&quot;);
    y += 22; }

  public void outputLine (String s1, String s2) {
    out.print (&quot;&lt;text x='&quot; + scale(10 + 20*depth)
                      + &quot;' y='&quot; + scale(y+22) + &quot;' class='st0'&gt;&quot;
                      + s1 + &quot;&lt;/text&gt;&quot;);
    out.print (&quot;&lt;text x='&quot; + scale(400) + &quot;' y='&quot; + scale(y+22) + &quot;' class='st0'&gt;&quot;
                      + s2 + &quot;&lt;/text&gt;&quot;);
    y += 22;
  }

  public void outputLine (String s1, String s2, String s3) {
    out.print (&quot;&lt;text x='&quot; + scale(10 + 20*depth)
                      + &quot;' y='&quot; + scale(y+22) + &quot;' class='st0'&gt;&quot;
                      + s1 + &quot;&lt;/text&gt;&quot;);
    out.print (&quot;&lt;text x='&quot; + scale(400) + &quot;' y='&quot; + scale(y+22) + &quot;' class='st0'&gt;&quot;
                      + s2 + &quot;&lt;/text&gt;&quot;);
    out.print (&quot;&lt;text x='&quot; + scale(600) + &quot;' y='&quot; + scale(y+22) + &quot;' class='st0'&gt;&quot;
                      + s3 + &quot;&lt;/text&gt;&quot;);
    y += 22;
  }


  public String annotation (String s) {
    return (&quot;&lt;tspan class='st1'&gt;&quot; + s + &quot;&lt;/tspan&gt;&quot;);
  }

  static final String arrow
       = &quot;&lt;tspan class='st2'&gt;&amp;#x2192;&lt;/tspan&gt;&quot;;

  static final String undef
       = &quot;&lt;tspan class='st1'&gt;&amp;#x7f;&lt;/tspan&gt;&quot;;

  public String glyphRun (GlyphRun gr) {
    String s = &quot;&quot;;
    if (positioned) {
      String xPos = &quot;&quot; + gr.getXPos (0);
      String yPos = &quot;&quot; + gr.getYPos (0);
      for (int i = 0; i &lt; gr.glyphCount (); i++) {
        s += &quot;&lt;altGlyph glyphRef='$$&quot; + gr.glyphAt (i) + &quot;'&gt;X&lt;/altGlyph&gt;&quot;;
        if (i &gt; 0) {
          xPos += &quot; &quot; + (gr.getXPos (i) - gr.getXPos (i-1)
                          - font.hmtx.getHorizontalAdvance (gr.glyphAt (i-1)));
          yPos += &quot; &quot; + (-(gr.getYPos (i) - gr.getYPos (i-1))); }}
      s = &quot;&lt;tspan dx='&quot; + xPos + &quot;' dy='&quot; + yPos + &quot;'&gt;&quot;
           + s + &quot;&lt;/tspan&gt;&quot;; }
    else {
      for (int i = 0; i &lt; gr.glyphCount (); i++) {
        s += &quot;&lt;altGlyph glyphRef='$$&quot; + gr.glyphAt (i) + &quot;'&gt;X&lt;/altGlyph&gt;&quot;; }}
    return s;
  }

  public String glyphRun (GlyphRun gr, int position) {
    String s = &quot;&quot;;
    for (int i = 0; i &lt; gr.glyphCount (); i++) {
      if (i == position) {
        s += annotation (&quot;*&quot;); }
      else {
        s += annotation (&quot; &quot;); }
      s += &quot;&lt;altGlyph glyphRef='$$&quot; + gr.glyphAt (i) + &quot;'&gt;X&lt;/altGlyph&gt;&quot;; }
    return s;
  }

  int depth = 0;



  public void selectedLookups (int[] lookupIndices) {
    String s = &quot;lookups selected:&quot;;
    for (int k = 0; k &lt; lookupIndices.length; k++) {
      s += &quot; &quot; + lookupIndices [k]; }
    outputLine (annotation (s));
  }


  String action = &quot;&quot;;
  protected void addAction (String s) {
    if (! action.equals (&quot;&quot;)) {
      action += &quot;; &quot;; }
    action += s;
  }


  public String intList (int[] ints) {
    if (ints.length == 0) {
      return &quot;&quot;; }

    String s = &quot;&quot; + ints [0];
    for (int i = 1; i &lt; ints.length; i++) {
      s += &quot;,&quot; + ints[i]; }
    return s;
  }

  public String stringList (String[] strings) {
    if (strings.length == 0) {
      return &quot;&quot;; }

    String s = &quot;&quot; + strings [0];
    for (int i = 1; i &lt; strings.length; i++) {
      s += &quot;,&quot; + strings[i]; }
    return s;
  }

  public void replace (int oldGlyphId, int newGlyphId) {
    addAction (&quot;&quot; + oldGlyphId + arrow + newGlyphId);
    if (font.cff != null) {
      addAction (font.cff.getGlyphName (oldGlyphId)
                  + &quot; &quot; + arrow + &quot; &quot;
                  + font.cff.getGlyphName (newGlyphId)); }
  }

  public void replace (int oldGlyphId, int[] newGlyphIds) {
    addAction (&quot;&quot; + oldGlyphId + arrow + intList (newGlyphIds));
    if (font.cff != null) {
      addAction (font.cff.getGlyphName (oldGlyphId)
                  + &quot; &quot; + arrow + &quot; &quot;
                  + stringList (font.cff.getGlyphName (newGlyphIds))); }
  }

  public void replace (int[] oldGlyphIds, int newGlyphId) {
    addAction (&quot;&quot; + intList (oldGlyphIds) + arrow + newGlyphId);
    if (font.cff != null) {
      addAction (stringList (font.cff.getGlyphName (oldGlyphIds))
                  + &quot; &quot; + arrow + &quot; &quot;
                  + font.cff.getGlyphName (newGlyphId)); }
  }

  public void adjust (ValueRecord vr, int format) {
    String s = &quot;&quot;;
    if ((format &amp; 0x001) != 0) {
      s += &quot;xp &quot; + vr.xPlacement + &quot; &quot;; }
    if ((format &amp; 0x002) != 0) {
      s += &quot;yp &quot; + vr.yPlacement + &quot; &quot;; }
    if ((format &amp; 0x004) != 0) {
      s += &quot;xa &quot; + vr.xAdvance + &quot; &quot;; }
    if ((format &amp; 0x008) != 0) {
      s += &quot;ya &quot; + vr.yAdvance + &quot; &quot;; }
    addAction (s);
  }

  public void move (int x, int y) {
    String s = &quot;x &quot; + x + &quot;  y &quot; + y;
    addAction (s);
  }

  public void applyingLookup (int lookupIndex, GlyphRun gr) {
    String l = Integer.toString (lookupIndex);
    while (l.length () &lt; 3) {
      l = &quot; &quot; + l; }
    outputLine (annotation (&quot;applying lookup &quot; + lookupIndex + &quot; on &quot;)
                 + glyphRun (gr));
  }

  public void applyingLookupAtPos (int lookupIndex, GlyphRun gr, int position) {
    depth++;
    action = &quot;&quot;;
  }

  public void applyingSubtable (int lookupIndex, GlyphRun gr,
                                int curGlyph, String table, int stOffset) {
    if (   (details &gt;= 1 &amp;&amp; depth == 1)
        || (details &gt;= 2)) {
      outputLine (glyphRun (gr, curGlyph),
                  annotation (&quot;using &quot; + table + &quot;.0x&quot;
                              + Integer.toHexString (stOffset)),
                  annotation (action)); }
  }

  public void noSubtableApplied (int lookupIndex, GlyphRun gr,
                                 int curGlyph) {
    if (details &gt;= 3) {
      outputLine (glyphRun (gr, curGlyph), &quot;&quot;, &quot;&quot;); }
  }

  public void applyingLookupAtPosDone (int lookupIndex, GlyphRun gr,
                                       int position) {
    depth--;
  }

  public void applyingLookupDone (int lookupIndex, GlyphRun gr) {
    if (details &gt;= 1) {
      depth++;
      outputLine (glyphRun (gr, -1), &quot;&quot;, &quot;&quot;);
      depth--; }

    outputLine (annotation (&quot;             result: &quot;) + glyphRun (gr));
  }

  public void shutdown () {
    out.println (&quot;  &lt;/g&gt;&quot;);
    out.println (&quot;  &lt;/g&gt;&quot;);
    out.println (&quot;&lt;/svg&gt;&quot;);
    out.close ();
  }
}
</code-fragment>

<code-fragment package="com.adobe.aots.CommonType" class="LookupTable">
  <code-title>LookupTable class</code-title>
package com.adobe.aots.CommonType;

import java.util.TreeSet;
import java.util.SortedSet;
import java.util.Iterator;
import java.util.Vector;
import java.util.HashSet;
import java.util.Map;
import java.util.HashMap;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public abstract class LookupTable extends LayoutTable {

  public LookupTable (long tag, Font font) {
    super (tag, font);
  }

  protected LookupTableListener listener = null;

  public void setLookupTableListener (LookupTableListener l) {
   listener = l;
  }

  public void removeLookupTableListener () {
    listener = null;
  }

  <code-include linkend="lookuptable.methods"/>

  abstract String lookupName (int lookupType);
  abstract int lookupType (String name);

  abstract void lookupSubtableToXMLCount (int offset, int[] counts,
                                          int lookupType);

  abstract void lookupSubtableOffsetToXML (DecompilerConfig conf, int offset,
                                           int[] counts,
                                           int lookupType)
     throws org.xml.sax.SAXException, InvalidFontException;

  abstract void lookupSubtableToXML (DecompilerConfig conf, int offset,
                                     int[] counts,
                                     int lookupType)
     throws org.xml.sax.SAXException, InvalidFontException;

  public void recordUse (int offset) {
  }
}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Table Organization</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Two CommonType Layout tables, <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable>, use the same data formats to
          describe the typographic functions of glyphs and the
          languages and scripts that they support: a ScriptList table,
          a FeatureList table, and a LookupList table. In
          <ottable>GSUB</ottable>, the tables define glyph
          substitution data. In <ottable>GPOS</ottable>, they define
          glyph positioning data. This chapter describes these common
          table formats.</para>

        <para>The ScriptList identifies the scripts in a font, each of
          which is represented by a Script table that contains script
          and language-system data. Language system tables reference
          features, which are defined in the FeatureList. Each feature
          table references the lookup data defined in the LookupList
          that describes how, when, and where to implement the
          feature</para>

        <figure>
          <title>Figure 2d. The relationship of scripts, language
          systems, features, and lookups for substitution and
          positioning tables</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="../../fig2d.gif"/>
            </imageobject>
          </mediaobject>
        </figure>

        <blockquote>
          <para>Note: The data in the <ottable>BASE</ottable> and
            <ottable>JSTF</ottable> tables also is organized by script
            and language system. However, the data formats differ from
            those in <ottable>GSUB</ottable> and
            <ottable>GPOS</ottable>, and they do not include a
            FeatureList or LookupList. The <ottable>BASE</ottable> and
            <ottable>JSTF</ottable> data formats are described in the
            <ottable>BASE</ottable> and <ottable>JSTF</ottable>
            chapters.</para>
        </blockquote>

        <para>The information used to substitute and position glyphs
          is defined in Lookup subtables. Each subtable supplies one
          type of information, depending upon whether the lookup is
          part of a <ottable>GSUB</ottable> or <ottable>GPOS</ottable>
          table. For instance, a <ottable>GSUB</ottable> lookup might
          specify the glyphs to be substituted and the context in
          which a substitution occurs, and a <ottable>GPOS</ottable>
          lookup might specify glyph position adjustments for kerning.
          CommonType Layout has seven types of <ottable>GSUB</ottable>
          lookups (described in the <ottable>GSUB</ottable> chapter)
          and nine types of <ottable>GPOS</ottable> lookups (described
          in the <ottable>GPOS</ottable> chapter).</para>

        <para>Each subtable (except for an Extension LookupType
          subtable) includes a Coverage table that lists the
          &quot;covered&quot; glyphs that will result in a glyph substitution or
          positioning operation. The Coverage table formats are
          described in this chapter.</para>

        <para>Some substitution or positioning operations may apply to
          groups, or classes, of glyphs. <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> Lookup subtables use the Class
          Definition table to assign glyphs to classes. This chapter
          includes a description of the Class Definition table
          formats.</para>

        <para>Lookup subtables also may contain device tables,
          described in this chapter, to adjust scaled contour glyph
          coordinates for particular output sizes and
          resolutions. This chapter also describes the data types used
          in CommonType Layout. Sample tables and lists that illustrate
          the common data formats are supplied at the end of this
          chapter.</para>

        <para>Scripts and Languages</para>

        <para>Three tables and their associated records apply to
          scripts and languages: the Script List table (ScriptList)
          and its script record (ScriptRecord), the Script table and
          its language system record (LangSysRecord), and the Language
          System table (LangSys).</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>A basic operation is to find the list of lookups
          corresponding to a 'featureTagsList' for a given
          'scriptTag'/'languageTag'. The strategy is to find the
          langSys table for the script/language, convert the set of
          feature tags into a set of feature indices, and finally to
          convert those to an ordered list of lookup indices.</para>

<code-fragment id="lookuptable.methods">
  <code-title>Find Lookups</code-title>
  public int[] findLookups (long scriptTag, long langSysTag,
                            long[] selectedFeatureTags) {

    int langSysOffset = -1;
    <code-include linkend="method_Table_findLookups2"/>
    if (langSysOffset == -1) {
      return new int[0]; }

    int[] selectedFeatureIndices = new int [selectedFeatureTags.length + 1];
    int   selectedFeatureIndicesCount = 0;
    int featureListOffset = getFeatureListOffset ();

    <code-include linkend="method_Table_findLookups4"/>

    SortedSet&lt;Integer&gt; selectedLookups = new TreeSet&lt;Integer&gt; ();
    <code-include linkend="method_Table_findLookups7"/>

    // turn the set of selectedLookups in an ordered list and return it
    int[] selectedL = new int [selectedLookups.size ()];
    int k = 0;
    for (Integer i : selectedLookups) {
      selectedL [k++] = i.intValue (); }

    return selectedL;
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Script List Table and Script Record</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>CommonType Layout fonts may contain one or more groups of
          glyphs used to render various scripts, which are enumerated
          in a ScriptList table. Both the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables define Script List tables
          (ScriptList):</para>

        <itemizedlist>
          <listitem>
            <para>The <ottable>GSUB</ottable> table uses the
              ScriptList table to access the glyph substitution
              features that apply to a script. For details, see the
              chapter, The Glyph Substitution Table
              (<ottable>GSUB</ottable>).</para>
          </listitem>

          <listitem>
            <para>The <ottable>GPOS</ottable> table uses the
              ScriptList table to access the glyph positioning
              features that apply to a script. For details, see the
              chapter, The Glyph Positioning Table
              (<ottable>GPOS</ottable>).</para>
          </listitem>
        </itemizedlist>

        <para>A ScriptList table consists of a count of the scripts
          represented by the glyphs in the font (ScriptCount) and an
          array of records (ScriptRecord), one for each script for
          which the font defines script-specific features (a script
          without script-specific features does not need a
          ScriptRecord).</para>

	<para>If a Script table with the script tag 'DFLT' (default)
	  is present in the ScriptList table, it must have a non-NULL
	  DefaultLangSys and LangSysCount must be equal to 0. The 'DFLT'
	  Script table should be used if there is not an explicit entry
	  for the script being formatted.</para>

        <para>The ScriptRecord array stores the records alphabetically
          by a ScriptTag that identifies the script. Each ScriptRecord
          consists of a ScriptTag and an offset to a Script
          table.</para>

        <para>Example 1 at the end of this chapter shows a ScriptList
          table and ScriptRecords for a Japanese font that uses three
          scripts.</para>

        <otformat>
          <title>ScriptList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ScriptCount</otfieldname>
            <otfielddesc>Number of ScriptRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>ScriptRecord [ScriptCount]</otfieldname>
            <otfielddesc>Array of ScriptRecords - listed
              alphabetically by ScriptTag</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>ScriptRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>ScriptTag</otfieldname>
            <otfielddesc>4-byte ScriptTag identifier</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Script</otfieldname>
            <otfielddesc>Offset to Script table-from beginning of
              ScriptList</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>scriptListTable</code-title>
  scriptListTable =
    element script {
      attribute tag { text },
      scriptTableOffset
    }*

  standaloneScriptListTable =
    element scriptListTable { attribute id { text }, scriptListTable }

  scriptListTableOffset = attribute name { text } | scriptListTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

        <para>To output the ScriptList table of a layout table, we
          need to find all the <sgmltag>scriptRecord</sgmltag>
          elements.</para>

<code-fragment id="table.methods">
  <code-title>Resolving XML ids</code-title>

  public Element resolveXMLid (Element table, String name) {
    NodeList l = table.getChildNodes ();
    for (int i = 0; i &lt; l.getLength (); i++) {
      Element e = (Element) l.item (i);
      String n = e.getAttribute (&quot;id&quot;);
      if (name.equals (n)) {
        return e; }}
    warning (&quot;Could not dereference '&quot; + name + &quot;'&quot;);
   return null;
  }
</code-fragment>

<code-fragment id="lookuptable.methods">
  <code-title>Output the ScriptList table of a layout table</code-title>

  public Block scriptListTableFromXML (Element t,
                                       Element table,
				       Map&lt;Element, Block&gt; blockCache,
                                       Map&lt;String, Integer&gt; featureIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        t = resolveXMLid (table, name); }}

    NodeList scripts = t.getChildNodes ();
    int scriptCount = scripts.getLength ();

    Block me = new Block (2 + 6 * scriptCount, scriptCount);
    me.setuint16 (0, scriptCount);

    for (int i = 0; i &lt; scriptCount; i++) {
      Element script = (Element) scripts.item (i);
      me.setTag (2 + 6 * i, script.getAttribute (&quot;tag&quot;));
      me.setOffset (2 + 6 * i + 4,
                    scriptTableFromXML (script, table, blockCache,
                                        featureIndices)); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

	<para>In order to generate a fairly readable representation,
	  we first check if the scriptTables are shared or not, to
	  generate a &quot;scriptRecord&quot; or a &quot;script&quot; element:</para>

<code-fragment id="lookuptable.methods">
  public void scriptListTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] &gt; 1) {
      return; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
       scriptTableToXMLCount (getOffset (offset, 2 + 6*i + 4),
                              counts); }
  }

  public void scriptListTableOffsetToXML (DecompilerConfig conf, int offset,
                                          int [] counts,
                                          String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;scriptListTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      scriptListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void scriptListTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;scriptListTable_&quot; + Integer.toHexString (offset));
      scriptListTableToXMLEmit (conf, offset, counts,
                                &quot;scriptListTable&quot;, at);
      counts [offset] = 0; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
      scriptTableToXML (conf,
                        getOffset (offset, 2 + 6*i + 4),
		        counts); }
  }

  protected void scriptListTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
					String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      for (int i = 0; i &lt; getuint16 (offset); i++) {
	at = new AttributesImpl ();
	at.addAttribute (&quot;&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;CDATA&quot;,
                         Tag.tag2string (getuint32 (offset + 2 + 6*i)));

        scriptTableOffsetToXML (conf, getOffset (offset, 2 + 6*i + 4),
                                counts, &quot;script&quot;, at); }

      conf.ch.endElement (element); }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>Since there is no a-priori reason that all tables that
          contain ScriptList tables put them at the same place (or put
          pointers to them at the same place), we need an abstract
          method to get the offset of the ScriptList table.</para>

<code-fragment id="lookuptable.methods">
  <code-title>Method to get the offset of ScriptList</code-title>
  abstract int getScriptListOffset ();
</code-fragment>

        <para>??</para>

<code-fragment id="method_Table_findLookups2">
  <code-title>Find LangSys table for 'scriptTag'/'langSysTag' in ScriptList table</code-title>
  { int scriptListOffset = getScriptListOffset ();
    int scriptCount = getuint16 (scriptListOffset);

    for (int scr = 0; scr &lt; scriptCount; scr++) {
      if (scriptTag == getuint32 (scriptListOffset + 2 + 6*scr)) {
        int scriptOffset
          = getOffset (scriptListOffset, 2 + 6*scr + 4);
        <code-include linkend="method_Table_findLookups3"/>
        break; }}}
</code-fragment>

<code-fragment id="lookuptable.methods">
  <code-title>Method to get the list of script/languages</code-title>
  public String[][] getScriptLangList () {
    int scriptListOffset = getScriptListOffset ();
    int scriptCount = getuint16 (scriptListOffset);

    String[][] result = new String [scriptCount][];

    for (int scr = 0; scr &lt; scriptCount; scr++) {
      long scriptTag = getuint32 (scriptListOffset + 2 + 6*scr);
      int scriptOffset
         = getOffset (scriptListOffset, 2 + 6*scr + 4);
      <code-include linkend="LookupTable_getScriptLangList_2"/> }

    return result;
  }
</code-fragment>

<code-fragment id="lookuptable.methods">
  <code-title>Method to get the names of features in a script/language</code-title>
  public String[] getFeatureNames (String script, String language) {
    int scriptListOffset = getScriptListOffset ();
    int scriptCount = getuint16 (scriptListOffset);

    long scriptTag = Tag.string2tag (script);
    long languageTag = Tag.string2tag (language);

    for (int scr = 0; scr &lt; scriptCount; scr++) {
      if (scriptTag == getuint32 (scriptListOffset + 2 + 6*scr)) {
        int scriptOffset
           = getOffset (scriptListOffset, 2 + 6*scr + 4);
        <code-include linkend="LookupTable_getFeatureNames_2"/> }}

    return null;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="validation">
        <title>Validation</title>

<code-fragment id="validate_ScriptList">
  <code-title>ScriptList validation</code-title>
  { if (! available (scriptListOffset, 2)) {
      return; }
    int scriptCount = getuint16 (scriptListOffset);

    if (! claim (&quot;script list&quot;, scriptListOffset, 2 + 6*scriptCount)) {
      return; }

    for (int scr = 0; scr &lt; scriptCount; scr++) {
      int scriptOffset
        = getOffset (scriptListOffset, 2 + 6*scr + 4);
      validateScript (scriptOffset); }
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Script Table and Language System Record</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>A Script table identifies each language system that
          defines how to use the glyphs in a script for a particular
          language. It also references a default language system that
          defines how to use the script's glyphs in the absence of
          language-specific knowledge.</para>

        <para>A Script table begins with an offset to the Default
          Language System table (DefaultLangSys), which defines the
          set of features that regulate the default behavior of the
          script. Next, Language System Count (LangSysCount) defines
          the number of language systems (excluding the
          DefaultLangSys) that use the script. In addition, an array
          of Language System Records (LangSysRecord) defines each
          language system (excluding the default) with an
          identification tag (LangSysTag) and an offset to a Language
          System table (LangSys). The LangSysRecord array stores the
          records alphabetically by LangSysTag.</para>

        <para>If no language-specific script behavior is defined, the
          LangSysCount is set to zero (0), and no LangSysRecords are
          allocated.</para>

        <otformat>
          <title>Script table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>DefaultLangSys</otfieldname>
            <otfielddesc>Offset to DefaultLangSys table-from beginning
              of Script table-may be NULL</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LangSysCount</otfieldname>
            <otfielddesc>Number of LangSysRecords for this
              script-excluding the DefaultLangSys</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>LangSysRecord [LangSysCount]</otfieldname>
            <otfielddesc>Array of LangSysRecords-listed alphabetically
              by LangSysTag</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>LangSysRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>LangSysTag</otfieldname>
            <otfielddesc>4-byte LangSysTag identifier</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LangSys</otfieldname>
            <otfielddesc>Offset to LangSys table-from beginning of
              Script table</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>scriptTable</code-title>
  scriptTable =
    element defaultLangSys { langSysTableOffset }?,
    element langSysRecord {
      attribute tag { text },
      langSysTableOffset
    }*

  standaloneScriptTable =
    element scriptTable { attribute id { text }, scriptTable }

  scriptTableOffset = attribute name { text } | scriptTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  <code-title>Output a Script table</code-title>

  private Block scriptTableFromXML (Element t, Element table,
                                    Map&lt;Element, Block&gt; blockCache,
				    Map&lt;String, Integer&gt; featureIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList langs = t.getChildNodes ();

    Element defaultLangSys = null;
    if (langs.getLength () &gt; 0
        &amp;&amp; &quot;defaultLangSys&quot;.equals (((Element) (langs.item (0))).getTagName ())) {
      defaultLangSys = (Element) langs.item (0);
      t.removeChild (defaultLangSys);
      langs = t.getChildNodes (); }

    int langSysCount = langs.getLength ();

    Block me = new Block (4 + 6 * langSysCount, langSysCount + 1);

    me.setOffset (0, defaultLangSys == null
                      ? null :
                        langSysTableFromXML (defaultLangSys, table,
                                             blockCache, featureIndices));
    me.setuint16 (2, langSysCount);
    for (int i = 0; i &lt; langSysCount; i++) {
      Element langSys = (Element) langs.item (i);
      me.setTag (4 + 6*i, langSys.getAttribute (&quot;tag&quot;));
      me.setOffset (4 + 6*i + 4,
                    langSysTableFromXML (langSys, table,
                                         blockCache, featureIndices)); }

    blockCache.put (t, me);
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  public void scriptTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] &gt; 1) {
      return; }

    if (getOffset (offset, 0) != 0) {
      langSysTableToXMLCount (getOffset (offset, 0), counts); }

    for (int i = 0; i &lt; getuint16 (offset + 2); i++) {
       langSysTableToXMLCount (getOffset (offset, 4 + 6*i + 4), counts); }
  }

  public void scriptTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;scriptTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      scriptTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void scriptTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;scriptTable_&quot; + Integer.toHexString (offset));
      scriptTableToXMLEmit (conf, offset, counts,
                                &quot;scriptTable&quot;, at);
      counts [offset] = 0; }

    if (getOffset (offset, 0) != 0) {
      langSysTableToXML (conf, getOffset (offset, 0), counts); }

    for (int i = 0; i &lt; getuint16 (offset+2); i++) {
      langSysTableToXML (conf,
                         getOffset (offset, 4 + 6*i + 4),
	 	         counts); }
  }

   void scriptTableToXMLEmit (DecompilerConfig conf, int offset,
                                    int[] counts,
				    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      if (getOffset (offset, 0) != 0) {
        at = new AttributesImpl ();
        langSysTableOffsetToXML (conf, getOffset (offset, 0),
                                 counts, &quot;defaultLangSys&quot;, at); }

      for (int i = 0; i &lt; getuint16 (offset + 2); i++) {
        at = new AttributesImpl ();
        at.addAttribute (&quot;&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;CDATA&quot;,
                         Tag.tag2string (getuint32 (offset + 4 + 6*i)));

        langSysTableOffsetToXML (conf, getOffset (offset, 4 + 6*i + 4),
                                 counts, &quot;langSysRecord&quot;, at); }

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>If we do not find the LangSys table specifically for the
          langugage, we revert to the default language table, if it
          exists.</para>

<code-fragment id="method_Table_findLookups3">
  <code-title>Find LangSys table for 'langSysTag' in Script table at 'scriptOffset'</code-title>
  { int langSysCount = getuint16 (scriptOffset + 2);
    for (int lang = 0; lang &lt; langSysCount; lang++) {
      if (langSysTag == getuint32 (scriptOffset + 4 + 6*lang)) {
        langSysOffset = getOffset (scriptOffset, 4 + 6*lang + 4);
        break; }}

    if (langSysOffset == -1) {
      int defaultLangSysOffset = getOffset (scriptOffset, 0);
      if (defaultLangSysOffset != 0) {
        langSysOffset = defaultLangSysOffset; }}}
</code-fragment>

<code-fragment id="LookupTable_getScriptLangList_2">
  <code-title>ddd</code-title>
  { int langSysCount = getuint16 (scriptOffset + 2);
    int defaultLangSysOffset = getOffset (scriptOffset);

    int n = langSysCount;
    if (defaultLangSysOffset != 0) {
      n++; }
    result [scr] = new String [n + 1];
    result [scr][0] = Tag.tag2string (scriptTag);

    for (int lang = 0; lang &lt; langSysCount; lang++) {
      long langSysTag = getuint32 (scriptOffset + 4 + 6*lang);
      result [scr] [lang+1] = Tag.tag2string (langSysTag); }

    if (defaultLangSysOffset != 0) {
      result [scr] [langSysCount + 1] = &quot;dflt&quot;; }}
</code-fragment>

<code-fragment id="LookupTable_getFeatureNames_2">
  <code-title>Return the names of features for 'scriptOffset', if any</code-title>
  { int langSysCount = getuint16 (scriptOffset + 2);
    int defaultLangSysOffset = getOffset (scriptOffset);

    for (int lang = 0; lang &lt; langSysCount; lang++) {
      if (languageTag == getuint32 (scriptOffset + 4 + 6*lang)) {
        int langSysOffset
          = scriptOffset + getOffset (scriptOffset + 4 + 6*lang + 4);
        return getFeatureNamesForLang (langSysOffset); }}

    if (defaultLangSysOffset != 0) {
      int langSysOffset = scriptOffset + defaultLangSysOffset;
      return getFeatureNamesForLang (langSysOffset); }}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Language System Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The Language System table (LangSys) identifies
          language-system features used to render the glyphs in a
          script. (The LookupOrder offset is reserved for future
          use.)</para>

        <para>Optionally, a LangSys table may define a Required
          Feature Index (ReqFeatureIndex) to specify one feature as
          required within the context of a particular language
          system. For example, in the Cyrillic script, the Serbian
          language system always renders certain glyphs differently
          than the Russian language system.</para>

        <para>Only one feature index value can be tagged as the
          ReqFeatureIndex. This is not a functional limitation,
          however, because the feature and lookup definitions in
          CommonType Layout are structured so that one feature table can
          reference many glyph substitution and positioning
          lookups. When no required features are defined, then the
          ReqFeatureIndex is set to 0xFFFF.</para>

        <para>All other features are optional. For each optional
          feature, a zero-based index value references a record
          (FeatureRecord) in the FeatureRecord array, which is stored
          in a Feature List table (FeatureList). The feature indices
          themselves (excluding the ReqFeatureIndex) are stored in
          arbitrary order in the FeatureIndex array. The FeatureCount
          specifies the total number of features listed in the
          FeatureIndex array.</para>

        <para>Features are specified in full in the FeatureList table,
          FeatureRecord, and Feature table, which are described later
          in this chapter. Example 2 at the end of this chapter shows
          a Script table, LangSysRecord, and LangSys table used for
          contextual positioning in the Arabic script.</para>

        <otformat>
          <title>LangSys table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>LookupOrder</otfieldname>
            <otfielddesc>= NULL (reserved for an offset to a
              reordering table)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ReqFeatureIndex</otfieldname>
            <otfielddesc>Index of a feature required for this language
              system- if no required features = 0xFFFF</otfielddesc>
          </otfield>
          <otfield>
           <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>FeatureCount</otfieldname>
            <otfielddesc>Number of FeatureIndex values for this
              language system-excludes the required
              feature</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>FeatureIndex [FeatureCount]</otfieldname>
            <otfielddesc>Array of indices into the FeatureList-in
              arbitrary order</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>langSysTable</code-title>
  langSysTable =
    element requiredFeature {
      attribute name { text }
    }?,
    element featureIndex {
      attribute name { text }
    }*

  standaloneLangSysTable =
    element langSysTable { attribute id { text }, langSysTable }

  langSysTableOffset = attribute name { text } | langSysTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  private Block langSysTableFromXML (Element t, Element table,
                                     Map&lt;Element, Block&gt; blockCache,
				     Map&lt;String, Integer&gt; featureIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList features = t.getChildNodes ();

    Element requiredFeature = null;
    if (features.getLength () &gt; 0
        &amp;&amp; &quot;requiredFeature&quot;.equals (((Element)features.item (0)).getTagName ())) {
      requiredFeature = (Element) features.item (0);
      t.removeChild (requiredFeature);
      features = t.getChildNodes (); }

    int featureCount = features.getLength ();

    Block me = new Block (6 + 2 * featureCount, 1);
    blockCache.put (t, me);

    me.setOffset (0, null);

    if (requiredFeature == null) {
      me.setuint16 (2, 0xffff); }
    else {
      String featureName = requiredFeature.getAttribute (&quot;name&quot;);
      Integer ii = featureIndices.get (featureName);
      if (ii == null) {
        warning (&quot;Cannot resolve '&quot; + featureName + &quot;'&quot;); }
      else {
        me.setuint16 (2, ii.intValue ()); }}
    me.setuint16 (4, featureCount);
    for (int i = 0; i &lt; featureCount; i++) {
      Element feature = (Element) features.item (i);
      String featureName = feature.getAttribute (&quot;name&quot;);
      Integer ii = featureIndices.get (featureName);
      if (ii == null) {
        warning (&quot;cannot resolve '&quot; + featureName + &quot;'&quot;); }
      else {
        me.setuint16 (6 + 2*i, ii.intValue ()); }}

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  public void langSysTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
  }

  public void langSysTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;langSysTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      langSysTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void langSysTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;langSysTable_&quot; + Integer.toHexString (offset));
      langSysTableToXMLEmit (conf, offset, counts,
                                &quot;langSysTable&quot;, at);
      counts [offset] = 0; }
  }

  public void langSysTableToXMLEmit (DecompilerConfig conf, int offset,
                                     int[] counts,
				     String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      if (getuint16 (offset + 2) != 0xffff) {
        at = new AttributesImpl ();
        at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                         &quot;feature_&quot; + getuint16 (offset+2)); }

      for (int i = 0; i &lt; getuint16 (offset + 4); i++) {
        at = new AttributesImpl ();
        at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                         &quot;feature_&quot; + getuint16 (offset + 6 + 2*i));
        conf.ch.element (&quot;featureIndex&quot;, at); }

      conf.ch.endElement (element); }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="method_Table_findLookups4">
  <code-title>Convert 'selectedFeatureTags' to
           'selectedFeatureIndices' using table at 'langSysOffset'</code-title>
  { int requiredFeature = getuint16 (langSysOffset + 2);
    if (requiredFeature != 0xffff) {
      selectedFeatureIndices [selectedFeatureIndicesCount++] = requiredFeature; }

    int featureCount = getuint16 (langSysOffset + 4);
    for (int f = 0; f &lt; featureCount; f++) {
      int featureIndex = getuint16 (langSysOffset + 6 + 2*f);
      <code-include linkend="method_Table_findLookups6"/> }}
</code-fragment>


<code-fragment id="lookuptable.methods">
  <code-title>aaa</code-title>
  private String[] getFeatureNamesForLang (int langSysOffset) {
    int featureCount = getuint16 (langSysOffset + 4);

    int featureListOffset = getFeatureListOffset ();

    String [] result = new String [featureCount];
    for (int f = 0; f &lt; featureCount; f++) {
      int featureIndex = getuint16 (langSysOffset + 6 + 2*f);
      <code-include linkend="LookupTable_getFeatureNamesForLang_2"/> }

    return result;
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Features and Lookups</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Features define the functionality of an CommonType Layout
          font and they are named to convey meaning to the
          text-processing client. Consider a feature named &quot;liga&quot; to
          create ligatures. Because of its name, the client knows what
          the feature does and can decide whether to apply it. For
          more information, see the <ulink url="http://www.microsoft.com/typography/otspec/TTOREG.htm">CommonType
            Layout Registered Features</ulink> chapter. Font
          developers can use these features, as well as create their
          own.</para>

        <para>After choosing which features to use, the client
          assembles all lookups from the selected features. Multiple
          lookups may be needed to define the data required for
          different substitution and positioning actions, as well as
          to control the sequencing and effects of those
          actions.</para>

        <para>To implement features, a client applies the lookups in
          the order the lookup definitions occur in the LookupList. As
          a result, within the <ottable>GSUB</ottable> or
          <ottable>GPOS</ottable> table, lookups from several
          different features may be interleaved during text
          processing. A lookup is finished when the client locates a
          target glyph or glyph context and performs a substitution
          (if specified) or a positioning (if specified).</para>

        <para>Note: The substitution (<ottable>GSUB</ottable>) lookups
          always occur before the positioning
          (<ottable>GPOS</ottable>) lookups. The lookup sequencing
          mechanism in TrueType relies on the font to determine the
          proper order of text-processing operations.</para>

        <para>Lookup data is defined in one or more subtables that
          contain information about specific glyphs and the operations
          to be performe on them. Each type of lookup has one or more
          corresponding subtable definitions. The choice of a subtable
          format depends upon two factors: the precise content of the
          information being applied to an operation, and the required
          storage efficiency. (For complete definitions of all lookup
          types and subtables, see the the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> chapters of this document.)</para>

        <para>CommonType Layout features define information that is
          specific to the layout of the glyphs in a font. They do not
          encode information that is constant within the conventions
          of a particular language or the typography of a particular
          script. Information that would be replicated across all
          fonts in a given language belongs in the text-processing
          application for that language, not in the fonts.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Feature List Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The headers of the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables contain offsets to Feature
          List tables (FeatureList) that enumerate all the features in
          a font. Features in a particular FeatureList are not limited
          to any single script. A FeatureList contains the entire list
          of either the <ottable>GSUB</ottable> or
          <ottable>GPOS</ottable> features that are used to render the
          glyphs in all the scripts in the font.</para>

        <para>The FeatureList table enumerates features in an array of
          records (FeatureRecord) and specifies the total number of
          features (FeatureCount). Every feature must have a
          FeatureRecord, which consists of a FeatureTag that
          identifies the feature and an offset to a Feature table
          (described next). The FeatureRecord array is arranged
          alphabetically by FeatureTag names.</para>

        <para>Note: The values stored in the FeatureIndex array of a
          LangSys table are used to locate records in the
          FeatureRecord array of a FeatureList table.</para>

        <otformat>
          <title>FeatureList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>FeatureCount</otfieldname>
            <otfielddesc>Number of FeatureRecords in this
              table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>FeatureRecord [FeatureCount]</otfieldname>
            <otfielddesc>Array of FeatureRecords-zero-based (first
              feature has FeatureIndex = 0)-listed alphabetically by
              FeatureTag</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>FeatureRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Tag</otfieldtype>
            <otfieldname>FeatureTag</otfieldname>
            <otfielddesc>4-byte feature identification
              tag</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Feature</otfieldname>
            <otfielddesc>Offset to Feature table-from beginning of
              FeatureList</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>featureListTable</code-title>
  featureListTable =
    element feature {
      attribute id { text },
      attribute tag { text },
      featureTableOffset
    }*

  standaloneFeatureListTable =
    element featureListTable { attribute id { text }, featureListTable }

  featureListTableOffset = attribute name { text } | featureListTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

        <para>FeatureRecords are referenced by indices. As we fill the
          FeatureList table, we also remember the index of a
          FeatureRecord by storing it in the
          <sgmltag>attribute</sgmltag> index. This method must be
          called before indices are needed.</para>

<code-fragment id="lookuptable.methods">
  public Block featureListTableFromXML (Element t, Element table,
                                        Map&lt;Element, Block&gt; blockCache,
					Map&lt;String, Integer&gt; lookupIndices,
                                        Map&lt;String, Integer&gt; featureIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        t = resolveXMLid (table, name); }}

    NodeList features = t.getChildNodes ();
    int featureCount = features.getLength ();

    Block me = new Block (2 + 6 * featureCount, featureCount);
    me.setuint16 (0, featureCount);

    for (int i= 0; i &lt; featureCount; i++) {
      Element feature = (Element) features.item (i);
      featureIndices.put (feature.getAttribute (&quot;id&quot;), i);
      me.setTag (2 + 6 * i, feature.getAttribute (&quot;tag&quot;));
      me.setOffset (2 + 6 * i + 4,
                    featureTableFromXML (feature, table, blockCache,
                                         lookupIndices)); }

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  public void featureListTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] &gt; 1) {
      return; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
       featureTableToXMLCount (getOffset (offset, 2 + 6*i + 4), counts); }
  }

  public void featureListTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;featureListTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      featureListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void featureListTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;featureListTable_&quot; + Integer.toHexString (offset));
      featureListTableToXMLEmit (conf, offset, counts,
                                &quot;featureListTable&quot;, at);
      counts [offset] = 0; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
      featureTableToXML (conf,
                         getOffset (offset, 2 + 6*i + 4),
	 	         counts); }
  }

  public void featureListTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
					String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      for (int i = 0; i &lt; getuint16 (offset); i++) {
        at = new AttributesImpl ();
        at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                         &quot;feature_&quot; + i);
        at.addAttribute (&quot;&quot;, &quot;tag&quot;, &quot;tag&quot;, &quot;CDATA&quot;,
                         Tag.tag2string (getuint32 (offset + 2 + 6*i)));

        featureTableOffsetToXML (conf, getOffset (offset, 2 + 6*i + 4),
                                 counts, &quot;feature&quot;, at); }
      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>


        <para>Since there is no a-priori reason that all tables that
          contain FeatureList tables put them at the same place (or
          put pointers to them at the same place), we need an abstract
          method to get the offset of the FeatureList table.</para>

<code-fragment id="lookuptable.methods">
  <code-title>Method to find the offset of FeatureList</code-title>
  abstract int getFeatureListOffset ();
</code-fragment>

        <para>??</para>

<code-fragment id="method_Table_findLookups6">
  <code-title>Include 'featureIndex' if its tag is in 'selectedFeatureTags'</code-title>
  { long featureTag = getuint32 (featureListOffset + 2 + 6*featureIndex);
    for (int i = 0; i &lt; selectedFeatureTags.length; i++) {
      if (selectedFeatureTags [i] == featureTag) {
        selectedFeatureIndices [selectedFeatureIndicesCount++] = featureIndex; }}}
</code-fragment>

<code-fragment id="LookupTable_getFeatureNamesForLang_2">
  <code-title>ddd</code-title>
  { long featureTag = getuint32 (featureListOffset + 2 + 6*featureIndex);
    result [f] = Tag.tag2string (featureTag); }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Feature Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>A Feature table defines a feature with one or more
          lookups. The client uses the lookups to substitute or
          position glyphs.</para>

        <para>Feature tables defined within the
          <ottable>GSUB</ottable> table contain references to glyph
          substitution lookups, and feature tables defined within the
          <ottable>GPOS</ottable> table contain references to glyph
          positioning lookups. If a text-processing operation requires
          both glyph substitution and positioning, then both the
          <ottable>GSUB</ottable> and <ottable>GPOS</ottable> tables
          must each define a Feature table, and the tables must use
          the same FeatureTags.</para>

        <para>A Feature table consists of an offset to a Feature
          Parameters (FeatureParams) table (if one has been defined
          for this feature - see note in the following paragraph), a
          count of the lookups listed for the feature (LookupCount),
          and an arbitrarily ordered array of indices into a
          LookupList (LookupListIndex). The LookupList indices are
          references into an array of offsets to Lookup tables.</para>

        <para>The format of the Feature Parameters table is specific
          to a particular feature, and must be specified in the
          feature's entry in the Feature Tags section of the CommonType
          Layout Tag Registry. The length of the Feature Parameters
          table must be implicitly or explicitly specified in the
          Feature Parameters table itself. The FeatureParams field in
          the Feature Table records the offset relative to the
          beginning of the Feature Table. If a Feature Parameters
          table is not needed, the FeatureParams field must be set to
          NULL.</para>

        <para>To identify the features in a <ottable>GSUB</ottable> or
          <ottable>GPOS</ottable> table, a text-processing client
          reads the FeatureTag of each FeatureRecord referenced in a
          given LangSys table. Then the client selects the features it
          wants to implement and uses the LookupList to retrieve the
          Lookup indices of the chosen features. Next, the client
          arranges the indices in the LookupList order. Finally, the
          client applies the lookup data to substitute or position
          glyphs.</para>

        <para>Example 3 at the end of this chapter shows the
          FeatureList and Feature tables used to substitute ligatures
          in two languages.</para>

        <otformat>
          <title>Feature table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>FeatureParams</otfieldname>
            <otfielddesc>= NULL (reserved for offset to
              FeatureParams)</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupCount</otfieldname>
            <otfielddesc>Number of LookupList indices for this
              feature</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupListIndex [LookupCount]</otfieldname>
            <otfielddesc>Array of LookupList indices for this feature
              -zero-based (first lookup is LookupListIndex =
              0)</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>The description of the FeatureParams field used to be in
          v1.25: &quot;Offset to Feature Parameters table (if one has been
          defined for the feature), relative to the beginning of the
          Feature Table; = NULL if not required&quot;. It is unclear why it
          has been changed and in fact the old version is better,
          since there are font with feature params.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>featureTable</code-title>
  featureTable =
    element lookupIndex {
      attribute name { text }
    }*

  standaloneFeatureTable =
    element featureTable { attribute id { text }, featureTable }

  featureTableOffset = attribute name { text } | featureTable
</code-fragment>

      </section>
      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  public Block featureParamsTableFromXML (Element t)
      throws InvalidFontException, UnsupportedFontException {

    Block me;
    return null;
  }

  public Block featureTableFromXML (Element t, Element table,
                                    Map&lt;Element, Block&gt; blockCache,
                                    Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
       t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList lookups = t.getChildNodes ();
    int lookupCount = lookups.getLength ();

    Block me = new Block (4 + 2 * lookupCount, 1);
    blockCache.put (t, me);

    me.setOffset (0, null);
    me.setuint16 (2, lookupCount);
    for (int i = 0; i &lt; lookupCount; i++) {
      Element lookup = (Element) lookups.item (i);
      String lookupName = lookup.getAttribute (&quot;name&quot;);
      Integer ii = lookupIndices.get (lookupName);
      if (ii == null) {
        warning (&quot;cannot resolve '&quot; + lookupName + &quot;'&quot;); }
      else {
        me.setuint16 (4 + 2 * i, ii.intValue ()); }}

    return me;
  }

/* feature params? */

</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  public void featureTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
  }

  public void featureTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                       String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;featureTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      featureTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void featureTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;featureTable_&quot; + Integer.toHexString (offset));
      featureTableToXMLEmit (conf, offset, counts,
                                &quot;featureTable&quot;, at);
      counts [offset] = 0; }
  }

  public void featureTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
					String element, AttributesImpl at)
      throws org.xml.sax.SAXException {

    conf.ch.startElement (element, at); {

      for (int i = 0; i &lt; getuint16 (offset + 2); i++) {
        at = new AttributesImpl ();
        at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;lookup_&quot; + getuint16 (offset + 4 + 2*i));
        conf.ch.element (&quot;lookupIndex&quot;, at); }

      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="method_Table_findLookups7">
  <code-title>Add the lookups of 'selectedFeatureIndices' to 'selectedLookups'</code-title>
  { for (int f = 0; f &lt; selectedFeatureIndicesCount; f++) {
      int featureOffset
         = featureListOffset
           + getuint16 (featureListOffset + 2 + selectedFeatureIndices[f]*6 + 4);
      int lookupCount = getuint16 (featureOffset + 2);
      for (int l = 0; l &lt; lookupCount; l++) {
        selectedLookups.add (getuint16 (featureOffset + 4 + l*2)); }}}
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Lookup List Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The headers of the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables contain offsets to Lookup
          List tables (LookupList) for glyph substitution
          (<ottable>GSUB</ottable> table) and glyph positioning
          (<ottable>GPOS</ottable> table). The LookupList table
          contains an array of offsets to Lookup tables (Lookup). The
          font developer defines the Lookup sequence in the Lookup
          array to control the order in which a text-processing client
          applies lookup data to glyph substitution and positioning
          operations. LookupCount specifies the total number of Lookup
          table offsets in the array.</para>

        <para>Example 4 at the end of this chapter shows three
          ligature lookups in the LookupList table.</para>

        <otformat>
          <title>LookupList table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupCount</otfieldname>
            <otfielddesc>Number of lookups in this table</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>Lookup [LookupCount]</otfieldname>
            <otfielddesc>Array of offsets to Lookup tables-from
              beginning of LookupList -zero based (first lookup is
              Lookup index = 0)</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>lookupListTable</code-title>
  GSUBlookup =
    element lookup {
      attribute id { text },
      GSUBlookupTableOffset
    }

  GSUBlookupListTable =
    GSUBlookup*

  standaloneGSUBLookupListTable =
    element lookupListTable { attribute id { text }, GSUBlookupListTable }

  GSUBlookupListTableOffset =  attribute name { text } | GSUBlookupListTable


  GPOSlookup =
    element lookup {
      attribute id { text },
      GPOSlookupTableOffset
    }

  GPOSlookupListTable =
    GPOSlookup*

  standaloneGPOSLookupListTable =
    element lookupListTable { attribute id { text }, GPOSlookupListTable }

  GPOSlookupListTableOffset =  attribute name { text } | GPOSlookupListTable

  lookup = GSUBlookup | GPOSlookup
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

        <para>Lookups are referenced by indices. As we fill the
          FeatureList table, we also remember the index of a
          Lookup by storing it in the
          <sgmltag>attribute</sgmltag> index. This method must be
          called before indices are needed.</para>

<code-fragment id="lookuptable.methods">
  public Block lookupListTableFromXML (Element t, Element table,
                                       Map&lt;Element, Block&gt; blockCache,
				       Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        t = resolveXMLid (table, name); }}

    NodeList lookups = t.getChildNodes ();
    int lookupCount = lookups.getLength ();

    for (int i = 0; i &lt; lookupCount; i++) {
      Element lookup = (Element) lookups.item (i);
      lookupIndices.put (lookup.getAttribute (&quot;id&quot;), i); }

    Block me = new Block (2 + 2 * lookupCount, lookupCount);
    me.setuint16 (0, lookupCount);
    for (int i = 0; i &lt; lookupCount; i++) {
      Element lookup = (Element) lookups.item (i);
      me.setOffset (2 + 2*i,
                    lookupTableFromXML (lookup, table, blockCache,
                                        lookupIndices)); }

    return me;
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  public void lookupListTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] &gt; 1) {
      return; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
       lookupTableToXMLCount (getOffset (offset, 2 + 2*i), counts); }
  }

  public void lookupListTableOffsetToXML (DecompilerConfig conf, int offset,
                                          int [] counts,
                                          String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;lookupListTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      lookupListTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void lookupListTableToXML (DecompilerConfig conf, int offset,
                                    int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;lookupTable_&quot; + Integer.toHexString (offset));
      lookupListTableToXMLEmit (conf, offset, counts,
                                &quot;lookupListTable&quot;, at);
      counts [offset] = 0; }

    for (int i = 0; i &lt; getuint16 (offset); i++) {
      lookupTableToXML (conf,
                        getOffset (offset, 2 + 2*i),
	 	        counts); }
  }

  public void lookupListTableToXMLEmit (DecompilerConfig conf, int offset,
                                        int[] counts,
				        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    conf.ch.startElement (element, at); {

      for (int i = 0; i &lt; getuint16 (offset); i++) {
        at = new AttributesImpl ();
        at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;, &quot;lookup_&quot; + i);

        lookupTableOffsetToXML (conf, getOffset (offset, 2 + 2*i),
                                counts, &quot;lookup&quot;, at); }
      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>Since there is no a-priori reason that all tables that
          contain LookupList tables put them at the same place (or put
          pointers to them at the same place), we need an abstract
          method to get the offset of the LookupList table.</para>

<code-fragment id="lookuptable.methods">
  <code-title>Method to get the offset of LookupList</code-title>
  abstract int getLookupListOffset ();
</code-fragment>

        <para>We can then find the offset of a Lookup.</para>

<code-fragment id="lookuptable.methods">
  <code-title>Method to get the offset of a Lookup</code-title>
  int getLookupOffset (int lookupIndex) {
    int lookupListOffset = getLookupListOffset ();
    return lookupListOffset + getOffset (lookupListOffset + 2 + 2*lookupIndex);
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Lookup Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>A Lookup table (Lookup) defines the specific conditions,
          type, and results of a substitution or positioning action
          that is used to implement a feature. For example, a
          substitution operation requires a list of target glyph
          indices to be replaced, a list of replacement glyph indices,
          and a description of the type of substitution action.</para>

        <para>Each Lookup table may contain only one type of
          information (LookupType), determined by whether the lookup
          is part of a <ottable>GSUB</ottable> or
          <ottable>GPOS</ottable> table. <ottable>GSUB</ottable>
          supports five LookupTypes, and <ottable>GPOS</ottable>
          supports seven LookupTypes (for details about LookupTypes,
          see the <ottable>GSUB</ottable> and <ottable>GPOS</ottable>
          chapters of the document).</para>

        <para>Each LookupType is defined with one or more subtables,
          and each subtable definition provides a different
          representation format. The format is determined by the
          content of the information required for an operation and by
          required storage efficiency. When glyph information is best
          presented in more than one format, a single lookup may
          contain more than one subtable, as long as all the subtables
          are the same LookupType. For example, within a given lookup,
          a glyph index array format may best represent one set of
          target glyphs, whereas a glyph index range format may be
          better for another set of target glyphs.</para>

        <para>During text processing, a client applies a lookup to
          each glyph in the string before moving to the next lookup. A
          lookup is finished for a glyph after the client makes the
          substitution/positioning operation. To move to the &quot;next&quot;
          glyph, the client will typically skip all the glyphs that
          participated in the lookup operation: glyphs that were
          substituted/positioned as well as any other glyphs that
          formed a context for the operation. However, in the case of
          pair positioning operations (i.e., kerning), the &quot;next&quot;
          glyph in a sequence may be the second glyph of the
          positioned pair (see pair positioning lookup for
          details).</para>

        <para>A Lookup table contains a LookupType, specified as an
          integer, that defines the type of information stored in the
          lookup. The LookupFlag specifies lookup qualifiers that
          assist a text-processing client in substituting or
          positioning glyphs. The SubTableCount specifies the total
          number of SubTables. The SubTable array specifies offsets,
          measured from the beginning of the Lookup table, to each
          SubTable enumerated in the SubTable array.</para>

        <otformat>
          <title>Lookup table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupType</otfieldname>
            <otfielddesc>Different enumerations for
              <ottable>GSUB</ottable> and
              <ottable>GPOS</ottable></otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>LookupFlag</otfieldname>
            <otfielddesc>Lookup qualifiers</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>SubTableCount</otfieldname>
            <otfielddesc>Number of SubTables for this
              lookup</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>Offset</otfieldtype>
            <otfieldname>SubTable [SubTableCount]</otfieldname>
            <otfielddesc>Array of offsets to SubTables-from beginning
              of Lookup table</otfielddesc>
          </otfield>
        </otformat>

        <para>The LookupFlag uses four bits and one byte:

          <itemizedlist>
            <listitem>
              <para>Each of the first four bits can be set in order to
                specify additional instructions for applying a lookup
                to a glyph string. The LookUpFlag bit enumeration
                table provides details about the use of these bits.
              </para>
            </listitem>
            <listitem>
              <para>The high byte is set to specify the type of mark
                attachment.</para>
            </listitem>
          </itemizedlist>
        </para>

        <table>
          <title>LookupFlag bit enumeration</title>

          <tgroup cols="3">
            <colspec colwidth="6pc"/>
            <colspec colwidth="10pc"/>
            <colspec colwidth="14pc"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>0x0001</entry>
                <entry>RightToLeft</entry>
                <entry>
                  <para>This bit relates only to the correct
                    processing of the cursive attachment lookup type
                    (GPOS lookup type 3). When this bit is set, the
                    last glyph in a given sequence to which the
                    cursive attachment lookup is applied, will be
                    positioned on the baseline.</para>
                  <para><emphasis>Note: Setting of this bit is not
                      intended to be used by operating systems or
                      applications to determine text
                      direction.</emphasis></para>
                </entry>
              </row>
              <row>
                <entry>0x0002</entry>
                <entry>IgnoreBaseGlyphs</entry>
                <entry>If set, skips over base glyphs</entry>
              </row>
              <row>
                <entry>0x0004</entry>
                <entry>IgnoreLigatures</entry>
                <entry>If set, skips over ligatures</entry>
              </row>
              <row>
                <entry>0x0008</entry>
                <entry>IgnoreMarks</entry>
                <entry>If set, skips over combining marks</entry>
              </row>
              <row>
                <entry>0x00F0</entry>
                <entry>Reserved</entry>
                <entry>For future use</entry>
              </row>
              <row>
                <entry>0xFF00</entry>
                <entry>MarkAttachmentType</entry>
                <entry>If not zero, skips over all marks of attachment
                  type different from specified.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>


        <para>For example, in Arabic text, a character string might
          have the pattern &lt;base character - mark character - base
          character&gt;. That string could be converted into a ligature
          composed of two components, one for each base character,
          with the combining mark glyph over the first component. To
          produce this ligature, the font developer would set the
          IgnoreMarks bit to tell the client to ignore the mark,
          substitute the ligature glyph first, and then position the
          mark glyph over the ligature. Alternatively, a lookup which
          did not set the IgnoreMarks bit could be used to describe a
          three-component ligature glyph, composed of the first base
          glyph, the mark glyph, and the second base glyph. Here's
          another example: A lookup which creates a ligature of a base
          glyph with a top mark may skip over all bottom marks by
          specifying the mark attachment type as top marks. You can
          define attachment types of marks in the MarkAttachClassDef
          subtable in the <ottable>GDEF</ottable> table.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

	<para>Second paragraph, should read: &quot;... GSUB supports seven
	LookupTypes and GPOS supports nine LookupTypes...&quot;</para>

	<para>In general, each lookup subtable can be described by:
	  <itemizedlist>
	    <listitem>
	      <para>a pattern that the glyph string must match (at the
	      current position)</para>
	    </listitem>
	    <listitem>
	      <para>transformations that must performed
	      on the glyph string, if the pattern is matched.</para>
	    </listitem>
	  </itemizedlist></para>

	<para>It is useful to describe each lookup subtable in those
	terms, and to do so using a somewhat formalized notation. This
	goes a long way toward resolving the inherent ambiguity of the
	English language.</para>

	<para>To describe patterns, we will use the usual regular
	expression notation: ‘*’ for 0 or more
	occurrences, ‘+’ for 1 or more occurrences. Each
	pattern consists of three parts, in that order: the backtrack
	part, the input part and the lookahead part. We indicate those
	parts by bracketing the input part with
	‘▶’ and ‘◀’.  The
	basic alphabet on which those regular expressions are built
	are sets of glyph IDs. The set L is the set of LookupFlag
	glyphs, that is the set of glyphs which need to be skipped
	according to LookupFlag. The other sets in the basic alphabet
	are introduced in the description of each lookup subtable
	format; all such sets are to be understood as excluding the
	glyphs in the set L. If a set is empty, then the pattern does
	not match any string.</para>

	<para>For example, the pattern matched by a Ligature table in
	a Ligature Substitution in format 1 is:</para>

	<blockquote>
	  <para>▶ L<subscript>0</subscript> L*
	  L<subscript>1</subscript> L* … L*
	  L<subscript>ComponentCount-1</subscript> ◀</para>
	</blockquote>

	<para>where L<subscript>0</subscript> = {glyph ID to which
	this Ligature table corresponds} - L, and
	L<subscript>i</subscript> = {Component [i-1]} - L for i &gt;
	0.</para>

	<para>The pattern matched by a Ligature Substitution is the
	union of the patterns matched by its subtables.</para>

	<para>Last sentence: “You <emphasis>can</emphasis>
	define...” seems a bit weak, since there does not seem
	to be any other place where this data can be found. In other
	words: “The attachment type of the glyphs are found in
	the GDEF table.”</para>

	<para>MarkAttachementType: A common use of this mechanism is
	when ligating a base character and a mark. The problem to
	solve handle is that there could be an intervening,
	non-interacting mark, as in the sequence &lt;base, mark_below,
	mark_above&gt;. (The canonical ordering of the combining classes
	in Unicode is irrelevant – just reverse the mark above
	and the mark below). We want to ligate the base and the mark
	above, so we have to skip the mark below. We cannot set
	ignoreMarks in lookupFlag, as to would force the mark above to
	be ignored as well! However, we cannot ignore base glyphs
	either; consider &lt;base, other_base, mark_above&gt;, in which
	case we do not want to ligate. So the seemingly trivial
	“skip over all <emphasis>marks</emphasis> of attachment
	type different from specified” is actually quite
	strong: only the <emphasis>marks</emphasis> of the appropriate
	attachment type have to be skipped. This means that the test
	to determine if a glyph should be skipped cannot look just at
	the mark attachment class definition, it must also look at the
	glyph class definition.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>Lookup type</code-title>
  lookupTableCommonAttributes =
    attribute rightToLeft         { yesOrNo }?,
    attribute ignoreBaseGlyphs    { yesOrNo }?,
    attribute ignoreLigatures     { yesOrNo }?,
    attribute ignoreMarks         { yesOrNo }?,
    attribute markAttachmentType  { text }?


  standaloneGSUBLookupTable =
    element lookupTable { attribute id { text }, GSUBlookupTable }

  GSUBlookupTableOffset = attribute name { text } | GSUBlookupTable


  standaloneGPOSLookupTable =
    element lookupTable { attribute id { text }, GPOSlookupTable }

  GPOSlookupTableOffset = attribute name { text } | GPOSlookupTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="lookuptable.methods">
  private Block lookupTableFromXML (Element t, Element table,
                                    Map&lt;Element, Block&gt; blockCache,
				    Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    NodeList subtables = t.getChildNodes ();

    int subtableCount = subtables.getLength ();
    int type = lookupType (t.getAttribute (&quot;type&quot;));
    if (type == 0) {
      type = Integer.parseInt (t.getAttribute (&quot;type&quot;)); }
    int lookupFlag = 0;
    if (&quot;yes&quot;.equals (t.getAttribute (&quot;rightToleft&quot;))) {
      lookupFlag |= 0x0001; }
    if (&quot;yes&quot;.equals (t.getAttribute (&quot;ignoreBaseGlyphs&quot;))) {
      lookupFlag |= 0x0002; }
    if (&quot;yes&quot;.equals (t.getAttribute (&quot;ignoreLigatures&quot;))) {
      lookupFlag |= 0x0004; }
    if (&quot;yes&quot;.equals (t.getAttribute (&quot;ignoreMarks&quot;))) {
      lookupFlag |= 0x0008; }
    String markAttachmentType = t.getAttribute (&quot;markAttachmentType&quot;);
    if (   markAttachmentType != null
        &amp;&amp; ! &quot;&quot;.equals (markAttachmentType)) {
      lookupFlag |= (Integer.parseInt (markAttachmentType) &amp; 0xff) &lt;&lt; 8; }

    Block me = new Block (6 + 2*subtableCount, subtableCount);
    blockCache.put (t, me);

    me.setuint16 (0, type);
    me.setuint16 (2, lookupFlag);
    me.setuint16 (4, subtableCount);
    for (int i = 0; i &lt; subtableCount; i++) {
      Element subtable =  (Element) subtables.item (i);
      Block block = lookupSubtableFromXML (subtable, table,
                                           blockCache, type,
					   lookupIndices);
      if (block == null) {
        String subtableName = subtable.getTagName ();
        warning (&quot;unrecognized lookup subtable &quot; + subtableName); }
      me.setOffset (6 + 2*i, block); }

    return me;
  }

  private Block lookupSubtableFromXML (Element lookupSubtable,
                                       Element table,
                                       Map&lt;Element, Block&gt; blockCache,
                                       int lookupType,
				       Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    { String name = lookupSubtable.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        lookupSubtable = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (lookupSubtable);
      if (cached != null) {
        return cached; }}

    Block me = lookupSubtableBodyFromXML (lookupSubtable, table, blockCache,
                                          lookupType, lookupIndices);

    blockCache.put (lookupSubtable, me);
    return me;
  }

  abstract Block lookupSubtableBodyFromXML (Element lookupSubtable,
                                           Element table,
                                           Map&lt;Element, Block&gt; blockCache,
                                           int lookupType,
		    		           Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException;
</code-fragment>

<code-fragment id="gpos.methods">
  Block lookupSubtableBodyFromXML (Element lookupSubtable,
                                           Element table,
                                           Map&lt;Element, Block&gt; blockCache,
                                           int lookupType,
					   Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

    switch (lookupType) {
      case 1: { return singlePosLookupFromXML (lookupSubtable, table,
                                               blockCache); }
      case 2: { return pairPosLookupFromXML (lookupSubtable, table,
                                             blockCache); }
      case 3: { return cursivePosFormat1FromXML (lookupSubtable, table,
                                                 blockCache); }
      case 4: { return markBasePosFormat1FromXML (lookupSubtable, table,
                                                  blockCache); }
      case 5: { return markLigPosFormat1FromXML (lookupSubtable, table,
                                                 blockCache); }
      case 6: { return markMarkPosFormat1FromXML (lookupSubtable, table,
                                                  blockCache); }
      case 7: { return contextLookupFromXML (lookupSubtable, table,
                                              blockCache, lookupIndices); }
      case 8: { return chainingLookupFromXML (lookupSubtable, table,
                                              blockCache, lookupIndices); }
      case 9: { return extensionFormat1FromXML (lookupSubtable, table,
                                                blockCache, lookupIndices); }}

     /* cannot get there with valid document */
     throw new InvalidFontException
                  (&quot;invalid lookupType (&quot; + lookupType + &quot;)&quot;);
  }
</code-fragment>

<code-fragment id="gsub.methods">
  Block lookupSubtableBodyFromXML (Element lookupSubtable,
                                           Element table,
                                           Map&lt;Element, Block&gt; blockCache,
                                           int lookupType,
					   Map&lt;String, Integer&gt; lookupIndices)
      throws InvalidFontException, UnsupportedFontException {

     switch (lookupType) {
       case 1: { return singleSubstLookupFromXML (lookupSubtable, table,
                                                   blockCache); }
       case 2: { return multipleSubstFormat1FromXML (lookupSubtable, table,
                                                     blockCache); }
       case 3: { return alternateSubstFormat1FromXML (lookupSubtable, table,
                                                      blockCache); }
       case 4: { return ligatureSubstFormat1FromXML (lookupSubtable, table,
                                                     blockCache); }
       case 5: { return contextLookupFromXML (lookupSubtable, table,
                                               blockCache, lookupIndices); }
       case 6: { return chainingLookupFromXML (lookupSubtable, table,
                                               blockCache, lookupIndices); }
       case 7: { return extensionFormat1FromXML (lookupSubtable, table,
                                                 blockCache, lookupIndices); }}

     /* cannot get there with valid document */
     throw new InvalidFontException
                  (&quot;invalid lookupType (&quot; + lookupType + &quot;)&quot;);
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="lookuptable.methods">
  public void lookupTableToXMLCount (int offset, int [] counts) {
    counts [offset]++;
    if (counts [offset] &gt; 1) {
      return; }

    int lookupType = getuint16 (offset);
    for (int st = 0; st &lt; getuint16 (offset + 4); st++) {
      int stOffset = getOffset (offset, 6 + 2*st);
      lookupSubtableToXMLCount (stOffset, counts, lookupType); }
  }

  public void lookupTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int [] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;lookupTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      lookupTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void lookupTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;lookupTable_&quot; + Integer.toHexString (offset));
      lookupTableToXMLEmit (conf, offset, counts,
                            &quot;lookupTable&quot;, at);
      counts [offset] = 0; }

    int lookupType = getuint16 (offset);
    for (int st = 0; st &lt; getuint16 (offset + 4); st++) {
      int stOffset = getOffset (offset, 6 + 2*st);
      lookupSubtableToXML (conf, stOffset, counts, lookupType); }
  }

  protected void lookupTableToXMLEmit (DecompilerConfig conf, int offset,
                                    int[] counts,
				    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute (&quot;&quot;, &quot;type&quot;, &quot;type&quot;, &quot;CDATA&quot;, &quot;&quot; + getuint16 (offset));

    int lookupFlag = getuint16 (offset + 2);
    if ((lookupFlag &amp; 0x0001) != 0) {
      at.addAttribute (&quot;&quot;, &quot;rightToLeft&quot;, &quot;rightToLeft&quot;, &quot;CDATA&quot;,
                       ((lookupFlag &amp; 0x0001) != 0) ? &quot;yes&quot; : &quot;no&quot;);  }
    if ((lookupFlag &amp; 0x0002) != 0) {
      at.addAttribute (&quot;&quot;, &quot;ignoreBaseGlyphs&quot;, &quot;ignoreBaseGlyphs&quot;, &quot;CDATA&quot;,
                       ((lookupFlag &amp; 0x0002) != 0) ? &quot;yes&quot; : &quot;no&quot;); }
    if ((lookupFlag &amp; 0x0004) != 0) {
      at.addAttribute (&quot;&quot;, &quot;ignoreLigatures&quot;, &quot;ignoreLigatures&quot;, &quot;CDATA&quot;,
                       ((lookupFlag &amp; 0x0004) != 0) ? &quot;yes&quot; : &quot;no&quot;); }
    if ((lookupFlag &amp; 0x0008) != 0) {
      at.addAttribute (&quot;&quot;, &quot;ignoreMarks&quot;, &quot;ignoreMarks&quot;, &quot;CDATA&quot;,
                       ((lookupFlag &amp; 0x0008) != 0) ? &quot;yes&quot; : &quot;no&quot;); }
    if ((lookupFlag &amp; 0xFF00) != 0) {
      at.addAttribute (&quot;&quot;, &quot;markAttachmentType&quot;, &quot;markAttachmentType&quot;,
                       &quot;CDATA&quot;, &quot;&quot; + ((lookupFlag &gt;&gt; 8) &amp; 0xff)); }

    conf.ch.startElement (element, at); {
      int lookupType = getuint16 (offset);
      for (int st = 0; st &lt; getuint16 (offset + 4); st++) {
        int stOffset = getOffset (offset, 6 + 2*st);
        lookupSubtableOffsetToXML (conf, stOffset, counts, lookupType); }
      conf.ch.endElement (element); }
  }
</code-fragment>

<code-fragment id="gsub.methods">
  static final String[] lookupNames = {null, &quot;singleSubst&quot;, &quot;multipleSubst&quot;,
    &quot;alternateSubst&quot;, &quot;ligatureSubst&quot;, &quot;contextual&quot;,
    &quot;chainingContextual&quot;, &quot;extensionSubst&quot;};

  String lookupName (int lookupType) {
    return lookupNames [lookupType];
  }

  int lookupType (String name) {
    for (int i = 0; i &lt; lookupNames.length ; i++) {
      if (name.equals (lookupNames [i])) {
        return i; }}
    return 0;
  }

  public void lookupSubtableToXMLCount (int stOffset, int[] counts,
                                        int lookupType) {
    counts [stOffset]++;
    if (counts [stOffset] &gt; 1) {
      return; }

    switch (lookupType) {
      case 1: { <code-include linkend="gsub.toXMLCount_1"/>;   break; }
      case 2: { <code-include linkend="gsub.toXMLCount_2"/>;   break; }
      case 3: { <code-include linkend="gsub.toXMLCount_3"/>;   break; }
      case 4: { <code-include linkend="gsub.toXMLCount_4"/>;   break; }
      case 5: { contextualLookupToXMLCount (stOffset, counts); break; }
      case 6: { chainingLookupToXMLCount (stOffset, counts);   break; }
      case 7: { extensionLookupToXMLCount (stOffset, counts);  break; }}
  }

  public void lookupSubtableOffsetToXML (DecompilerConfig conf, int stOffset,
                                         int [] counts,
                                         int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [stOffset] != 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       lookupNames [lookupType] + &quot;Table_&quot;
		         + Integer.toHexString (stOffset));
      conf.ch.element (lookupNames [lookupType] + &quot;Table&quot;, at); }

    else {
      lookupSubtableToXMLEmit (conf, stOffset, counts,
                               lookupNames [lookupType], new AttributesImpl (),
			       lookupType); }
  }

  public void lookupSubtableToXML (DecompilerConfig conf, int stOffset,
                                   int[] counts,
                                   int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [stOffset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       lookupNames [lookupType] + &quot;Table_&quot;
                         + Integer.toHexString (stOffset));
      lookupSubtableToXMLEmit (conf, stOffset, counts,
                               lookupNames [lookupType] + &quot;Table&quot;, at,
                               lookupType);
      counts [stOffset] = 0; }

    switch (lookupType) {
      case 1: { <code-include linkend="gsub.toXML_1"/>;       break; }
      case 2: { <code-include linkend="gsub.toXML_2"/>;       break; }
      case 3: { <code-include linkend="gsub.toXML_3"/>;       break; }
      case 4: { <code-include linkend="gsub.toXML_4"/>;       break; }
      case 5: { contextualLookupToXML (conf, stOffset, counts); break; }
      case 6: { chainingLookupToXML (conf, stOffset, counts);   break; }
      case 7: { extensionLookupToXML (conf, stOffset, counts);  break; }}
  }

  public void lookupSubtableToXMLEmit (DecompilerConfig conf,
                                       int stOffset, int[] counts,
				       String element, AttributesImpl at,
                                       int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute (&quot;&quot;, &quot;format&quot;, &quot;format&quot;, &quot;CDATA&quot;,
                     &quot;&quot; + getuint16 (stOffset));
    conf.ch.startElement (element, at); {
      switch (lookupType) {
        case 1: { <code-include linkend="gsub.toXMLEmit_1"/>;       break; }
        case 2: { <code-include linkend="gsub.toXMLEmit_2"/>;       break; }
        case 3: { <code-include linkend="gsub.toXMLEmit_3"/>;       break; }
        case 4: { <code-include linkend="gsub.toXMLEmit_4"/>;       break; }
        case 5: { contextualLookupToXMLEmit (conf, stOffset, counts); break; }
	case 6: { chainingLookupToXMLEmit (conf, stOffset, counts);   break; }
	case 7: { extensionLookupToXMLEmit (conf, stOffset, counts);  break; }}
      conf.ch.endElement (element); }
  }
</code-fragment>


<code-fragment id="gpos.methods">
  final String[] lookupNames = {null, &quot;singlePos&quot;, &quot;pairPos&quot;,
      &quot;cursiveAttachment&quot;, &quot;markToBaseAttachment&quot;,
      &quot;markToLigatureAttachment&quot;, &quot;markToMarkAttachment&quot;,
      &quot;contextual&quot;, &quot;chainingContextual&quot;, &quot;extensionPos&quot;};

  String lookupName (int lookupType) {
    return lookupNames [lookupType];
  }

  int lookupType (String name) {
    for (int i = 0; i &lt; lookupNames.length; i++) {
      if (name.equals (lookupNames [i])) {
        return i; }}
    return 0;
  }

  public void lookupSubtableToXMLCount (int stOffset, int[] counts,
                                        int lookupType) {
    counts [stOffset]++;
    if (counts [stOffset] &gt; 1) {
      return; }

    switch (lookupType) {
      case 1: { <code-include linkend="gpos.toXMLCount_1"/>;   break; }
      case 2: { <code-include linkend="gpos.toXMLCount_2"/>;   break; }
      case 3: { <code-include linkend="gpos.toXMLCount_3"/>;   break; }
      case 4: { <code-include linkend="gpos.toXMLCount_4"/>;   break; }
      case 5: { <code-include linkend="gpos.toXMLCount_5"/>;   break; }
      case 6: { <code-include linkend="gpos.toXMLCount_6"/>;   break; }
      case 7: { contextualLookupToXMLCount (stOffset, counts); break; }
      case 8: { chainingLookupToXMLCount (stOffset, counts);   break; }
      case 9: { extensionLookupToXMLCount (stOffset, counts);  break; }}
  }

  public void lookupSubtableToXML (DecompilerConfig conf, int stOffset,
                                   int[] counts,
                                   int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [stOffset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       lookupNames [lookupType] + &quot;Table_&quot;
                         + Integer.toHexString (stOffset));
      lookupSubtableToXMLEmit (conf, stOffset, counts,
                               lookupNames [lookupType] + &quot;Table&quot;, at,
                               lookupType);
      counts [stOffset] = 0; }

    switch (lookupType) {
      case 1: { <code-include linkend="gpos.toXML_1"/>;       break; }
      case 2: { <code-include linkend="gpos.toXML_2"/>;       break; }
      case 3: { <code-include linkend="gpos.toXML_3"/>;       break; }
      case 4: { <code-include linkend="gpos.toXML_4"/>;       break; }
      case 5: { <code-include linkend="gpos.toXML_5"/>;       break; }
      case 6: { <code-include linkend="gpos.toXML_6"/>;       break; }
      case 7: { contextualLookupToXML (conf, stOffset, counts); break; }
      case 8: { chainingLookupToXML (conf, stOffset, counts);   break; }
      case 9: { extensionLookupToXML (conf, stOffset, counts);  break; }}
  }

  public void lookupSubtableOffsetToXML (DecompilerConfig conf, int stOffset,
                                         int [] counts,
                                         int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [stOffset] != 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       lookupNames [lookupType] + &quot;Table_&quot;
		         + Integer.toHexString (stOffset));
      conf.ch.element (lookupNames [lookupType], at); }

    else {
      lookupSubtableToXMLEmit (conf, stOffset, counts,
                               lookupNames [lookupType], new AttributesImpl (),
			       lookupType); }
  }

  public void lookupSubtableToXMLEmit (DecompilerConfig conf,
                                       int stOffset, int[] counts,
 				       String element, AttributesImpl at,
                                       int lookupType)
      throws org.xml.sax.SAXException, InvalidFontException {

    at.addAttribute (&quot;&quot;, &quot;format&quot;, &quot;format&quot;, &quot;CDATA&quot;,
                     &quot;&quot; + getuint16 (stOffset));
    conf.ch.startElement (element, at); {
      switch (lookupType) {
        case 1: { <code-include linkend="gpos.toXMLEmit_1"/>;       break; }
        case 2: { <code-include linkend="gpos.toXMLEmit_2"/>;       break; }
	case 3: { <code-include linkend="gpos.toXMLEmit_3"/>;       break; }
	case 4: { <code-include linkend="gpos.toXMLEmit_4"/>;       break; }
	case 5: { <code-include linkend="gpos.toXMLEmit_5"/>;       break; }
	case 6: { <code-include linkend="gpos.toXMLEmit_6"/>;       break; }
	case 7: { contextualLookupToXMLEmit (conf, stOffset, counts); break; }
	case 8: { chainingLookupToXMLEmit (conf, stOffset, counts);   break; }
	case 9: { extensionLookupToXMLEmit (conf, stOffset, counts);  break; }}
      conf.ch.endElement (element); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>Since each table (<ottable>GSUB</ottable>,
          <ottable>GPOS</ottable>) defines different lookup subtables,
          we need to defer the application of a subtable to the
          corresponding classes. We encapsulate this operation in a
          method that applies a given subtable to a given position of
          a glyphrun.</para>

	<para>This method returns a complex result. The boolean
          <varname>applied</varname> is true iff the glyphrun matched
          the pattern of the subtable. If true, then the two other
          fields are defined: <varname>nextToProcess</varname> is the
          next glyph to process, and <varname>countAdjust</varname> is
          the difference between the number of glyphs after
          application and the number of glyph before application.</para>

<code-fragment id="lookuptable.methods">
  <code-title>LookupResult class</code-title>
  static public class LookupResult {
    public boolean applied;
    public int nextToProcess;
    public int countAdjust;

    public LookupResult (boolean applied, int nextToProcess, int countAdjust) {
      this.applied = applied;
      this.nextToProcess = nextToProcess;
      this.countAdjust = countAdjust;
    }
  }

  static public LookupResult lookupNotApplied = new LookupResult (false, 0, 0);
</code-fragment>

	<para>And is the declaration for applyLookupSubtable:</para>

<code-fragment id="lookuptable.methods">
  <code-title>Method to apply a lookup subtable at a glyph position</code-title>
  abstract public LookupResult applyLookupSubtable
              (int lookupIndex, int lookupType,
               int lookupFlag, int stOffset,
               GlyphRun gr, int curGlyph)
      throws InvalidFontException;
</code-fragment>

        <para>From there, we can apply a given lookup to a given
          position in a glyph run. It's simply a matter of trying each
          subtable in turn, until one succeeds. This method returns
          a <varname>LookupResult</varname>.</para>

<code-fragment id="lookuptable.methods">
  <code-title>Method to apply a lookup at a glyph position</code-title>

  public LookupResult applyLookup (int lookupIndex, GlyphRun gr, int curGlyph)
    throws InvalidFontException {

    if (listener != null) {
      listener.applyingLookupAtPos (lookupIndex, gr, curGlyph); }

    try {
      int lookupOffset = getLookupOffset (lookupIndex);

      int lookupType = getuint16 (lookupOffset);
      int lookupFlag = getuint16 (lookupOffset + 2);
      int subtableCount = getuint16 (lookupOffset + 4);


      if (lookupFlagCovers (lookupFlag, gr.glyphAt (curGlyph))) {
        if (listener != null) {
          listener.noSubtableApplied (lookupIndex, gr, curGlyph); }
        return lookupNotApplied; }

      for (int st = 0; st &lt; subtableCount; st++) {
        int stOffset
          = lookupOffset + getOffset (lookupOffset + 6 + 2*st);

        LookupResult result = applyLookupSubtable (lookupIndex,
	                          lookupType, lookupFlag,
                                  stOffset, gr, curGlyph);
        if (result.applied) {
          return result; }}

      // no subtable worked, just move to the next glyph
      if (listener != null) {
        listener.noSubtableApplied (lookupIndex, gr, curGlyph); }

      return lookupNotApplied; }

    finally {
      if (listener != null) {
        listener.applyingLookupAtPosDone (lookupIndex, gr, curGlyph); }}
  }
</code-fragment>

        <para>Finally, we can apply a bunch of features to a glyph
          run:</para>

<code-fragment id="lookuptable.methods">
  <code-title>Apply features to a glyphrun</code-title>
  public void applyFeatures (long scriptTag, long langSysTag,
                             long []featureTags, GlyphRun gr)
      throws InvalidFontException {
    applyFeatures (scriptTag, langSysTag, featureTags,
                   gr, 0, gr.glyphCount () - 1);
  }

  public void applyFeatures (long scriptTag, long langSysTag,
                             long []featureTags, GlyphRun gr,
	                     int start, int stop)
      throws InvalidFontException {

    int[] lookupIndices = findLookups (scriptTag, langSysTag, featureTags);

    if (listener != null) {
      listener.selectedLookups (lookupIndices); }

    for (int l = 0; l &lt; lookupIndices.length; l++) {
      if (listener != null) {
        listener.applyingLookup (lookupIndices [l], gr); }
      int curGlyph = start;
      while (curGlyph &lt;= stop) {
        LookupResult result = applyLookup (lookupIndices [l], gr, curGlyph);
        if (result.applied) {
          curGlyph = result.nextToProcess;
          stop += result.countAdjust; }
        else {
          curGlyph++; }}
      if (listener != null) {
        listener.applyingLookupDone (lookupIndices [l], gr); }}
  }
</code-fragment>

        <para>When we apply a lookup, we will need to know if LookupFlag
          covers a glyph or not.</para>

<code-fragment id="layouttable.methods">
  <code-title>Method to find if lookupFlag covers a glyph</code-title>
  public boolean lookupFlagCovers (int lookupFlag, int glyph)
    throws InvalidFontException {

    if (glyph == -1) {
      return false; }

    if ((lookupFlag &amp; 0x0E) != 0) {
      int glyphClass = font.gdef.getGlyphClass (glyph);
      if (   ((lookupFlag &amp; 0x2) != 0 &amp;&amp; glyphClass == 1)
          || ((lookupFlag &amp; 0x4) != 0 &amp;&amp; glyphClass == 2)
          || ((lookupFlag &amp; 0x8) != 0 &amp;&amp; glyphClass == 3))
        return true; }

    if (   (lookupFlag &amp; 0xff00) != 0
        &amp;&amp; font.gdef.getGlyphClass (glyph) == 3) {
      int markClass = font.gdef.getMarkAttachClass (glyph);
      if (((lookupFlag &amp; 0xff00) &gt;&gt; 8) != markClass) {
        return true; }}

    return false;
  }
</code-fragment>

      </section>
      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

	<section>
	  <title>LookupFlag</title>

	  <para>Testing the behavior of lookupFlag on every single
	  type of lookup would be an enormous tasks. In fact, it is
	  likely that the behaviour of lookupFlag is implemented in
	  our place (like our <function>lookupFlagCovers</function>
	  method above) and is used everywhere. So all our testing is
	  done using the simplest lookup type that is convenient to
	  reach the behaviour, LigatureSubstitutions.</para>

	  <para>Let’s start by making sure that those work
	  reasonably well:</para>

<aots:test-font id="lookupflag_ignore_base_f1">
  <base-font name="base.otf"/>
  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
	<class classID="1" glyphs="24 25"/>
    </glyphClassDef>
  </GDEF>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
	<lookup id="lookup.test" type="4" ignoreBaseGlyphs="yes">
	  <ligatureSubst format="1">
	    <coverage glyphs="18" format="any"/>
	    <subst in="18 19 20" out="23"/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <para>First, let’s make sure we get the ligating
          behaviour even when no glyphs have to be skipped:</para>

	  <aots:gsub-test id="lookupflag_ignore_base_t1" font="lookupflag_ignore_base_f1" inputs="17, 18, 19, 20, 21" outputs="17, 23,         21"/>

	  <para>Let’s skip a few glyphs:</para>

	  <aots:gsub-test id="lookupflag_ignore_base_t2" font="lookupflag_ignore_base_f1" inputs="17, 18, 24, 24, 19, 25, 20, 21" outputs="17, 23, 24, 24,     25,     21"/>

	  <para>Let’s try ignoring ligatures:</para>

<aots:test-font id="lookupflag_ignore_ligatures_f1">
  <base-font name="base.otf"/>
  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
	<class classID="1" glyphs="24 25"/>
	<class classID="2" glyphs="26 27"/>
	<class classID="3" glyphs="28 29"/>
    </glyphClassDef>
  </GDEF>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
	<lookup id="lookup.test" type="4" ignoreLigatures="yes">
	  <ligatureSubst format="1">
	    <coverage glyphs="18" format="any"/>
	    <subst in="18 19 20" out="23"/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="lookupflag_ignore_ligatures_t1" font="lookupflag_ignore_ligatures_f1" inputs="17, 18, 26, 27, 19, 27, 20, 21" outputs="17, 23, 26, 27,     27,     21"/>

	  <para>Let’s not skip some glyphs in the other classes:</para>

          <aots:gsub-test id="lookupflag_ignore_ligatures_t2" font="lookupflag_ignore_ligatures_f1" inputs="17, 18, 26, 24, 19, 27, 20, 21" outputs="17, 18, 26, 24, 19, 27, 20, 21"/>

	  <para>... including in class 0, which is always a bit special:</para>

          <aots:gsub-test id="lookupflag_ignore_ligatures_t3" font="lookupflag_ignore_ligatures_f1" inputs="17, 18, 26, 42, 19, 27, 20, 21" outputs="17, 18, 26, 42, 19, 27, 20, 21"/>

	  <para>Let’s try ignoring marks:</para>

<aots:test-font id="lookupflag_ignore_marks_f1">
  <base-font name="base.otf"/>
  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
	<class classID="1" glyphs="24 25"/>
	<class classID="2" glyphs="26 27"/>
	<class classID="3" glyphs="28 29"/>
    </glyphClassDef>
  </GDEF>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
	<lookup id="lookup.test" type="4" ignoreMarks="yes">
	  <ligatureSubst format="1">
	    <coverage glyphs="18" format="any"/>
	    <subst in="18 19 20" out="23"/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="lookupflag_ignore_marks_t1" font="lookupflag_ignore_marks_f1" inputs="17, 18, 28, 29, 19, 29, 20, 21" outputs="17, 23, 28, 29,     29,     21"/>

	  <para>Let’s try ignoring marks by their attachment
	  class. Remember the discussion about base glyphs in the
	  annotations. Glyphs 10...15 are base glyphs, 20...24 are marks of one
	  class, and 25...29 are marks of another class. We want to
	  ligate 11, 13 and 26 into 15.</para>

<aots:test-font id="lookupflag_ignore_attach_f1">
  <base-font name="base.otf"/>
  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
	<class classID="1" glyphs="10 11 12 13 14 "/>
	<class classID="2" glyphs="15"/>
	<class classID="3" glyphs="20 21 22 23 24 25 26 27 28 29"/>
    </glyphClassDef>
    <markAttachClassDef format="any">
	<class classID="1" glyphs="20 21 22 23 24"/>
	<class classID="2" glyphs="25 26 27 28"/>
    </markAttachClassDef>
  </GDEF>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
	<lookup id="lookup.test" type="4" markAttachmentType="2">
	  <ligatureSubst format="1">
	    <coverage glyphs="11" format="any"/>
	    <subst in="11 13 26" out="15"/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <para>First, let’s make sure the ligature works.</para>

          <aots:gsub-test id="lookupflag_ignore_attach_t1" font="lookupflag_ignore_attach_f1" inputs="10, 11, 13, 26, 10" outputs="10, 15,         10"/>

	  <para>Let”s inject class 0 and 1 marks, which should be
	  skipped.</para>

          <aots:gsub-test id="lookupflag_ignore_attach_t2" font="lookupflag_ignore_attach_f1" inputs="10, 11, 21, 13, 22, 23, 29, 26, 10" outputs="10, 15, 21,     22, 23, 29,     10"/>

	  <para>Let’s inject class 2 marks, which should
	  prevent the ligature</para>

          <aots:gsub-test id="lookupflag_ignore_attach_t3" font="lookupflag_ignore_attach_f1" inputs="10, 11, 21, 13, 22, 27, 26, 10" outputs="10, 11, 21, 13, 22, 27, 26, 10"/>

          <aots:gsub-test id="lookupflag_ignore_attach_t4" font="lookupflag_ignore_attach_f1" inputs="10, 11, 27, 13, 22, 23, 26, 10" outputs="10, 11, 27, 13, 22, 23, 26, 10"/>

	  <para>So do other base</para>

          <aots:gsub-test id="lookupflag_ignore_attach_t5" font="lookupflag_ignore_attach_f1" inputs="10, 11, 27, 13, 14, 23, 26, 10" outputs="10, 11, 27, 13, 14, 23, 26, 10"/>

	  <para>And of course, we have combinations!</para>

<aots:test-font id="lookupflag_ignore_combination_f1">
  <base-font name="base.otf"/>
  <GDEF major="1" minor="0">
    <glyphClassDef format="any">
	<class classID="1" glyphs="24 25 26"/>
	<class classID="2" glyphs="27 28 29"/>
	<class classID="3" glyphs="30 31 32"/>
    </glyphClassDef>
    <markAttachClassDef format="any">
	<class classID="1" glyphs="25 28 31 34"/>
	<class classID="2" glyphs="26 29 32 35"/>
    </markAttachClassDef>
  </GDEF>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
	<lookup id="lookup.test" type="4" ignoreBaseGlyphs="yes" markAttachmentType="2">
	  <ligatureSubst format="1">
	    <coverage glyphs="18" format="any"/>
	    <subst in="18 19 20" out="23"/>
	  </ligatureSubst>
	</lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="lookupflag_ignore_combination_t1" font="lookupflag_ignore_combination_f1" inputs="17, 18, 26, 19, 20, 21" outputs="17, 23, 26,        21"/>

          <aots:gsub-test id="lookupflag_ignore_combination_t2" font="lookupflag_ignore_combination_f1" inputs="17, 18, 26, 19, 24, 30, 31, 20, 21" outputs="17, 23, 26,     24, 30, 31,     21"/>

          <aots:gsub-test id="lookupflag_ignore_combination_t3" font="lookupflag_ignore_combination_f1" inputs="17, 18, 26, 19, 24, 30, 32, 20, 21" outputs="17, 18, 26, 19, 24, 30, 32, 20, 21"/>

	</section>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Coverage Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Each subtable (except an Extension LookupType subtable)
          in a lookup references a Coverage table (Coverage), which
          specifies all the glyphs affected by a substitution or
          positioning operation described in the subtable. The
          <ottable>GSUB</ottable>, <ottable>GPOS</ottable>, and
          <ottable>GDEF</ottable> tables rely on this notion of
          coverage. If a glyph does not appear in a Coverage table,
          the client can skip that subtable and move immediately to
          the next subtable.</para>

        <para>A Coverage table identifies glyphs by glyph indices
          (GlyphIDs) either of two ways:</para>

        <itemizedlist>
          <listitem>
            <para>As a list of individual glyph indices in the glyph
              set.</para>
          </listitem>
          <listitem>
            <para>As ranges of consecutive indices. The range format
              gives a number of start-glyph and end-glyph index pairs
              to denote the consecutive glyphs covered by the
              table.</para>
          </listitem>
        </itemizedlist>

        <para>In a Coverage table, a format code (CoverageFormat)
          specifies the format as an integer: 1 = lists, and 2 =
          ranges.</para>

        <para>A Coverage table defines a unique index value (Coverage
          Index) for each covered glyph. This unique value specifies
          the position of the covered glyph in the Coverage table. The
          client uses the Coverage Index to look up values in the
          subtable for each glyph.</para>

      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>The specification does not mention a fairly interesting
          property of the existing subtable formats: A coverage is
          really a subset of n glyphs of the font, and those glyphs
          are enumerated in glyph index order by the Coverage Index<!--  -->
          (i.e. CI(0) is the glyph with the smallest glyph id in that
          subset, CI(1) is the next, and so on to CI(n-1) which is the
          glyph with the largest glyph id).</para>

        <para>It is possible that a new coverage be defined for which
          this property does not hold. However, this seems unlikely,
          and we will assume that the property will always
          hold. Recommendation: make that clear in the
          specification.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a coverage, but instead
	  would prefer the compiler to figure out the best
	  representation. For this purpose, we use the observation in
	  our annotations, and represent two attributes:
	  <sgmltag>format</sgmltag> with the value
	  <sgmltag>any</sgmltag> and <sgmltag>glyphs</sgmltag> to hold
	  the list of covered glyphs:</para>

<code-fragment id="schema">
  <code-title>coverageTable</code-title>
  coverageTable |=
    attribute format { &quot;any&quot; },
    attribute glyphs { text }

  standaloneCoverageTable =
    element coverageTable { attribute id { text }, coverageTable }

  coverageTableOffset = attribute name { text } | coverageTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment package="com.adobe.aots.CommonType" class="CoverageTableBlock">
package com.adobe.aots.CommonType;

public class CoverageTableBlock extends Block {
  public CoverageTableBlock (int size, int referenceCount) {
    super (size, referenceCount);
  }

  public int[] glyphs;

  public int index (int gid) {
    for (int ci = 0; ci &lt; glyphs.length; ci++) {
      if (glyphs [ci] == gid) {
        return ci; }}
    return -1;
  }
}
</code-fragment>


<code-fragment id="layouttable.methods">
  public CoverageTableBlock coverageFromXML (Element t,
                                             Element table,
					     Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        t = resolveXMLid (table, name); }}

    { CoverageTableBlock cached = (CoverageTableBlock) blockCache.get (t);
      if (cached != null) {
        return cached; }}

    CoverageTableBlock me = null;

    String format = t.getAttribute (&quot;format&quot;);

    if (&quot;any&quot;.equals (format)) {
      me = coverageFromGlyphs (getGlyphs (t.getAttribute (&quot;glyphs&quot;))); }
    else if (&quot;1&quot;.equals (format)) {
      me = coverageFormat1FromXML (t, table, blockCache); }
    else if (&quot;2&quot;.equals (format)) {
      me = coverageFormat2FromXML (t, table, blockCache); }
    else {
      /* cannot get there on valid document */
      throw new InvalidFontException
                 (&quot;invalid coverage format (&quot; + format + &quot;)&quot;); }

    blockCache.put (t, me);
    return me;
  }


  public CoverageTableBlock emptyCoverage () {
    return coverageFromGlyphs (new int[0], 0);
  }

  public CoverageTableBlock coverageFromGlyphs (int [] glyphs) {
    return coverageFromGlyphs (glyphs, glyphs.length);
  }

  public CoverageTableBlock coverageFromGlyphs (Integer [] glyphs) {
    return coverageFromGlyphs (glyphs, glyphs.length);
  }

  public CoverageTableBlock coverageFromGlyphs (Integer [] glyphs, int count) {
    int[] g = new int [count];
    for (int i = 0; i &lt; count; i++) {
      g[i] = glyphs[i].intValue (); }
    return coverageFromGlyphs (g, count);
  }

  public CoverageTableBlock coverageFromGlyphs (int [] glyphs, int count) {
    CoverageTableBlock table = new CoverageTableBlock (4 + 2*count, 0);
    table.glyphs = new int [count];
    System.arraycopy (glyphs, 0, table.glyphs, 0, count);

    for (int i = 0; i &lt; count - 1; i++) {
      for (int j = i + 1; j &lt; count; j++) {
        if (table.glyphs [i] &gt; table.glyphs [j]) {
          int temp = table.glyphs [i];
          table.glyphs [i] = table.glyphs [j];
          table.glyphs [j] = temp; }}}

    table.setuint16 (0, 1);
    table.setuint16 (2, count);
    for (int i = 0; i &lt; count; i++) {
      table.setGlyphID (4 + 2*i, table.glyphs [i]); }

    return table;
  }
</code-fragment>

        <para>This method is given a nodelist, which must contains
        Elements only. Each element in the list must have the
        attribute <varname>attribute</varname>, the value of which is
        a sequence of glyph references. The coverage is built by
        taking the first glyph reference in each attribute (if
        firstOnly is true) or all the glyphs references (if firstOnly
        is false).</para>

<code-fragment id="layouttable.methods">
  public CoverageTableBlock coverageFromXML (NodeList nl, String attribute)
      throws InvalidFontException, UnsupportedFontException {
    return coverageFromXML (nl, attribute, true);
  }

  public CoverageTableBlock coverageFromXML (NodeList nl, String attribute,
                                             boolean firstOnly)
      throws InvalidFontException, UnsupportedFontException {

    SortedSet&lt;Integer&gt; s = new TreeSet&lt;Integer&gt; ();

    for (int i = 0; i &lt; nl.getLength (); i++) {
      Element e = (Element) nl.item (i);
      String v = e.getAttribute (attribute).trim ();
      if (e.hasAttribute (attribute)) {
        int[] gids = parseGlyphList (v);
        int count = firstOnly ? 1 : gids.length;
        for (int j = 0; j &lt; count; j++) {
          s.add (gids [j]); }}}

    int [] glyphs = new int [s.size ()];
    int glyphCount = 0;

    for (int gid : s) {
       glyphs [glyphCount++] = gid; }

    return coverageFromGlyphs (glyphs);
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="layouttable.methods">
  public void coverageTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
  }

  public void coverageTableOffsetToXML (DecompilerConfig conf, int offset,
                                        int[] counts,
                                        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;coverageTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      coverageTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void coverageTableToXML (DecompilerConfig conf, int offset,
                                  int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;coverageTable_&quot; + Integer.toHexString (offset));
      coverageTableToXMLEmit (conf, offset, counts, &quot;coverageTable&quot;, at);
      counts [offset] = 0; }
  }

  public void coverageTableToXMLEmit (DecompilerConfig conf, int offset,
                                      int[] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (conf.preciseCoverageFormat) {
      int format = getuint16 (offset);
      at.addAttribute (&quot;&quot;, &quot;format&quot;, &quot;format&quot;, &quot;CDATA&quot;, &quot;&quot; + format);
      switch (format) {
        case 1: { <code-include linkend="LayoutTable.coverageToXML.1"/>; break; }
        case 2: { <code-include linkend="LayoutTable.coverageToXML.2"/>; break; }}}

    else {
      int[] glyphs = getCoveredGlyphs (offset);
      StringBuilder sb = new StringBuilder ();

      if (conf.glyphNames != null) {
        for (int i = 0; i &lt; glyphs.length; i++) {
          glyphToXML (conf, sb, glyphs [i]); }}

      else {
        int i = 0;
        while (i &lt; glyphs.length) {
          int start = glyphs [i];
          int stop = start;
          i++;

          while (i &lt; glyphs.length &amp;&amp; (glyphs [i] == glyphs [i-1] + 1)) {
    	    stop = glyphs [i];
            i++; }

          if (start &lt; stop) {
            sb.append (&quot; &quot;);
	    sb.append (start);
            sb.append (&quot;:&quot;);
	    sb.append (stop); }
          else {
            sb.append (&quot; &quot;);
	    sb.append (start); }}}

        at.addAttribute (&quot;&quot;, &quot;format&quot;, &quot;format&quot;, &quot;CDATA&quot;, &quot;any&quot;);
        at.addAttribute (&quot;&quot;, &quot;glyphs&quot;, &quot;glyphs&quot;, &quot;CDATA&quot;, sb.toString ());
        conf.ch.element (element, at); }
  }


  public int[] coverageToXMLDetailed (DecompilerConfig conf, int offset)
      throws org.xml.sax.SAXException {

    return null;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>Getting a little bit ahead of the specification, we note
          that in all formats, a subtable starts with a uint16, which
          indicates its format.</para>

        <para>The first interesting operation on a coverage is to
          determine if a given glyph is covered;</para>

<!--
<code-method-decl id='layouttable.methods>
  <code-signature>
    <code-visible>protected</code-visible>
    <code-name>getCoverageIndex</code-name>

    <code-args>
      <code-arg>
        <code-type>int</code-type>
        <code-name>glyphID</code-name>
        <code-desc>The glyph for which the coverage index is
        desired</code-desc>
      <code-arg>
      <code-arg>
        <code-type>int</code-type>
        <code-name>coverageOffset</code-name>
        <code-desc>The offset of the coverage table to use, in the
        current table</code-desc>
      </code-arg>
    </code-args>

    <code-exceptions>
      <code-exception>
        <code-name>InvalidFontException</code-name>
        <code-desc>if the font cannot be parsed</code-desc>
      </code-exception>
    </code-exceptions>

    <code-return>
      <code-type>int</code-type>
      <code-desc>-1 if the glyph is not covered; otherwise its
      coverage index</code-desc>
    </code-return>
  <code-signature>

  <code-desc>Returns the coverage index of <varname>glyphID</varname>
  using the coverage table at
  <varname>coverageOffset</varname>.</code-desc>

  <code-body>
    int format = getuint16 (coverageOffset);

    switch (format) {
      case 1: { <code-include linkend='LayoutTable_getCoverageIndex1'/> }
      case 2: { <code-include linkend='LayoutTable_getCoverageIndex2'/> }
      default: throw new InvalidFontException (); }
  </code-body>

</code-method-decl>
-->



<code-fragment id="layouttable.methods">
  <code-title>Method to get the coverage index of a glyph</code-title>
  /**
   * Returns the coverage index of glyphID using the coverage at
   * coverageOffset. If the glyph is not covered, returns -1.
   *
   * @param glyphID
   * @param coverageOffset the offset the coverage table in the current table
   * @return -1 if the glyph is not covered, its coverage index  otherwise.
   * @exception InvalidFontException
   *             if the font cannot be parsed.
   */
  protected int getCoverageIndex (int glyphID, int coverageOffset)
      throws InvalidFontException {

    if (glyphID == -1) {
      return -1; }

    int format = getuint16 (coverageOffset);

    switch (format) {
      case 1: { <code-include linkend="LayoutTable_getCoverageIndex1"/> }
      case 2: { <code-include linkend="LayoutTable_getCoverageIndex2"/> }
      default: throw new InvalidFontException (); }
  }
</code-fragment>

        <para>Another interesting operation is to enumerate all the
          covered glyphs:</para>

<code-fragment id="layouttable.methods">
  <code-title>Method to get the glyphs covered by a Coverage Table</code-title>
  /**
   * Returns the glyphs covered by the coverage at
   * coverageOffset.
   *
   * @param coverageOffset the offset the coverage table in the current table
   * @return an array of glyphIDs. The coverage index of a glyph is
   *         its position in the array
   * @exception InvalidFontException
   *             if the font cannot be parsed.
   */
  protected int[] getCoveredGlyphs (int coverageOffset)
      throws InvalidFontException {

    int format = getuint16 (coverageOffset);

    switch (format) {
      case 1: { <code-include linkend="LayoutTable_getCoveredGlyphs1"/> }
      case 2: { <code-include linkend="LayoutTable_getCoveredGlyphs2"/> }
      default: throw new InvalidFontException (); }
  }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Coverage Format 1</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Coverage Format 1 consists of a format code
          (CoverageFormat) and a count of covered glyphs (GlyphCount),
          followed by an array of glyph indices (GlyphArray). The
          glyph indices must be in numerical order for binary
          searching of the list. When a glyph is found in the Coverage
          table, its position in the GlyphArray determines the
          Coverage Index that is returned-the first glyph has a
          Coverage Index = 0, and the last glyph has a Coverage Index
          = GlyphCount -1.</para>

        <para>Example 5 at the end of this chapter shows a Coverage
          table that uses Format 1 to list the GlyphIDs of all
          lowercase descender glyphs in a font.</para>

        <otformat>
          <title>CoverageFormat1 table: Individual glyph
          indices</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CoverageFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Number of glyphs in the
              GlyphArray</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>GlyphArray [GlyphCount]</otfieldname>
            <otfielddesc>Array of GlyphIDs-in numerical
              order</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>coverageTable, format 1</code-title>
  coverageTable |=
    attribute format { &quot;1&quot; },
    attribute glyphs { text }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="layouttable.methods">
  public CoverageTableBlock coverageFormat1FromXML (Element t,
                                                    Element table,
                                                    Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    return coverageFromGlyphs (getGlyphs (t.getAttribute (&quot;glyphs&quot;)));
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="LayoutTable.coverageToXML.1">
  { StringBuilder sb = new StringBuilder ();
    int glyphCount = getuint16 (offset + 2);
    int firstGlyph = -1;
    int lastGlyph = -2;

    for (int i = 0; i &lt; glyphCount; i++) {
      int glyphID = getuint16 (offset + 4 + 2*i);
      if (glyphID == lastGlyph + 1) {
        lastGlyph = glyphID; }
      else {
        if (lastGlyph &gt; firstGlyph) {
          sb.append (&quot; &quot; + firstGlyph + &quot;:&quot; + lastGlyph); }
        else if (lastGlyph == firstGlyph) {
          sb.append (&quot; &quot; + lastGlyph); }
        firstGlyph = lastGlyph = glyphID; }}

    if (lastGlyph &gt; firstGlyph) {
      sb.append (&quot; &quot; + firstGlyph + &quot;:&quot; + lastGlyph); }
    else if (lastGlyph == firstGlyph) {
      sb.append (&quot; &quot; + lastGlyph); }

    at.addAttribute (&quot;&quot;, &quot;glyphs&quot;, &quot;glyphs&quot;, &quot;CDATA&quot;, sb.toString ());

    conf.ch.element (element, at); }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>Here is our binary search to compute the coverage index
          of a glyph. The loop invariant is that a glyph is in the
          GlyphArray iff its position in it is between min and max
          (included).</para>

<code-fragment id="LayoutTable_getCoverageIndex1">
  <code-title>Return the coverage index for a format 1 Coverage table</code-title>
  { int min = 0;
    int max = getuint16 (coverageOffset + 2) - 1;

    while (min &lt;= max) {
      int mid = (min + max) / 2;
      int g = getGlyphID (coverageOffset + 4 + 2*mid);

      if (glyphID &lt; g) {
        max = mid - 1; }
      else if (g &lt; glyphID) {
        min = mid + 1; }
      else {
        return mid; }}

    return -1; }
</code-fragment>

        <para>Building the list of covered glyphs is straithforward:</para>

<code-fragment id="LayoutTable_getCoveredGlyphs1">
  <code-title>Return the glyphs covered by a format 1 Coverage table</code-title>
  { int glyphCount = getuint16 (coverageOffset + 2);
    int[] glyphs = new int [glyphCount];
    for (int i = 0; i &lt; glyphCount; i++) {
      glyphs [i] = getGlyphID (coverageOffset + 4 + 2*i); }
    return glyphs; }
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Coverage Format 2</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Format 2 consists of a format code (CoverageFormat) and
          a count of glyph index ranges (RangeCount), followed by an
          array of records (RangeRecords). Each RangeRecord consists
          of a start glyph index (Start), an end glyph index (End),
          and the Coverage Index associated with the range's Start
          glyph. Ranges must be in GlyphID order, and they must be
          distinct, with no overlapping.</para>

        <para>The Coverage Indexes for the first range begin with zero
          (0), and the Start Coverage Indexes for each succeeding
          range are determined by adding the length of the preceding
          range (End GlyphID - Start GlyphID + 1) to the array Index.
          This allows for a quick calculation of the Coverage Index
          for any glyph in any range using the formula: Coverage Index
          (GlyphID) = StartCoverageIndex + GlyphID - Start
          GlyphID.</para>

        <para>Example 6 at the end of this chapter shows a Coverage
          table that uses Format 2 to identify a range of numeral
          glyphs in a font.</para>


        <otformat>
          <title>CoverageFormat2 table: Range of glyphs</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>CoverageFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>RangeCount</otfieldname>
            <otfielddesc>Number of RangeRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>RangeRecord [RangeCount]</otfieldname>
            <otfielddesc>Array of glyph ranges-ordered by Start
              GlyphID</otfielddesc>
          </otfield>
        </otformat>


        <otformat>
          <title>RangeRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Start</otfieldname>
            <otfielddesc>First GlyphID in the range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>End</otfieldname>
            <otfielddesc>Last GlyphID in the range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>StartCoverageIndex</otfieldname>
            <otfielddesc>Coverage Index of first GlyphID in
              range</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>coverageTable, format 2</code-title>
  coverageTable |=
    attribute format { &quot;2&quot; },
    element range {
      attribute start { text },
      attribute end { text }
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="layouttable.methods">
  public CoverageTableBlock coverageFormat2FromXML (Element t,
                                                    Element table,
                                                    Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    NodeList ranges = t.getChildNodes ();
    int nbRanges = ranges.getLength ();

    CoverageTableBlock me = new CoverageTableBlock (4 + 6*nbRanges, 0);
    me.setuint16 (0, 2);
    me.setuint16 (2, nbRanges);
    int ci = 0;
    for (int r = 0; r &lt; nbRanges; r++) {
      Element range = (Element) ranges.item (r);
      int start = Integer.parseInt (range.getAttribute (&quot;start&quot;));
      int end = Integer.parseInt (range.getAttribute (&quot;end&quot;));
      me.setGlyphID (4 + 6*r, start);
      me.setGlyphID (4 + 6*r+2, end);
      me.setuint16 (4 + 6*r+4, ci);
      ci += (end - start + 1); }

    me.glyphs = new int [ci];
    ci = 0;
    for (int r = 0; r &lt; nbRanges; r++) {
      Element range = (Element) ranges.item (r);
      int start = Integer.parseInt (range.getAttribute (&quot;start&quot;));
      int end = Integer.parseInt (range.getAttribute (&quot;end&quot;));
      for (int k = start; k &lt;= end; k++) {
        me.glyphs [ci++] = k; }}

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="LayoutTable.coverageToXML.2">
  { conf.ch.startElement (element, at); {

      int rangeCount = getuint16 (offset + 2);
      for (int i = 0; i &lt; rangeCount; i++) {
        int start = getuint16 (offset + 4 + 6*i);
        int end = getuint16 (offset + 4 + 6*i + 2);
        at = new AttributesImpl ();
        at.addAttribute (&quot;&quot;, &quot;start&quot;, &quot;start&quot;, &quot;CDATA&quot;, &quot;&quot; + start);
        at.addAttribute (&quot;&quot;, &quot;end&quot;, &quot;end&quot;, &quot;CDATA&quot;, &quot;&quot; + end);
        conf.ch.element (&quot;range&quot;, at); }

      conf.ch.endElement (element); }}
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>We use a binary search on the RangeRecords to find the
          coverage index of a glyph. The loop invariant is that a
          glyph is covered iff the index of the RangeRecord in which
          it occurs is between min and max (included).</para>

<code-fragment id="LayoutTable_getCoverageIndex2">
  <code-title>Return the coverage index for a format 2 Coverage table</code-title>
  { int min = 0;
    int max = getuint16 (coverageOffset + 2) - 1;

    while (min &lt;= max) {
      int mid = (min + max) / 2;
      int start = getGlyphID (coverageOffset + 4 + 6*mid);
      int stop = getGlyphID (coverageOffset + 4 + 6*mid + 2);

      if (glyphID &lt; start) {
        max = mid - 1; }
      else if (stop &lt; glyphID) {
        min = mid + 1; }
      else {
        return getuint16 (coverageOffset + 4 + 6*mid + 4)
                 + (glyphID - start); }}

    return -1; }
</code-fragment>

        <para>We can compute the number of covered glyphs by first
          computing the coverage index of the last covered
          glyph.</para>

<code-fragment id="LayoutTable_getCoveredGlyphs2">
  <code-title>Return the glyphs covered by a format 2 Coverage table</code-title>
  { int rangeCount = getuint16 (coverageOffset + 2);

    int lastRangeStart = getGlyphID (coverageOffset + 4 + 6*(rangeCount-1));
    int lastRangeEnd = getGlyphID (coverageOffset + 4 + 6*(rangeCount-1) + 2);
    int lastRangeStartCI = getuint16 (coverageOffset + 4 + 6*(rangeCount-1) + 4);
    int glyphCount = lastRangeStartCI + (lastRangeEnd - lastRangeStart) + 1;

    int[] glyphs = new int [glyphCount];

    for (int r = 0; r &lt; rangeCount; r++) {
      int start = getGlyphID (coverageOffset + 4 + 6*r);
      int stop = getGlyphID (coverageOffset + 4 + 6*r + 2);
      int ci = getuint16 (coverageOffset + 4 + 6*r + 4);
      for (int g = start; g &lt;= stop; g++) {
        glyphs [ci] = g;
        ci++; }}

    return glyphs; }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Class Definition Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>In CommonType Layout, index values identify glyphs. For
          efficiency and ease of representation, a font developer can
          group glyph indices to form glyph classes. Class assignments
          vary in meaning from one lookup subtable to another. For
          example, in the <ottable>GSUB</ottable> and
          <ottable>GPOS</ottable> tables, classes are used to describe
          glyph contexts. <ottable>GDEF</ottable> tables also use the
          idea of glyph classes.</para>

        <para>Consider a substitution action that replaces only the
          lowercase ascender glyphs in a glyph string. To more easily
          describe the appropriate context for the substitution, the
          font developer might divide the font's lowercase glyphs into
          two classes, one that contains the ascenders and one that
          contains the glyphs without ascenders.</para>

        <para>A font developer can assign any glyph to any class, each
          identified with an integer called a class value. A Class
          Definition table (ClassDef) groups glyph indices by class,
          beginning with Class 1, then Class 2, and so on. All glyphs
          not assigned to a class fall into Class 0. Within a given
          class definition table, each glyph in the font belongs to
          exactly one class.</para>

        <para>The ClassDef table can have either of two formats: one
          that assigns a range of consecutive glyph indices to
          different classes, or one that puts groups of consecutive
          glyph indices into the same class.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

	<para>In many cases, we do not care to specify the format
	  which should be used to represent a class definition, but instead
	  would prefer the compiler to figure out the best
	  representation. In that case, the classes are just listed:</para>

<code-fragment id="schema">
  <code-title>classDefTable, any format</code-title>
  classDefTable |=
    attribute format { &quot;any&quot; },
    element class {
      attribute classID { text },
      attribute glyphs { text }
    }*

  standaloneClassDefTable =
    element classDefTable { attribute id { text }, classDefTable }

  classDefTableOffset = attribute name { text } | classDefTable
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment package="com.adobe.aots.CommonType" class="ClassdefTableBlock">
package com.adobe.aots.CommonType;

public class ClassdefTableBlock extends Block {
    public ClassdefTableBlock (int size, int referenceCount) {
      super (size, referenceCount);
    }

    public int classCount;
  }
</code-fragment>

<code-fragment id="layouttable.methods">
  public ClassdefTableBlock classdefFromXML (Element classdef, Element table,
                                             Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = classdef.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        classdef = resolveXMLid (table, name); }}

    { ClassdefTableBlock cached = (ClassdefTableBlock) blockCache.get (classdef);
      if (cached != null) {
        return cached; }}

    String format = classdef.getAttribute (&quot;format&quot;);


    ClassdefTableBlock me = null;

    if (&quot;any&quot;.equals (format)) {
      me = classdefFormatAnyFromXML (classdef, table, blockCache); }
    else if (&quot;1&quot;.equals (format)) {
      me = classdefFormat1FromXML (classdef, table, blockCache); }
    else if (&quot;2&quot;.equals (format)) {
      me = classdefFormat2FromXML (classdef, table, blockCache); }
    else {
      /* cannot get there on valid document */
      throw new InvalidFontException
                 (&quot;invalid classdef format (&quot; + format + &quot;)&quot;); }

    blockCache.put (classdef, me);
    return me;
  }


  public ClassdefTableBlock classdefFormatAnyFromXML (Element classdef,
                                                      Element table,
                                                      Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    /*TODO: generate a format 1 if smaller; generate a better format2 */
    /*generate a format 2 */

    int highestClass = 0;

    NodeList classes = classdef.getChildNodes ();
    java.util.SortedMap&lt;Integer, Integer&gt; map
         = new java.util.TreeMap&lt;Integer, Integer&gt; ();
    for (int i = 0; i &lt; classes.getLength (); i++) {
      Element aclass = (Element) classes.item (i);
      int classID = Integer.parseInt (aclass.getAttribute (&quot;classID&quot;));
      int [] glyphs = getGlyphs (aclass.getAttribute (&quot;glyphs&quot;));
      if (glyphs.length != 0) {
        if (classID &gt; highestClass) {
	  highestClass = classID; }}
      if (classID != 0) {
        for (int j = 0; j &lt; glyphs.length; j++) {
          map.put (glyphs [j], classID); }}}

    Integer[] glyphs = map.keySet ().toArray (new Integer [0]);

    ClassdefTableBlock me = new ClassdefTableBlock (4 + 6 * glyphs.length, 0);
    me.classCount = highestClass + 1;
    me.setuint16 (0, 2);
    me.setuint16 (2, glyphs.length);
    for (int i = 0; i &lt; glyphs.length; i++) {
      me.setGlyphID (4 + 6*i, glyphs [i].intValue ());
      me.setGlyphID (4 + 6*i + 2, glyphs [i].intValue ());
      me.setuint16 (4 + 6*i + 4, map.get (glyphs [i])); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="layouttable.methods">
  public void classDefTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
  }

  public void classDefTableOffsetToXML (DecompilerConfig conf, int offset,
                                        int[] counts,
                                        String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;classDefTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      classDefTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void classDefTableToXML (DecompilerConfig conf, int offset,
                                  int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;classDefTable_&quot; + Integer.toHexString (offset));
      classDefTableToXMLEmit (conf, offset, counts, &quot;classDefTable&quot;, at);
      counts [offset] = 0; }
  }

  public void classDefTableToXMLEmit (DecompilerConfig conf, int offset,
                                      int[] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    switch (getuint16 (offset)) {
      <code-include linkend="LayoutTable.classDefTableToXMLEmit.cases"/>
      default: {
        throw new InvalidFontException (&quot;illegal classdef format at offset &quot;
                                        + offset + &quot;: &quot; + getuint16 (offset)); }}
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="layouttable.methods">
  <code-title>Method to find the class index of a glyph</code-title>

  protected int classIndex (int glyph, int offset)
     throws InvalidFontException {

    if (glyph == -1) {
      return -1; }

    int format = getuint16 (offset);

    switch (format) {
      case 1: { <code-include linkend="sub_classIndex1"/> }
      case 2: { <code-include linkend="sub_classIndex2"/> }
      default: throw new InvalidFontException (); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

	<para>To test classDef table, we use contextual GSUB tests.
	Here are some base lookups:</para>

<code-fragment id="layout.test.classdef">
  <code-title>?</code-title>
   <lookup id="inc_by_3" type="1">
     <singleSubst format="1">
	  <coverage format="any" glyphs="0:99"/>
	  <delta v="3"/>
     </singleSubst>
   </lookup>

   <lookup id="inc_by_4" type="1">
     <singleSubst format="1">
	  <coverage format="any" glyphs="0:99"/>
	  <delta v="4"/>
     </singleSubst>
   </lookup>

   <lookup id="inc_by_5" type="1">
     <singleSubst format="1">
	  <coverage format="any" glyphs="0:99"/>
	  <delta v="5"/>
     </singleSubst>
   </lookup>
</code-fragment>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Class Definition Table Format 1</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The first class definition format (ClassDefFormat1)
          specifies a range of consecutive glyph indices and a list of
          corresponding glyph class values. This table is useful for
          assigning each glyph to a different class because the glyph
          indices in each class are not grouped together.</para>

        <para>A ClassDef Format 1 table begins with a format
          identifier (ClassFormat). The range of glyph indices
          (GlyphIDs) covered by the table is identified by two values:
          the GlyphID of the first glyph (StartGlyph), and the number
          of consecutive GlyphIDs (including the first one) that will
          be assigned class values (GlyphCount). The ClassValueArray
          lists the class value assigned to each GlyphID, starting
          with the class value for StartGlyph and following the same
          order as the GlyphIDs. Any glyph not included in the range
          of covered GlyphIDs automatically belongs to Class 0.</para>

        <para>Example 7 at the end of this chapter uses Format 1 to
          assign class values to the lowercase, x-height, ascender,
          and descender glyphs in a font.</para>

        <otformat>
          <title>ClassDefFormat1 table: Class array</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassFormat</otfieldname>
            <otfielddesc>Format identifier-format = 1</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>StartGlyph</otfieldname>
            <otfielddesc>First GlyphID of the ClassValueArray</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>GlyphCount</otfieldname>
            <otfielddesc>Size of the ClassValueArray</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassValueArray [GlyphCount]</otfieldname>
            <otfielddesc>Array of Class Values-one per GlyphID</otfielddesc>
          </otfield>
        </otformat>

      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>classDefTable, format 1</code-title>
  classDefTable |=
    attribute format { &quot;1&quot; },
    attribute startGlyph { text },
    attribute classes    { text }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="layouttable.methods">
  public ClassdefTableBlock classdefFormat1FromXML (Element classdef,
                                                    Element table,
                                                    Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    int startGlyph = Integer.parseInt (classdef.getAttribute (&quot;startGlyph&quot;));
    int[] classes = parseIntList (classdef.getAttribute (&quot;classes&quot;));

    ClassdefTableBlock me = new ClassdefTableBlock (6 + 2 * classes.length, 0);

    me.classCount = 0;
    for (int i = 0; i &lt; classes.length; i++) {
      me.classCount = Math.max (me.classCount, classes [i] + 1); }

    if (me.classCount == 0) {
      me.classCount = 1; } // we always have at least class 0.
    me.setuint16 (0, 1);
    me.setuint16 (2, startGlyph);
    me.setuint16 (4, classes.length);
    for (int i = 0; i &lt; classes.length; i++) {
      me.setGlyphID (6 + 2*i, classes [i]); }

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="LayoutTable.classDefTableToXMLEmit.cases">
  case 1: {
    int startGlyph = getGlyphID (offset + 2);
    int glyphCount = getuint16 (offset + 4);

    if (conf.preciseClassDefFormat) {
      at.addAttribute (&quot;&quot;, &quot;format&quot;, &quot;format&quot;, &quot;CDATA&quot;, &quot;1&quot;);
      at.addAttribute (&quot;&quot;, &quot;startGlyph&quot;, &quot;startGlyph&quot;, &quot;CDATA&quot;, &quot;&quot; + startGlyph);
      StringBuilder sb = new StringBuilder ();
      for (int i = 0; i &lt; glyphCount; i++) {
        sb.append (&quot; &quot;);
        sb.append (getuint16 (offset + 6 + 2*i)); }
      at.addAttribute (&quot;&quot;, &quot;classes&quot;, &quot;classes&quot;, &quot;CDATA&quot;, sb.toString ());

      conf.ch.element (element, at); }

    else {
      at.addAttribute (&quot;&quot;, &quot;format&quot;, &quot;format&quot;, &quot;CDATA&quot;, &quot;any&quot;);
      conf.ch.startElement (element, at); {

        StringBuilder sb = new StringBuilder ();

        // there are at most glyphCount classes
        for (int cl = 1; cl &lt;= glyphCount; cl++) {
          for (int glyph = 0; glyph &lt; glyphCount; glyph++) {
            if (cl == getuint16 (offset + 6 + 2*glyph)) {
              glyphToXML (conf, sb, startGlyph + glyph); }}

          if (sb.length () != 0) {
            at = new AttributesImpl ();
            at.addAttribute (&quot;&quot;, &quot;classID&quot;, &quot;classID&quot;, &quot;CDATA&quot;, &quot;&quot; + cl);
            at.addAttribute (&quot;&quot;, &quot;glyphs&quot;, &quot;glyphs&quot;, &quot;CDATA&quot;, sb.toString ());
            conf.ch.element (&quot;class&quot;, at);
            sb.setLength (0); }}
        conf.ch.endElement (element); }}

    break; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="sub_classIndex1">
  <code-title>Find class in format 1 and return it</code-title>
  { int startGlyph = getuint16 (offset + 2);
    int glyphCount = getuint16 (offset + 4);

    if (startGlyph &lt;= glyph &amp;&amp; glyph &lt; startGlyph + glyphCount) {
      return getuint16 (offset + 6 + (glyph - startGlyph)*2); }

    return 0; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

	<para>Our first test is a single range covering glyphs 18:20,
	which are incremented by 5.</para>

<aots:test-font id="classdef1_font1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <code-include linkend="layout.test.classdef"/>
      <lookup id="lookup.test" type="5">
        <contextual format="2">
          <coverage glyphs="0:99" format="any"/>
          <classDef format="1" startGlyph="18" classes="1 1 1"/>
	  <pattern in="1">
	    <apply pos="0" lookup="inc_by_5"/>
	  </pattern>
        </contextual>
      </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="classdef1_single_range" font="classdef2_font1" inputs="17, 18, 19, 20, 21" outputs="17, 23, 24, 25, 21"/>

	  <para>Next, we try the case where one class (1) has no
	  glyphs. Note that we include a transformation for that
	  class, to make sure that no glyphs are matched with that
	  class.</para>

<aots:test-font id="classdef1_font2">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <code-include linkend="layout.test.classdef"/>

      <lookup id="lookup.test" type="5">
        <contextual format="2">
          <coverage glyphs="0:99" format="any"/>
          <classDef format="1" startGlyph="18" classes="2 2 2"/>

	  <pattern in="1">
	    <apply pos="0" lookup="inc_by_4"/>
	  </pattern>
	  <pattern in="2">
	    <apply pos="0" lookup="inc_by_5"/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="classdef1_empty_class" font="classdef1_font2" inputs="17, 18, 19, 20, 21" outputs="17, 23, 24, 25, 21"/>

	  <para>Our most complex case has with multiple
	  ranges. Two ranges are assigned to class 2, and a range is
	  assigned to class 0.</para>

<aots:test-font id="classdef1_font3">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <code-include linkend="layout.test.classdef"/>

      <lookup id="lookup.test" type="5">
        <contextual format="2">
          <coverage glyphs="0:99" format="any"/>
          <classDef format="1" startGlyph="18" classes="2 2 2 0 1 1 1 0 0 0 0 2 0 0 0 1 1"/>
	  <pattern in="0">
	    <apply pos="0" lookup="inc_by_3"/>
	  </pattern>
	  <pattern in="1">
	    <apply pos="0" lookup="inc_by_4"/>
	  </pattern>
	  <pattern in="2">
	    <apply pos="0" lookup="inc_by_5"/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="classdef1_multiple_ranges" font="classdef1_font3" inputs="17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36" outputs="20, 23, 24, 25, 24, 26, 27, 28, 28, 29, 30, 31, 34, 33, 34, 35, 37, 38, 38, 39"/>

	  <para>The empty definition.</para>

<aots:test-font id="classdef1_font4">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <code-include linkend="layout.test.classdef"/>

      <lookup id="lookup.test" type="5">
        <contextual format="2">
          <coverage glyphs="0:99" format="any"/>
          <classDef format="1" startGlyph="18" classes=""/>

	  <pattern in="1">
	    <apply pos="0" lookup="inc_by_4"/>
	  </pattern>
	  <pattern in="2">
	    <apply pos="0" lookup="inc_by_5"/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="classdef1_empty" font="classdef1_font4" inputs="17, 18, 19, 20, 21" outputs="17, 18, 19, 20, 21"/>

      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Class Definition Table Format 2</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The second class definition format (ClassDefFormat2)
          defines multiple groups of glyph indices that belong to the
          same class. Each group consists of a discrete range of glyph
          indices in consecutive order (ranges cannot overlap).</para>

        <para>The ClassDef Format 2 table contains a format identifier
          (ClassFormat), a count of ClassRangeRecords that define the
          groups and assign class values (ClassRangeCount), and an
          array of ClassRangeRecords ordered by the GlyphID of the
          first glyph in each record (ClassRangeRecord).</para>

        <para>Each ClassRangeRecord consists of a Start glyph index,
          an End glyph index, and a Class value. All GlyphIDs in a
          range, from Start to End inclusive, constitute the class
          identified by the Class value. Any glyph not covered by a
          ClassRangeRecord is assumed to belong to Class 0.</para>

        <para>Example 8 at the end of this chapter uses Format 2 to
          assign class values to four types of glyphs in the Arabic
          script.</para>

        <otformat>
          <title>ClassDefFormat2 table: Class ranges</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassFormat</otfieldname>
            <otfielddesc>Format identifier-format = 2</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>ClassRangeCount</otfieldname>
            <otfielddesc>Number of ClassRangeRecords</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>struct</otfieldtype>
            <otfieldname>ClassRangeRecord
              [ClassRangeCount]</otfieldname>
            <otfielddesc>Array of ClassRangeRecords-ordered by Start
              GlyphID</otfielddesc>
          </otfield>
        </otformat>

        <otformat>
          <title>ClassRangeRecord</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>Start</otfieldname>
            <otfielddesc>First GlyphID in the range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>GlyphID</otfieldtype>
            <otfieldname>End</otfieldname>
            <otfielddesc>Last GlyphID in the range</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>Class</otfieldname>
            <otfielddesc>Applied to all glyphs in the
              range</otfielddesc>
          </otfield>
        </otformat>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>classDefTable, format 2</code-title>
  classDefTable |=
    attribute format { &quot;2&quot; },
    element range {
      attribute start { text },
      attribute end   { text },
      attribute class { text }
    }*
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="layouttable.methods">
  public ClassdefTableBlock classdefFormat2FromXML (Element classdef,
                                                    Element table,
                                                    Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    NodeList ranges = classdef.getChildNodes ();
    int nbRanges = ranges.getLength ();

    int lastClass = 0;

    ClassdefTableBlock me = new ClassdefTableBlock (4 + 6 * nbRanges, 0);
    me.setuint16 (0, 2);
    me.setuint16 (2, nbRanges);
    for (int i = 0; i &lt; nbRanges; i++) {
      Element range = (Element) ranges.item (i);
      me.setGlyphID (4 + 6*i,  Integer.parseInt (range.getAttribute (&quot;start&quot;)));
      me.setGlyphID (4 + 6*i+2, Integer.parseInt (range.getAttribute (&quot;end&quot;)));
      int classID = Integer.parseInt (range.getAttribute (&quot;class&quot;));
      if (classID &gt; lastClass) {
        lastClass = classID; }
      me.setuint16 (4 + 6*i+4, classID); }

    me.classCount = lastClass + 1;
    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="LayoutTable.classDefTableToXMLEmit.cases">
  case 2: {
    int classRangeCount = getuint16 (offset + 2);

    if (conf.preciseClassDefFormat) {
      at.addAttribute (&quot;&quot;, &quot;format&quot;, &quot;format&quot;, &quot;CDATA&quot;, &quot;2&quot;);
      conf.ch.startElement (element, at); {
        int o = offset + 4;
        for (int r = 0; r &lt; classRangeCount; r++) {
          at = new AttributesImpl ();
          at.addAttribute (&quot;&quot;, &quot;start&quot;, &quot;start&quot;, &quot;CDATA&quot;, &quot;&quot; + getGlyphID (o));
          at.addAttribute (&quot;&quot;, &quot;end&quot;, &quot;end&quot;, &quot;CDATA&quot;, &quot;&quot; + getGlyphID (o + 2));
          at.addAttribute (&quot;&quot;, &quot;class&quot;, &quot;class&quot;, &quot;CDATA&quot;,
                           &quot;&quot; + getuint16 (o + 4));
          conf.ch.element (&quot;range&quot;, at);
          o += 6; }

        conf.ch.endElement (element); }}

    else {
      at.addAttribute (&quot;&quot;, &quot;format&quot;, &quot;format&quot;, &quot;CDATA&quot;, &quot;any&quot;);
      conf.ch.startElement (element, at); {

        int lastClass = 0;
        for (int r = 0; r &lt; classRangeCount; r++) {
          int thisClass = getuint16 (offset + 4 + 6*r + 4);
          if (thisClass &gt; lastClass) {
            lastClass = thisClass; }}

// TODO: need to combine ranges; e.g. if
//    {range start='1' end='10' class=2'}
//    {range start='11' end='20' class='2'}
// generate a single range &quot;1:20&quot;
// probably involves having a method to return the glyphs in a class
// also need to combine with a seperate method to form the
// text representation of a list of glyphs, so that names can be emitted.

        StringBuilder sb = new StringBuilder ();
        for (int c = 1; c &lt;= lastClass; c++) {
          for (int r = 0; r &lt; classRangeCount; r++) {
            if (getuint16 (offset + 4 + 6*r + 4) == c) {
              int start = getGlyphID (offset + 4 + 6*r);
              int stop = getGlyphID (offset + 4 + 6*r + 2);
              if (conf.glyphNames != null) {
	        for (int i = start; i &lt; stop + 1; i++) {
                  glyphToXML (conf, sb, i); }}
              else {
                sb.append (&quot; &quot;);
		sb.append (start);
		if (start != stop) {
		  sb.append (&quot;:&quot;);
		  sb.append (stop); }}}}
          if (sb.length () != 0) {
            at = new AttributesImpl ();
            at.addAttribute (&quot;&quot;, &quot;classID&quot;, &quot;classID&quot;, &quot;CDATA&quot;, &quot;&quot; + c);
            at.addAttribute (&quot;&quot;, &quot;glyphs&quot;, &quot;glyphs&quot;, &quot;CDATA&quot;, sb.toString ());
            sb.setLength (0);
            conf.ch.element (&quot;class&quot;, at); }}

        conf.ch.endElement (element); }}

    break; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

<code-fragment id="sub_classIndex2">
  <code-title>Find class index in format 2 and return it</code-title>
  { int rangeCount = getuint16 (offset + 2);

    int min = 0;
    int max = rangeCount - 1;

    while (min &lt;= max) {
      int mid = (min + max) / 2;
      int start = getuint16 (offset + 4 + mid*6);
      int stop = getuint16 (offset + 4 + mid*6 + 2);

      if (glyph &lt; start) {
        max = mid - 1; }
      else if (stop &lt; glyph) {
        min = mid + 1; }
      else {
        return getuint16 (offset + 4 + mid*6 + 4); }}

    return 0; }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="test-suite">
        <title>Implementation Test</title>

	<para>Our first test is a single range covering glyphs 18:20,
	which are incremented by 5.</para>

<aots:test-font id="classdef2_font1">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <code-include linkend="layout.test.classdef"/>

      <lookup id="lookup.test" type="5">
        <contextual format="2">
          <coverage glyphs="0:99" format="any"/>
          <classDef format="2">
             <range start="18" end="20" class="1"/>
          </classDef>

	  <pattern in="1">
	    <apply pos="0" lookup="inc_by_5"/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="classdef2_single_range" font="classdef2_font1" inputs="17, 18, 19, 20, 21" outputs="17, 23, 24, 25, 21"/>

	  <para>Next, we try the case where one class (1) has no
	  glyphs. Note that we include a transformation for that
	  class, to make sure that no glyphs are matched with that
	  class.</para>

<aots:test-font id="classdef2_font2">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <code-include linkend="layout.test.classdef"/>
      <lookup id="lookup.test" type="5">
        <contextual format="2">
          <coverage glyphs="0:99" format="any"/>
          <classDef format="2">
             <range start="18" end="20" class="2"/>
          </classDef>

	  <pattern in="1">
	    <apply pos="0" lookup="inc_by_4"/>
	  </pattern>
	  <pattern in="2">
	    <apply pos="0" lookup="inc_by_5"/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="classdef2_empty_class" font="classdef2_font2" inputs="17, 18, 19, 20, 21" outputs="17, 23, 24, 25, 21"/>

	  <para>Our most complex case has multiple ranges. Two ranges
	  are assigned to class 2, and a range is assigned to class
	  0.</para>

<aots:test-font id="classdef2_font3">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <code-include linkend="layout.test.classdef"/>

      <lookup id="lookup.test" type="5">
        <contextual format="2">
          <coverage glyphs="0:99" format="any"/>
          <classDef format="2">
             <range start="18" end="20" class="2"/>
	     <range start="22" end="24" class="1"/>
	     <range start="26" end="28" class="0"/>
	     <range start="29" end="29" class="2"/>
	     <range start="33" end="34" class="1"/>
          </classDef>

	  <pattern in="0">
	    <apply pos="0" lookup="inc_by_3"/>
	  </pattern>
	  <pattern in="1">
	    <apply pos="0" lookup="inc_by_4"/>
	  </pattern>
	  <pattern in="2">
	    <apply pos="0" lookup="inc_by_5"/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="classdef2_multiple_ranges" font="classdef2_font3" inputs="17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36" outputs="20, 23, 24, 25, 24, 26, 27, 28, 28, 29, 30, 31, 34, 33, 34, 35, 37, 38, 38, 39"/>

	  <para>The empty definition.</para>

<aots:test-font id="classdef2_font4">
  <base-font name="base.otf"/>
  <GSUB major="1" minor="0">
    <code-include linkend="testfonts.gsub.scripts_features"/>
    <lookupList>
      <code-include linkend="layout.test.classdef"/>

      <lookup id="lookup.test" type="5">
        <contextual format="2">
          <coverage glyphs="0:99" format="any"/>
          <classDef format="2"/>

	  <pattern in="1">
	    <apply pos="0" lookup="inc_by_4"/>
	  </pattern>
	  <pattern in="2">
	    <apply pos="0" lookup="inc_by_5"/>
	  </pattern>
      </contextual>
    </lookup>
    </lookupList>
  </GSUB>
</aots:test-font>

          <aots:gsub-test id="classdef2_empty" font="classdef2_font4" inputs="17, 18, 19, 20, 21" outputs="17, 18, 19, 20, 21"/>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Device Tables</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Glyphs in a font are defined in design units specified
          by the font developer. Font scaling increases or decreases a
          glyph's size and rounds it to the nearest whole
          pixel. However, precise glyph positioning often requires
          adjustment of these scaled and rounded values. Hinting,
          applied to points in the glyph outline, is an effective
          solution to this problem, but it may require the font
          developer to redesign or re-hint glyphs.</para>

        <para>Another solution-used by the <ottable>GPOS</ottable>,
          <ottable>BASE</ottable>, <ottable>JSTF</ottable>, and
          <ottable>GDEF</ottable> tables-is to use a Device table to
          specify correction values to adjust the scaled design
          units. A Device table applies the correction values to the
          range of sizes identified by StartSize and EndSize, which
          specify the smallest and largest pixel-per-em (ppem) sizes
          needing adjustment.</para>

        <para>Because the adjustments often are very small (a pixel or
          two), the correction can be compressed into a 2-, 4-, or
          8-bit representation per size. Two bits can represent a
          number in the range {-2, -1, 0, or 1}, four bits can
          represent a number in the range {-8 to 7}, and eight bits
          can represent a number in the range {-128 to 127}. The
          Device table identifies one of three data formats-signed 2-,
          4,- or 8-bit values-for the adjustment values
          (DeltaFormat). A single Device table provides delta
          information for one coordinate at a range of sizes.</para>

        <informaltable>
          <tgroup cols="3">
            <colspec colwidth="8pc"/>
            <colspec colwidth="8pc"/>
            <colspec colwidth="14pc"/>
            <thead>
              <row>
                <entry>Type</entry>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>1</entry>
                <entry>2</entry>
                <entry>Signed 2-bit value, 8 values per uint16</entry>
              </row>
              <row>
                <entry>2</entry>
                <entry>4</entry>
                <entry>Signed 4-bit value, 4 values per uint16</entry>
              </row>
              <row>
                <entry>3</entry>
                <entry>8</entry>
                <entry>Signed 8-bit value, 2 values per uint16</entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>


        <para>The 2-, 4-, or 8-bit signed values are packed into
          uint16's most significant bits first. For example, using a
          DeltaFormat of 2 (4-bit values), an array of values equal to
          {1, 2, 3, -1} would be represented by the DeltaValue
          0x123F.</para>

        <para>The DeltaValue array lists the number of pixels to
          adjust specified points on the glyph, or the entire glyph,
          at each ppem size in the targeted range. In the array, the
          first index position specifies the number of pixels to add
          or subtract from the coordinate at the smallest ppem size
          that needs correction, the second index position specifies
          the number of pixels to add or subtract from the coordinate
          at the next ppem size, and so on for each ppem size in the
          range.</para>

        <para>Example 9 at the end of this chapter uses a Device table
          to define the minimum extent value for a math script.</para>

        <otformat>
          <title>Device table</title>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>StartSize</otfieldname>
            <otfielddesc>Smallest size to correct-in
              ppem</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>2</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>EndSize</otfieldname>
            <otfielddesc>Largest size to correct-in ppem</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>DeltaFormat</otfieldname>
            <otfielddesc>Format of DeltaValue array data: 1, 2, or
              3</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>6</otfieldoffs>
            <otfieldtype>uint16</otfieldtype>
            <otfieldname>DeltaValue []</otfieldname>
            <otfielddesc>Array of compressed data</otfielddesc>
          </otfield>
        </otformat>
      </section>


      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
  <code-title>deviceTable</code-title>
  deviceTable =
    attribute startSize    { text },
    attribute endSize      { text },
    attribute deltaFormat  { text },
    attribute values       { text }

  standaloneDeviceTable =
    element deviceTable { attribute id { text }, deviceTable }

  deviceTableOffset = attribute name { text } | deviceTable
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="layouttable.methods">
  protected Block deviceTableFromXML (Element t, Element table,
                                      Map&lt;Element, Block&gt; blockCache)
      throws InvalidFontException, UnsupportedFontException {

    { String name = t.getAttribute (&quot;name&quot;);
      if (name != null &amp;&amp; ! &quot;&quot;.equals (name)) {
        t = resolveXMLid (table, name); }}

    { Block cached = blockCache.get (t);
      if (cached != null) {
        return cached; }}

    int startSize = Integer.parseInt (t.getAttribute (&quot;startSize&quot;));
    int endSize = Integer.parseInt (t.getAttribute (&quot;endSize&quot;));
    int[] values = parseIntList (t.getAttribute (&quot;values&quot;));

    if (endSize &lt; startSize) {
      warning (&quot;device/@endSize must be bigger than device/@startSize&quot;); }

    if (values.length != (endSize - startSize + 1)) {
      warning (&quot;device/@values must have one value for each ppem &quot;
               + &quot;between &quot; + startSize + &quot; and &quot; + endSize
               + &quot; (included)&quot; ); }

    int minValue = 0;
    int maxValue = 0;
    for (int i = 0; i &lt; values.length; i++) {
      minValue = Math.min (minValue, values [i]);
      maxValue = Math.max (maxValue, values [i]); }

    int[] min =             {0,  -2,  -8, -128};
    int[] max =             {0,   1,   7,  127};
    int[] valuesPerUint =   {0,   8,   4,    2};
    int[] bitsPerValue =    {0,   2,   4,    8};
    int[] mask =            {0, 0x3, 0xF, 0xFF};

    int minFormat = -1;
    for (int i = 1; i &lt; min.length; i++) {
      if (min[i] &lt;= minValue &amp;&amp; maxValue &lt;= max[i]) {
        minFormat = i;
        break; }}
    if (minFormat == -1) {
      warning (&quot;device/@value must be in the range [-128, +127];&quot;
               + &quot; values will be truncated&quot;);
      minFormat = 3; }

    int format;
    String f = t.getAttribute (&quot;format&quot;);
    if (f != null &amp;&amp; ! &quot;&quot;.equals (f)) {
      int desiredFormat = Integer.parseInt (f);
      if (desiredFormat &lt; minFormat) {
        warning (&quot;device/@format is too small; will use &quot; + minFormat);
        format = minFormat; }
      else {
        format = desiredFormat; }}
    else {
      format = minFormat; }

    int nbUints = (values.length + valuesPerUint [format] - 1)
                  / valuesPerUint [format];
    int nbValues = valuesPerUint [format] * nbUints;

    if (nbValues != values.length) {
      int[] temp = new int [nbValues];
      System.arraycopy (values, 0, temp, 0, values.length);
      for (int i = values.length; i &lt; nbValues; i++) {
        temp [i] = 0; }
      values = temp; }

    Block me = new Block (6 + 2*nbUints, 0);
    me.setuint16 (0, startSize);
    me.setuint16 (2, endSize);
    me.setuint16 (4, format);

    for (int i = 0; i &lt; nbValues; i += valuesPerUint [format]) {
      int v = 0;
      for (int j = 0; j &lt; valuesPerUint [format]; j++) {
        v = (v &lt;&lt; bitsPerValue [format])
            | (values [i + j] &amp; mask [format]); }
      me.setuint16 (6 + 2 *(i / valuesPerUint [format]), v); }

    blockCache.put (t, me);

    return me;
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="layouttable.methods">
  public void deviceTableToXMLCount (int offset, int[] counts) {
    counts [offset]++;
  }

  public void deviceTableOffsetToXML (DecompilerConfig conf, int offset,
                                      int[] counts,
                                      String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] != 1) {
      at.addAttribute (&quot;&quot;, &quot;name&quot;, &quot;name&quot;, &quot;CDATA&quot;,
                       &quot;deviceTable_&quot; + Integer.toHexString (offset));
      conf.ch.element (element, at); }

    else {
      deviceTableToXMLEmit (conf, offset, counts, element, at); }
  }

  public void deviceTableToXML (DecompilerConfig conf, int offset,
                                int[] counts)
      throws org.xml.sax.SAXException, InvalidFontException {

    if (counts [offset] &gt; 1) {
      AttributesImpl at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;id&quot;, &quot;id&quot;, &quot;CDATA&quot;,
                       &quot;deviceTable_&quot; + Integer.toHexString (offset));
      deviceTableToXMLEmit (conf, offset, counts, &quot;deviceTable&quot;, at);
      counts [offset] = 0; }
  }

  public void deviceTableToXMLEmit (DecompilerConfig conf, int offset,
                                    int[] counts,
                                    String element, AttributesImpl at)
      throws org.xml.sax.SAXException, InvalidFontException {

    int startSize = getuint16 (offset);
    int endSize = getuint16 (offset + 2);
    int format = getuint16 (offset + 4);

    at.addAttribute (&quot;&quot;, &quot;startSize&quot;, &quot;startSize&quot;, &quot;CDATA&quot;, &quot;&quot; + startSize);
    at.addAttribute (&quot;&quot;, &quot;endSize&quot;, &quot;endSize&quot;, &quot;CDATA&quot;, &quot;&quot; + endSize);
    at.addAttribute (&quot;&quot;, &quot;deltaFormat&quot;, &quot;deltaFormat&quot;, &quot;CDATA&quot;, &quot;&quot; + format);

    StringBuilder s = new StringBuilder ();

    int[] bitsPerValue  = {0, 2,   4,   8};
    int[] bitMask       = {0, 0x3, 0xf, 0xff};
    int[] maxValue      = {0, 1,   7,   127};

    offset += 6;
    int bitsLeft = 0;
    int word = 0;

    for (int i = startSize; i &lt;= endSize; i++) {
      if (bitsLeft == 0) {
        word = getuint16 (offset);
        bitsLeft = 16;
        offset += 2; }

      int value = (word &gt;&gt; (bitsLeft - bitsPerValue [format])) &amp; bitMask [format];
      if (value &gt; maxValue [format]) {
        value -= (bitMask [format] + 1); }

      bitsLeft -= bitsPerValue [format];

      s.append (&quot; &quot; + value); }
    at.addAttribute (&quot;&quot;, &quot;values&quot;, &quot;values&quot;, &quot;CDATA&quot;, s.toString ());

    conf.ch.element (element, at);
  }
</code-fragment>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Common Table Examples</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The rest of this chapter describes and illustrates
          examples of all the common table formats. All the examples
          reflect unique parameters, but the samples provide a useful
          reference for building tables specific to other
          situations.</para>

        <para>The examples have three columns showing hex data,
          source, and comments.</para>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 1: ScriptList Table and ScriptRecords</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 1 illustrates a ScriptList table and
          ScriptRecord definitions for a Japanese font with multiple
          scripts: Han Ideographic, Kana, and Latin. Each script has
          script-specific behavior.</para>

        <otexample>
          <title>Example 1</title>
          <otexline>
            <otexdata/>
            <otexsrc>ScriptList</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>TheScriptList</otexsrc>
            <otexcom>ScriptList table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ScriptCount. ScriptRecord[0],in alphabetical
                  order by ScriptTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>68616E69</otexdata>
            <otexsrc>&quot;hani&quot;</otexsrc>
            <otexcom>ScriptTag, Han Ideographic script</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>HanIScriptTable</otexsrc>
            <otexcom>offset to Script table ScriptRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6B616E61</otexdata>
            <otexsrc>&quot;kana&quot;</otexsrc>
            <otexcom>ScriptTag, Hiragana and Katakana
                  scripts</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>KanaScriptTable</otexsrc>
            <otexcom>offset to Script table ScriptRecord[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6C61746E</otexdata>
            <otexsrc>&quot;latn&quot;</otexsrc>
            <otexcom>ScriptTag, Latin script</otexcom>
          </otexline>
          <otexline>
            <otexdata>001C</otexdata>
            <otexsrc>LatinScriptTable</otexsrc>
            <otexcom>offset to Script table</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 2: Script Table, LangSysRecord, and LangSys Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>


        <para>Example 2 illustrates the Script table, LangSysRecord,
          and LangSys table definitions for the Arabic script and the
          Urdu language system. The default LangSys table defines
          three default Arabic script features used to replace certain
          glyphs in words with their proper initial, medial, and final
          glyph forms. These contextual substitutions are invariant
          and occur in all language systems that use the Arabic
          script.</para>

        <para>Many alternative glyphs in the Arabic script have
          language-specific uses. For instance, the Arabic, Farsi, and
          Urdu language systems use different glyphs for numerals. To
          maintain character-set compatibility, the Unicode standard
          includes separate character codes for the Arabic and Farsi
          numeral glyphs. However, the standard uses the same
          character codes for Farsi and Urdu numerals, even though
          three of the Urdu glyphs (4, 6, and 7) differ from the Farsi
          glyphs. To access and display the proper glyphs for the Urdu
          numerals, users of the text-processing client must enter the
          character codes for the Farsi numerals. Then the
          text-processing client uses a required CommonType Layout glyph
          substitution feature, defined in the Urdu LangSys table, to
          access the correct Urdu glyphs for the 4, 6, and 7
          numerals.</para>

        <para>Note that the Urdu LangSys table repeats the default
          script features. This repetition is necessary because the
          Urdu language system also uses alternative glyphs in the
          initial, medial, and final glyph positions in words.</para>

        <otexample>
          <title>Example 2</title>
          <otexline>
            <otexdata/>
            <otexsrc>Script</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>ArabicScriptTable</otexsrc>
            <otexcom>Script table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000A</otexdata>
            <otexsrc>DefLangSys</otexsrc>
            <otexcom>offset to DefaultLangSys table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LangSysCount LangSysRecord[0], in alphabetical
                  order by LangSysTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>55524420</otexdata>
            <otexsrc>&quot;URD &quot;</otexsrc>
            <otexcom>LangSysTag, Urdu language</otexcom>
          </otexline>
          <otexline>
            <otexdata>0016</otexdata>
            <otexsrc>UrduLangSys</otexsrc>
            <otexcom>offset to LangSys table for Urdu</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>LangSys</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>DefLangSys</otexsrc>
            <otexcom>default LangSys table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>LookupOrder, reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>FFFF</otexdata>
            <otexsrc>0xFFFF</otexsrc>
            <otexcom>ReqFeatureIndex, no required features</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>FeatureCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>FeatureIndex[0], in arbitrary order &quot;init&quot;
                  feature (initial glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>FeatureIndex[1], &quot;fina&quot; feature (final
                  glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>FeatureIndex[2], for &quot;medi&quot; feature (medial
                  glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>LangSys</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>UrduLangSys</otexsrc>
            <otexcom>LangSys table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>LookupOrder, reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ReqFeatureIndex, numeral subsitution in
                  Urdu</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>FeatureCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>FeatureIndex[0], in arbitrary order &quot;init&quot;
                  feature (initial glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>FeatureIndex[1], &quot;fina&quot; feature (final
                  glyph)</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>FeatureIndex[2], &quot;medi&quot; feature (medial
                  glyph)</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 3: FeatureList Table and Feature Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 3 shows the FeatureList and Feature table
          definitions for ligatures in the Latin script. The
          FeatureList has three features, all optional and named
          &quot;liga.&quot; One feature, also a default, implements ligatures in
          Latin if no language-specific feature specifies other
          ligatures. Two other features implement ligatures in the
          Turkish and German languages, respectively.</para>

        <para>Three lookups define glyph substitutions for rendering
          ligatures in this font. The first lookup produces the &quot;ffi&quot;
          and &quot;fi&quot; ligatures; the second produces the &quot;ffl,&quot; &quot;fl,&quot; and
          &quot;ff&quot; ligatures; and the third produces the eszet
          ligature.</para>

        <para>The ligatures that begin with an &quot;f&quot; are separated into
          two sets because Turkish has a dotless &quot;i&quot; glyph and so does
          not use &quot;ffi&quot; and &quot;fi&quot; ligatures. However, Turkish does use
          the &quot;ffl,&quot; &quot;fl,&quot; and &quot;ff&quot; ligatures, and the
          TurkishLigatures feature table lists this one lookup.</para>

        <para>Only the German language system uses the eszet ligature,
          so the GermanLigatures feature table includes a lookup for
          rendering that ligature.</para>

        <para>Because the Latin script can use both sets of ligatures,
          the DefaultLigatures feature table defines two LookupList
          indices: one for the &quot;ffi&quot; and &quot;fi&quot; ligatures, and one for
          the &quot;ffl,&quot; &quot;fl,&quot; and &quot;ff&quot; ligatures. If the text-processing
          client selects this feature, then the font applies both
          lookups.</para>

        <para>Note that the TurkishLigatures and DefaultLigatures
          feature tables both list a LookupListIndex of one (1) for
          the &quot;ffl,&quot; &quot;fl,&quot; and &quot;ff&quot; ligatures lookup. This is because
          language-specific lookups override all default
          language-system lookups, and a language-system feature table
          must explicitly list all lookups that apply to the
          language.</para>

        <otexample>
          <title>Example 3</title>
          <otexline>
            <otexdata/>
            <otexsrc>FeatureList</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>TheFeatureList</otexsrc>
            <otexcom>FeatureList table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>FeatureCount FeatureRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6C696761</otexdata>
            <otexsrc>&quot;liga&quot;</otexsrc>
            <otexcom>FeatureTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>0014</otexdata>
            <otexsrc>TurkishLigatures</otexsrc>
            <otexcom>offset to Feature table, FflFfFlLiga
                  FeatureRecord[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6C696761</otexdata>
            <otexsrc>&quot;liga&quot;</otexsrc>
            <otexcom>FeatureTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>DefaultLigatures</otexsrc>
            <otexcom>offset to Feature table, FfiFiLiga, FflFfFlLiga
                  FeatureRecord[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>6C696761</otexdata>
            <otexsrc>&quot;liga&quot;</otexsrc>
            <otexcom>FeatureTag</otexcom>
          </otexline>
          <otexline>
            <otexdata>0022</otexdata>
            <otexsrc>GermanLigatures</otexsrc>
            <otexcom>offset to Feature table, EszetLiga</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Feature</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>TurkishLigatures</otexsrc>
            <otexcom>Feature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>FeatureParams, reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex[1], ffl, fl, ff ligature
                  substitution Lookup</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Feature</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>DefaultLigatures</otexsrc>
            <otexcom>Feature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>FeatureParams - reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>LookupListIndex[0], in arbitrary order, ffi, fi
                  ligatures</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex[1], ffl, fl, ff ligature
                  substitution Lookup</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Feature</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>GermanLigatures</otexsrc>
            <otexcom>Feature table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>NULL</otexsrc>
            <otexcom>FeatureParams - reserved, null</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>LookupListIndex[0], in arbitrary order, ffi, fi
                  ligatures</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>LookupListIndex[1], ffl, fl, ff ligature
                  substitution Lookup</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>LookupListIndex[2], eszet ligature substitution
                  Lookup</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 4: LookupList Table and Lookup Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>A continuation of Example 3, Example 4 shows three
          ligature lookups in the LookupList table. The first
          generates the &quot;ffi&quot; and &quot;fi&quot; ligatures; the second produces
          the &quot;ffl,&quot; &quot;fl,&quot; and &quot;ff&quot; ligatures; and the third generates
          the eszet ligature. Each lookup table defines an offset to a
          subtable that contains data for the ligature
          substitution.</para>

        <otexample>
          <title>Example 4</title>
          <otexline>
            <otexdata/>
            <otexsrc>LookupList</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>TheLookupList</otexsrc>
            <otexcom>LookupList table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>LookupCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0008</otexdata>
            <otexsrc>FfiFiLookup</otexsrc>
            <otexcom>Offset to Lookup[0] table, in design
                  order</otexcom>
          </otexline>
          <otexline>
            <otexdata>0010</otexdata>
            <otexsrc>FflFlFfLookup</otexsrc>
            <otexcom>offset to Lookup[1] table</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>EszetLookup</otexsrc>
            <otexcom>offset to Lookup[2] table</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Lookup</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>FfiFiLookup</otexsrc>
            <otexcom>Lookup[0] table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>LookupType, ligature subst</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>0x000C</otexsrc>
            <otexcom>LookupFlag, IgnoreLigatures,
                  IgnoreMarks</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubTableCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0018</otexdata>
            <otexsrc>FfiFiSubtable</otexsrc>
            <otexcom>offset to FfiFi ligature substitution
                  subtable</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Lookup</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>FflFlFfLookup</otexsrc>
            <otexcom>Lookup[1] table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>LookupType ligature subst</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>0x000C</otexsrc>
            <otexcom>LookupFlag- IgnoreLigatures,
                  IgnoreMarks</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubTableCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0028</otexdata>
            <otexsrc>FflFlFfSubtable</otexsrc>
            <otexcom>offset to FflFlFf ligature substitution
                  subtable</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>Lookup</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>EszetLookup</otexsrc>
            <otexcom>Lookup[2] table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0004</otexdata>
            <otexsrc>4</otexsrc>
            <otexcom>LookupType- ligature subst</otexcom>
          </otexline>
          <otexline>
            <otexdata>000C</otexdata>
            <otexsrc>0x000C</otexsrc>
            <otexcom>LookupFlag- IgnoreLigatures,
                  IgnoreMarks</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>SubTableCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0038</otexdata>
            <otexsrc>EszetSubtable</otexsrc>
            <otexcom>offset to Eszet ligature substitution
                  subtable</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 5: CoverageFormat1 Table (GlyphID List)</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 5 illustrates a Coverage table that lists the
          GlyphIDs of all lowercase descender glyphs in a font. The
          table uses the list format instead of the range format
          because the GlyphIDs for the descender glyphs are not
          consecutively ordered.</para>


        <otexample>
          <title>Example 5</title>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>DescenderCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>CoverageFormat lists</otexcom>
          </otexline>
          <otexline>
            <otexdata>0005</otexdata>
            <otexsrc>5</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0038</otexdata>
            <otexsrc>gGlyphID</otexsrc>
            <otexcom>GlyphArray[0], in GlyphID order</otexcom>
          </otexline>
          <otexline>
            <otexdata>003B</otexdata>
            <otexsrc>jGlyphID</otexsrc>
            <otexcom>GlyphArray[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc>pGlyphID</otexsrc>
            <otexcom>GlyphArray[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0042</otexdata>
            <otexsrc>qGlyphID</otexsrc>
            <otexcom>GlyphArray[3]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004A</otexdata>
            <otexsrc>yGlyphID</otexsrc>
            <otexcom>GlyphArray[4]</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 6: CoverageFormat2 Table (GlyphID Ranges)</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 6 shows a Coverage table that defines ten
          numeral glyphs (0 through 9). The table uses the range
          format instead of the list format because the GlyphIDs are
          ordered consecutively in the font. The StartCoverageIndex of
          zero (0) indicates that the first GlyphID, for the zero
          glyph, returns a Coverage Index of 0. The second GlyphID,
          for the numeral one (1) glyph, returns a Coverage Index of
          1, and so on.</para>


        <otexample>
          <title>Example 6</title>
          <otexline>
            <otexdata/>
            <otexsrc>CoverageFormat2</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>NumeralCoverage</otexsrc>
            <otexcom>Coverage table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>CoverageFormat, GlyphID ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>RangeCount RangeRecord[0]</otexcom>
          </otexline>
          <otexline>
            <otexdata>004E</otexdata>
            <otexsrc>0glyphID</otexsrc>
            <otexcom>Start GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0057</otexdata>
            <otexsrc>9glyphID</otexsrc>
            <otexcom>End GlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>StartCoverageIndex, first CoverageIndex =
                  0</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 7: ClassDefFormat1 Table (Class Array)</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>The ClassDef table in Example 7 assigns class values to
          the lowercase glyphs in a font. The x-height glyphs are in
          Class 0, the ascender glyphs are in Class 1, and the
          descender glyphs are in Class 2. The array begins with the
          index for the lowercase &quot;a&quot; glyph.</para>


        <otexample>
          <title>Example 7</title>
          <otexline>
            <otexdata/>
            <otexsrc>ClassDefFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>LowercaseClassDef</otexsrc>
            <otexcom>ClassDef table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>ClassFormat</otexcom>
          </otexline>
          <otexline>
            <otexdata>0032</otexdata>
            <otexsrc>aGlyphID</otexsrc>
            <otexcom>StartGlyph</otexcom>
          </otexline>
          <otexline>
            <otexdata>001A</otexdata>
            <otexsrc>26</otexsrc>
            <otexcom>GlyphCount</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>aGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>bGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>cGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>dGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>eGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>fGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>gGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>hGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>iGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>jGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>kGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>lGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>mGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>nGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>oGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>pGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>qGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>rGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>sGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>tGlyph, Ascender Class 1</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>uGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>vGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>wGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>xGlyph, Xheight Class 0</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>yGlyph, Descender Class 2</otexcom>
          </otexline>
          <otexline>
            <otexdata>0000</otexdata>
            <otexsrc>0</otexsrc>
            <otexcom>zGlyph, Xheight Class 0</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 8: ClassDefFormat2 Table (Class Ranges)</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>In Example 8, the ClassDef table assigns class values to
          four types of glyphs in the Arabic script: medium-height
          base glyphs, high base glyphs, very high base glyphs, and
          default mark glyphs. The table lists only Class 1, Class 2,
          and Class 3; all glyphs not explicitly assigned a class fall
          into Class 0.</para>

        <para>The table uses the range format because the GlyphIDs in
          each class are ordered consecutively in the font. In the
          ClassRange array, ClassRange definitions are ordered by the
          Start glyph index in each range. The indices of the high
          base glyphs, defined in ClassRange[0], are first in the font
          and have a class value of 2. ClassRange[1] defines all the
          very high base glyphs and assigns a class value of 3.
          ClassRange[2] contains all default mark glyphs; the class
          value is 1. Class 0 consists of all the medium-height base
          glyphs, which are not explicitly assigned a class
          value.</para>


        <otexample>
          <title>Example 8</title>
          <otexline>
            <otexdata/>
            <otexsrc>ClassDefFormat2</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>GlyphHeightClassDef</otexsrc>
            <otexcom>Class table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class Format ranges</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>ClassRangeCount ClassRange[0], ordered by
                  StartGlyphID</otexcom>
          </otexline>
          <otexline>
            <otexdata>0030</otexdata>
            <otexsrc>tahGlyphID</otexsrc>
            <otexcom>Start first GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0031</otexdata>
            <otexsrc>dhahGlyphID</otexsrc>
            <otexcom>End Last GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0002</otexdata>
            <otexsrc>2</otexsrc>
            <otexcom>Class, high base glyphs, ClassRange[1]</otexcom>
          </otexline>
          <otexline>
            <otexdata>0040</otexdata>
            <otexsrc>cafGlyphID</otexsrc>
            <otexcom>Start, first GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0041</otexdata>
            <otexsrc> gafGlyphID</otexsrc>
            <otexcom>End, Last GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0003</otexdata>
            <otexsrc>3</otexsrc>
            <otexcom>Class, very high base glyphs,
                  ClassRange[2]</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D2</otexdata>
            <otexsrc>fathatanDefaultGlyphID</otexsrc>
            <otexcom>Start, first GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>00D3</otexdata>
            <otexsrc>dammatanDefaultGlyphID</otexsrc>
            <otexcom>End, Last GlyphID in the range</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>Class default marks</otexcom>
          </otexline>
        </otexample>
      </section>
    </section>

    <!--======================================================================-->
    <section role="fragment">
      <title>Example 9: Device Table</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>Example 9 defines the minimum extent value for a math
          script, using a Device table to adjust the value according
          to the size of the output font. Here, the Device table
          defines single-pixel adjustments for font sizes from 11 ppem
          to 15 ppem. The DeltaFormat is 1, which signifies a packed
          array of signed 2-bit values, eight values per
          uint16.</para>


        <otexample>
          <title>Example 9</title>
          <otexline>
            <otexdata/>
            <otexsrc>DeviceTableFormat1</otexsrc>
            <otexcom/>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>MinCoordDeviceTable</otexsrc>
            <otexcom>Device Table definition</otexcom>
          </otexline>
          <otexline>
            <otexdata>000B</otexdata>
            <otexsrc>11</otexsrc>
            <otexcom>StartSize, 11 ppem</otexcom>
          </otexline>
          <otexline>
            <otexdata>000F</otexdata>
            <otexsrc>15</otexsrc>
            <otexcom>EndSize, 15 ppem</otexcom>
          </otexline>
          <otexline>
            <otexdata>0001</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>DeltaFormat signed 2 bit value, 8 values per
                  uint16</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>1</otexsrc>
            <otexcom>increase 11ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>1</otexsrc>
            <otexcom>increase 12ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>1</otexsrc>
            <otexcom>increase 13ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata/>
            <otexsrc>1</otexsrc>
            <otexcom>increase 14ppem by 1 pixel</otexcom>
          </otexline>
          <otexline>
            <otexdata>5540</otexdata>
            <otexsrc>1</otexsrc>
            <otexcom>increase 15ppem by 1 pixel </otexcom>
          </otexline>
        </otexample>
      </section>
    </section>
  </section>
