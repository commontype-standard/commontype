<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section id="chapter.hdmx">
  <title>hdmx - Horizontal Device Metrics</title>
  <!--======================================================================-->
  <section role="fragment">
    <title>Overview</title>
    <!--____________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>The hdmx table relates to CommonType fonts with TrueType
          outlines. The Horizontal Device Metrics table stores integer
          advance widths scaled to particular pixel sizes. This allows
          the font manager to build integer width tables without
          calling the scaler for each glyph. Typically this table
          contains only selected screen sizes. This table is sorted by
          pixel size. The checksum for this table applies to both
          subtables listed.</para>
      <para>Note that for non-square pixel grids, the character
          width (in pixels) will be used to determine which device
          record to use. For example, a 12 point character on a device
          with a resolution of 72x96 would be 12 pixels high, and 16 pixels
          wide. The hdmx device record for 16 pixel characters
          would be used.</para>
      <para>When the hdmx table is used, bit 2 of the flag field in
	  the <ottable>head</ottable> table must be set to 1 to
	  indicate that instructions may depend on point size.</para>
      <para>If bit 4 of the flag field in the
          <ottable>head</ottable> table is not set, then it is assumed
          that the font scales linearly; in this case an
          <ottable>hdmx</ottable> table is not necessary and should
          not be built. If bit 4 of the flag field is set, then one or
          more glyphs in the font are assumed to scale nonlinearly. In
          this case, performance can be improved by including the
          <ottable>hdmx</ottable> table with one or more important
          DeviceRecord's for important sizes. Please see the chapter
          "Recommendations for Windows Fonts" for more detail.</para>
      <para>The table begins as follows:</para>
      <otformat>
        <title>hdmx header</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>USHORT</otfieldtype>
          <otfieldname>version</otfieldname>
          <otfielddesc>Table version number (0)</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>2</otfieldoffs>
          <otfieldtype>SHORT</otfieldtype>
          <otfieldname>numRecords</otfieldname>
          <otfielddesc>Number of device records.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>4</otfieldoffs>
          <otfieldtype>LONG</otfieldtype>
          <otfieldname>sizeDeviceRecord</otfieldname>
          <otfielddesc>Size of a device record, long
              aligned.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>8</otfieldoffs>
          <otfieldtype>DeviceRecord</otfieldtype>
          <otfieldname>records[numRecords]</otfieldname>
          <otfielddesc>Array of device records.</otfielddesc>
        </otfield>
      </otformat>
      <para>Each DeviceRecord for format 0 looks like this.</para>
      <otformat>
        <title>Device Record</title>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>BYTE</otfieldtype>
          <otfieldname>pixelSize</otfieldname>
          <otfielddesc>Pixel size for following widths (as
                  ppem).</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>BYTE</otfieldtype>
          <otfieldname>maxWidth</otfieldname>
          <otfielddesc>Maximum width.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>BYTE</otfieldtype>
          <otfieldname>widths [numGlyphs]</otfieldname>
          <otfielddesc>Array of widths (numGlyphs is from the
	      <ottable>maxp</ottable>)</otfielddesc>
        </otfield>
      </otformat>
      <para>Each DeviceRecord is padded with 0's to make it long
          word aligned.</para>
      <para>Each Width value is the width of the particular glyph,
          in pixels, at the pixels per em (ppem) size listed at the
          start of the DeviceRecord.</para>
      <para>The ppem sizes are measured along the y axis.</para>
    </section>
    <!--________________________________________________________________-->
    <section role="xml-representation">
      <title>XML Representation</title>
      <code-fragment id="schema"><code-title>??</code-title>
hdmx =
  element hdmx {
    attribute version { text },
    element deviceRecord {
      attribute pixelSize { text },
      attribute maxWidth { text },
      element width {
        attribute gid { text },
        attribute v   { text }}* }* }
</code-fragment>
    </section>
    <!--____________________________________________________________________-->
    <section role="compiler">
      <title>Compiler</title>
      <code-fragment id="hdmx.methods">
  public void fromXML (Element hdmx)
    throws InvalidFontException, UnsupportedFontException {

    NodeList deviceRecords = hdmx.getChildNodes ();

    int numRecords = deviceRecords.getLength ();

    int sizeDeviceRecord = 0;

    for (int i = 0; i &lt; numRecords; i++) {
      Element deviceRecord = (Element) deviceRecords.item (i);
      int deviceRecordSize = 2 + deviceRecord.getChildNodes ().getLength ();
      sizeDeviceRecord = Math.max (deviceRecordSize, sizeDeviceRecord); }

    while (sizeDeviceRecord % 4 != 0) {
      sizeDeviceRecord++; }

    Block me = new Block (2 + 2 + 4 + numRecords * sizeDeviceRecord, 0);

    int offset = 0;

    me.setuint16 (offset,
                  Integer.decode (hdmx.getAttribute ("version")).intValue ());
    me.setint16 (offset + 2, numRecords);
    me.setint32 (offset + 4, sizeDeviceRecord);

    offset += 8;

    for (int i = 0; i &lt; numRecords; i++) {
      Element deviceRecord = (Element) deviceRecords.item (i);
      me.setuint8 (offset, Integer.decode (deviceRecord.getAttribute ("pixelSize")).intValue ());
      offset++;
      me.setuint8 (offset, Integer.decode (deviceRecord.getAttribute ("maxWidth")).intValue ());
      offset++;

      NodeList widths = deviceRecord.getChildNodes ();
      for (int j = 0; j &lt; widths.getLength (); j++) {
        Element width = (Element) widths.item (j);
        me.setuint8 (offset, Integer.decode (width.getAttribute ("v")).intValue ());
        offset ++; }

      while (offset % 4 != 0) {
       offset++; }}

    data = me.serialize ();
  }
</code-fragment>
    </section>
    <!--____________________________________________________________________-->
    <section role="decompiler">
      <title>Decompiler</title>
      <code-fragment id="hdmx.methods">
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at = new AttributesImpl ();
    at.addAttribute ("", "version", "version", "CDATA", "" + getuint16 (0));

    conf.ch.startElement ("hdmx", at); {
      int offset;
      int numGlyphs = font.maxp.getNumGlyphs ();

      int numRecords = getint16 (2);
      int sizeDeviceRecord = getint32 (4);

      offset = 8;

      for (int i = 0; i &lt; numRecords; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "pixelSize", "pixelSize", "CDATA", "" + getuint8 (offset));
        at.addAttribute ("", "maxWidth", "maxWidth", "CDATA", "" + getuint8 (offset + 1));

        conf.ch.startElement ("deviceRecord", at); {
          for (int gid = 0; gid &lt; numGlyphs; gid++) {
            at = new AttributesImpl ();
            at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);
            at.addAttribute ("", "v", "v", "CDATA", "" + getuint8 (offset + 2 + gid));
            conf.ch.element ("width", at); }
          conf.ch.endElement ("deviceRecord"); }

        offset += sizeDeviceRecord; }

      conf.ch.endElement ("hdmx"); }
  }
</code-fragment>
    </section>
    <!--________________________________________________________________-->
    <section role="implementation">
      <title>Implementation</title>
      <code-fragment package="com.adobe.aots.CommonType" class="Hdmx"><code-title>Hdmx class</code-title>
package com.adobe.aots.CommonType;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Hdmx extends Table {

  public Hdmx () {
    super (Tag.hdmx, null);
  }

  public Hdmx (Font font) {
    super (Tag.hdmx, font);
  }

  <code-include linkend="hdmx.methods"/>
}
</code-fragment>
    </section>
  </section>
</section>
