<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section id="chapter.head">
    <title>head - Font Header</title>

    <!--======================================================================-->
    <section role="fragment">
      <title>Introduction</title>

      <!--____________________________________________________________________-->
      <section role="specification">
        <title>Specification</title>

        <para>This table gives global information about the font. The
          bounding box values should be computed using
          <emphasis>only</emphasis> glyphs that have contours. Glyphs
          with no contours should be ignored for the purposes of these
          calculations.</para>

        <otformat>
          <otfield>
            <otfieldoffs>0</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>Table version number</otfieldname>
            <otfielddesc>0x00010000 for version 1.0.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>4</otfieldoffs>
            <otfieldtype>Fixed</otfieldtype>
            <otfieldname>fontRevision</otfieldname>
            <otfielddesc>Set by font manufacturer.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>12</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>checkSumAdjustment</otfieldname>
            <otfielddesc>To compute: set it to 0, sum the entire font
              as ULONG, then store 0xB1B0AFBA - sum.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>16</otfieldoffs>
            <otfieldtype>ULONG</otfieldtype>
            <otfieldname>magicNumber</otfieldname>
            <otfielddesc>Set to 0x5F0F3CF5.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>20</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>flags</otfieldname>
            <otfielddesc><simplelist>
                <member>Bit 0: baseline for font at y=0;</member>
                <member>Bit 1: left sidebearing at x=0;</member>
                <member>Bit 2: instructions may depend on point
                  size;</member>
                <member>Bit 3: force ppem to integer values for all internal
                  scaler math; may use fractional ppem sizes if this bit is
                  clear;</member>
                <member>Bit 4: instructions may alter advance width (the
                  advance widths might not scale linearly);</member>
                <member>Bits 5-10: These should be set according to
                  <ulink url="http://developer.apple.com/fonts/TTRefMan/RM06/Chap6head.html">Apple's specification</ulink>. However, they are not
                  implemented in CommonType.</member>
                <member>Bit 11: font data is 'lossless,' as a result of
                  having been compressed and decompressed with the Agfa
                  MicroType Express engine.</member>
                <member>Bit 12: font converted (produce compatible
                  metrics).</member>
                <member>Bit 13: Font optimized for ClearType.</member>
                <member>Bit 14: Reserved, set to 0.</member>
                <member>Bit 15: Reserved, set to 0.</member>
              </simplelist>
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>22</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>unitsPerEm</otfieldname>
            <otfielddesc>Valid range is from 16 to
              16384. This value should be a power of 2 for fonts that
            have TrueType outlines.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>24</otfieldoffs>
            <otfieldtype>LONGDATETIME</otfieldtype>
            <otfieldname>created</otfieldname>
            <otfielddesc>Number of seconds since 12:00 midnight,
              January 1, 1904. 64-bit integer.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>32</otfieldoffs>
            <otfieldtype>LONGDATETIME</otfieldtype>
            <otfieldname>modified</otfieldname>
            <otfielddesc>Number of seconds since 12:00 midnight,
              January 1, 1904. 64-bit integer.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>40</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>xMin</otfieldname>
            <otfielddesc>For all glyph bounding boxes.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>42</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yMin</otfieldname>
            <otfielddesc>For all glyph bounding boxes.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>44</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>xMax</otfieldname>
            <otfielddesc>For all glyph bounding boxes.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>46</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>yMax</otfieldname>
            <otfielddesc>For all glyph bounding boxes.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>48</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>macStyle</otfieldname>
            <otfielddesc>
	      <simplelist>
		<member>Bit 0: Bold (if set to 1);</member>
		<member>Bit 1: Italic (if set to 1)</member>
		<member>Bit 2: Underline (if set to 1)</member>
		<member>Bit 3: Outline (if set to 1)</member>
		<member>Bit 4: Shadow (if set to 1)</member>
		<member>Bit 5: Condensed (if set to 1)</member>
		<member>Bit 6: Extended (if set to 1)</member>
		<member>Bits 7-15: Reserved (set to 0)</member>
	      </simplelist>
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>50</otfieldoffs>
            <otfieldtype>USHORT</otfieldtype>
            <otfieldname>lowestRecPPEM</otfieldname>
            <otfielddesc>Smallest readable size in
              pixels.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>52</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>fontDirectionHint</otfieldname>
            <otfielddesc>
                  <simplelist>
                    <member>0: Fully mixed directional
                      glyphs;</member>
                    <member>1: Only strongly left to right;</member>
                    <member>2: Like 1 but also contains
                      neutrals;</member>
                    <member>-1: Only strongly right to left;</member>
                    <member>-2: Like -1 but also contains
                      neutrals<footnote>
                        <para>A neutral character has no inherent
                          directionality; it is not a character with
                          zero (0) width. Spaces and punctuation are
                          examples of neutral characters. Non-neutral
                          characters are those with inherent
                          directionality. For example, Roman letters
                          (left-to-right) and Arabic
                          letters(right-to-left) have directionality.
                          In a &quot;normal&quot; Roman font where spaces and
                          punctuation are present, the font direction
                          hints should be set to two (2).</para>
                      </footnote>.</member>
                  </simplelist>
            </otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>54</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>indexToLocFormat</otfieldname>
            <otfielddesc>0 for short offsets, 1 for
              long.</otfielddesc>
          </otfield>
          <otfield>
            <otfieldoffs>56</otfieldoffs>
            <otfieldtype>SHORT</otfieldtype>
            <otfieldname>glyphDataFormat</otfieldname>
            <otfielddesc>0 for current format.</otfielddesc>
          </otfield>
        </otformat>

        <para/>


        <para>Note that macStyle bits must agree with the
          <ottable>OS/2</ottable> table fsSelection bits. The
          fsSelection bits are used over the macStyle bits in
          Microsoft Windows. The PANOSE values and
          <ottable>post</ottable> table values are ignored for
          determining bold or italic fonts.</para>

        <para>For historical reasons, the fontRevision value contained
          in this table is not used by Windows to determine the
          version of a font. Instead, Windows evaluates the version
          string (id 5) in the <ottable>name</ottable> table.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="annotation">
        <title>Annotation</title>

        <para>It seems that Table version number is set to 'OTTO' for
          CFF based fonts.</para>
      </section>

      <!--____________________________________________________________________-->
      <section role="xml-representation">
        <title>XML Representation</title>

<code-fragment id="schema">
head =
  element head {
    attribute major { text },
    attribute minor { text },
    element fontRevision {
      attribute major { text },
      attribute minor { text }
    },
    element flags {
      attribute baseline_at_0 { yesOrNo },
      attribute lsb_at_0 { yesOrNo },
      attribute instructions_vary_with_point_size { yesOrNo },
      attribute use_integral_ppem { yesOrNo },
      attribute instructions_alter_advance_width { yesOrNo },
      attribute lossless { yesOrNo },
      attribute converted { yesOrNo },
      attribute optimized_for_cleartype { yesOrNo }
    },
    element unitsPerEm {
      attribute v { text }
    },
    element dates {
      attribute created { text },
      attribute modified { text }
    },
    element bbox {
      attribute xMin { text },
      attribute yMin { text },
      attribute xMax { text },
      attribute yMax { text }
    },
    element macStyle {
      attribute bold { yesOrNo },
      attribute italic { yesOrNo }
    },
    element lowestRecPPEM {
      attribute v { text }
    },
    element fontDirectionHint {
      attribute v { text }
    },
    element indexToLocFormat {
      attribute v { text }
    }
  }
</code-fragment>

      </section>

      <!--____________________________________________________________________-->
      <section role="compiler">
        <title>Compiler</title>

<code-fragment id="head.methods">
  public void fromXML (Element head)
      throws InvalidFontException, UnsupportedFontException {

    data = new byte [54];

    { int major = Integer.decode (head.getAttribute (&quot;major&quot;)).intValue ();
      int minor = Integer.decode (head.getAttribute (&quot;minor&quot;)).intValue ();
      setTableVersion (major, minor); }

    NodeList children = head.getChildNodes ();
    for (int i = 0; i &lt; children.getLength (); i++) {
      Element e = (Element) children.item (i);

      if (&quot;fontRevision&quot;.equals (e.getTagName ())) {
        int major = Integer.decode (e.getAttribute (&quot;major&quot;)).intValue ();
        int minor = Integer.decode (e.getAttribute (&quot;minor&quot;)).intValue ();
        setFontRevision (major, minor); }

      else if (&quot;flags&quot;.equals (e.getTagName ())) {
        Flags flags = new Flags ();
        flags.baseline_at_0
           = &quot;yes&quot;.equals (e.getAttribute (&quot;baseline_at_0&quot;));
        flags.lsb_at_0
           = &quot;yes&quot;.equals (e.getAttribute (&quot;lsb_at_0&quot;));
        flags.instructions_vary_with_point_size
           = &quot;yes&quot;.equals (e.getAttribute (&quot;instructions_vary_with_point_size&quot;));
        flags.use_integral_ppem
           = &quot;yes&quot;.equals (e.getAttribute (&quot;use_integral_ppem&quot;));
        flags.instructions_alter_advance_width
           = &quot;yes&quot;.equals (e.getAttribute (&quot;instructions_alter_advance_width&quot;));
        flags.lossless
           = &quot;yes&quot;.equals (e.getAttribute (&quot;lossless&quot;));
        flags.converted
           = &quot;yes&quot;.equals (e.getAttribute (&quot;converted&quot;));
        flags.optimized_for_cleartype
           = &quot;yes&quot;.equals (e.getAttribute (&quot;optimized_for_cleartype&quot;));
        setFlags (flags); }

      else if (&quot;unitsPerEm&quot;.equals (e.getTagName ())) {
        int upem = Integer.decode (e.getAttribute (&quot;v&quot;)).intValue ();
        setUnitsPerEm (upem); }

      else if (&quot;dates&quot;.equals (e.getTagName ())) {
        java.text.DateFormat df
          = java.text.DateFormat.getDateTimeInstance (java.text.DateFormat.LONG,
                                                      java.text.DateFormat.LONG);
        try {
          java.util.Date created = df.parse (e.getAttribute (&quot;created&quot;));
          setCreated (created); }
        catch (java.text.ParseException ex) {
          throw new InvalidFontException (&quot;incorrect date/time for head.created&quot;); }

        try {
	  java.util.Date modified = df.parse (e.getAttribute (&quot;modified&quot;));
	  setModified (modified); }
        catch (java.text.ParseException ex) {
          throw new InvalidFontException (&quot;incorrect date/time for head.modified&quot;); }}


      else if (&quot;bbox&quot;.equals (e.getTagName ())) {
        Bbox b = new Bbox ();
        b.xMin = Integer.decode (e.getAttribute (&quot;xMin&quot;)).intValue ();
        b.yMin = Integer.decode (e.getAttribute (&quot;yMin&quot;)).intValue ();
        b.xMax = Integer.decode (e.getAttribute (&quot;xMax&quot;)).intValue ();
        b.yMax = Integer.decode (e.getAttribute (&quot;yMax&quot;)).intValue ();
        setBbox (b); }

      else if (&quot;macStyle&quot;.equals (e.getTagName ())) {
        MacStyle macStyle = new MacStyle ();
        macStyle.bold = &quot;yes&quot;.equals (e.getAttribute (&quot;bold&quot;));
        macStyle.italic = &quot;yes&quot;.equals (e.getAttribute (&quot;italic&quot;));
        setMacStyle (macStyle); }

      else if (&quot;lowestRecPPEM&quot;.equals (e.getTagName ())) {
        int rpem = Integer.decode (e.getAttribute (&quot;v&quot;)).intValue ();
        setLowestRecPPEM (rpem); }

      else if (&quot;fontDirectionHint&quot;.equals (e.getTagName ())) {
        int hint = Integer.decode (e.getAttribute (&quot;v&quot;)).intValue ();
        setFontDirectionHint (hint); }

      else if (&quot;indexToLocFormat&quot;.equals (e.getTagName ())) {
        int o = Integer.decode (e.getAttribute (&quot;v&quot;)).intValue ();
        setIndexToLocFormat (o); }}

      setuint32 (12, 0x5f0f3cf5); // magicNumber
//    setint16 (52, 0); // glyphDataFormat
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="decompiler">
        <title>Decompiler</title>

<code-fragment id="head.methods">
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at;

    int [] version = getTableVersion ();
    at = new AttributesImpl ();
    at.addAttribute (&quot;&quot;, &quot;major&quot;, &quot;major&quot;, &quot;CDATA&quot;, &quot;&quot; + version [0]);
    at.addAttribute (&quot;&quot;, &quot;minor&quot;, &quot;minor&quot;, &quot;CDATA&quot;, &quot;&quot; + version [1]);
    conf.ch.startElement (&quot;head&quot;, at); {

      int [] fontRevision = getFontRevision ();
      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;major&quot;, &quot;major&quot;, &quot;CDATA&quot;, &quot;&quot; + fontRevision [0]);
      at.addAttribute (&quot;&quot;, &quot;minor&quot;, &quot;minor&quot;, &quot;CDATA&quot;, &quot;&quot; + fontRevision [1]);
      conf.ch.element (&quot;fontRevision&quot;, at);

      Flags flags = getFlags ();
      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;baseline_at_0&quot;, &quot;baseline_at_0&quot;, &quot;CDATA&quot;,
                       flags.baseline_at_0 ? &quot;yes&quot; : &quot;no&quot;);
      at.addAttribute (&quot;&quot;, &quot;lsb_at_0&quot;, &quot;lsb_at_0&quot;, &quot;CDATA&quot;,
                       flags.lsb_at_0 ? &quot;yes&quot; : &quot;no&quot;);
      at.addAttribute (&quot;&quot;, &quot;instructions_vary_with_point_size&quot;, &quot;instructions_vary_with_point_size&quot;, &quot;CDATA&quot;,
                       flags.instructions_vary_with_point_size ? &quot;yes&quot; : &quot;no&quot;);
      at.addAttribute (&quot;&quot;, &quot;use_integral_ppem&quot;, &quot;use_integral_ppem&quot;, &quot;CDATA&quot;,
                       flags.use_integral_ppem ? &quot;yes&quot; : &quot;no&quot;);
      at.addAttribute (&quot;&quot;, &quot;instructions_alter_advance_width&quot;, &quot;instructions_alter_advance_width&quot;, &quot;CDATA&quot;,
                       flags.instructions_alter_advance_width ? &quot;yes&quot; : &quot;no&quot;);
      at.addAttribute (&quot;&quot;, &quot;lossless&quot;, &quot;lossless&quot;, &quot;CDATA&quot;,
                       flags.lossless ? &quot;yes&quot; : &quot;no&quot;);
      at.addAttribute (&quot;&quot;, &quot;converted&quot;, &quot;converted&quot;, &quot;CDATA&quot;,
                       flags.converted ? &quot;yes&quot; : &quot;no&quot;);
      at.addAttribute (&quot;&quot;, &quot;optimized_for_cleartype&quot;, &quot;optimized_for_cleartype&quot;, &quot;CDATA&quot;,
                       flags.optimized_for_cleartype? &quot;yes&quot; : &quot;no&quot;);
      conf.ch.element (&quot;flags&quot;, at);


      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;v&quot;, &quot;v&quot;, &quot;CDATA&quot;, &quot;&quot; + getUnitsPerEm ());
      conf.ch.element  (&quot;unitsPerEm&quot;, at);

      at = new AttributesImpl ();
      java.text.DateFormat df
         = java.text.DateFormat.getDateTimeInstance (java.text.DateFormat.LONG,
                                                     java.text.DateFormat.LONG);
      at.addAttribute (&quot;&quot;, &quot;created&quot;, &quot;created&quot;, &quot;CDATA&quot;,
                       df.format (getCreated ()));
      at.addAttribute (&quot;&quot;, &quot;modified&quot;, &quot;modified&quot;, &quot;CDATA&quot;,
                       df.format (getModified ()));
      conf.ch.element (&quot;dates&quot;, at);

      at = new AttributesImpl ();
      Bbox b = getBbox ();
      at.addAttribute (&quot;&quot;, &quot;xMin&quot;, &quot;xMin&quot;, &quot;CDATA&quot;, &quot;&quot; + b.xMin);
      at.addAttribute (&quot;&quot;, &quot;yMin&quot;, &quot;yMin&quot;, &quot;CDATA&quot;, &quot;&quot; + b.yMin);
      at.addAttribute (&quot;&quot;, &quot;xMax&quot;, &quot;xMax&quot;, &quot;CDATA&quot;, &quot;&quot; + b.xMax);
      at.addAttribute (&quot;&quot;, &quot;yMax&quot;, &quot;yMax&quot;, &quot;CDATA&quot;, &quot;&quot; + b.yMax);
      conf.ch.element (&quot;bbox&quot;, at);

      MacStyle macStyle = getMacStyle ();
      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;bold&quot;, &quot;bold&quot;, &quot;CDATA&quot;,
                       macStyle.bold ? &quot;yes&quot; : &quot;no&quot;);
      at.addAttribute (&quot;&quot;, &quot;italic&quot;, &quot;italic&quot;, &quot;CDATA&quot;,
                       macStyle.italic ? &quot;yes&quot; : &quot;no&quot;);
      conf.ch.element (&quot;macStyle&quot;, at);

      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;v&quot;, &quot;v&quot;, &quot;CDATA&quot;, &quot;&quot; + getLowestRecPPEM ());
      conf.ch.element (&quot;lowestRecPPEM&quot;, at);

      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;v&quot;, &quot;v&quot;, &quot;CDATA&quot;, &quot;&quot; + getFontDirectionHint ());
      conf.ch.element (&quot;fontDirectionHint&quot;, at);

      at = new AttributesImpl ();
      at.addAttribute (&quot;&quot;, &quot;v&quot;, &quot;v&quot;, &quot;CDATA&quot;, &quot;&quot; + getIndexToLocFormat ());
      conf.ch.element (&quot;indexToLocFormat&quot;, at);

// TODO
//      at = new AttributesImpl ();
//      at.addAttribute (&quot;&quot;, &quot;v&quot;, &quot;v&quot;, &quot;CDATA&quot;, &quot;&quot; + getGlyphDataFormat ());
//      conf.ch.element (&quot;glyphDataFormat&quot;, at);

      conf.ch.endElement (&quot;head&quot;); }
  }
</code-fragment>
      </section>

      <!--____________________________________________________________________-->
      <section role="implementation">
        <title>Implementation</title>

        <para>Here is the class that represents the head
          table:</para>

<code-fragment package="com.adobe.aots.CommonType" class="Head">
  <code-title>Head class</code-title>
package com.adobe.aots.CommonType;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.Attributes;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Head extends Table {

  public Head () {
    super (Tag.head, null);
  }

  public Head (Font font) {
    super (Tag.head, font);
  }

  static public final long Version_OTTO = 0x4f54544f;
  static public final long Version_1_0  = 0x00010000;

  static public final long magicNumber = 0x5F0F3CF5;

  public class Flags {
    boolean baseline_at_0;
    boolean lsb_at_0;
    boolean instructions_vary_with_point_size;
    boolean use_integral_ppem;
    boolean instructions_alter_advance_width;
    boolean lossless;
    boolean converted;
    boolean optimized_for_cleartype;

    public void fromBinary (int n) {
      baseline_at_0                        = ((n &amp; 0x0001) != 0);
      lsb_at_0                             = ((n &amp; 0x0002) != 0);
      instructions_vary_with_point_size    = ((n &amp; 0x0004) != 0);
      use_integral_ppem                    = ((n &amp; 0x0008) != 0);
      instructions_alter_advance_width     = ((n &amp; 0x0010) != 0);
      lossless                             = ((n &amp; 0x0800) != 0);
      converted                            = ((n &amp; 0x1000) != 0);
      optimized_for_cleartype              = ((n &amp; 0x2000) != 0);
    }

    public int toBinary () {
      int bin = 0;
      if (baseline_at_0)                          { bin |= 0x0001; }
      if (lsb_at_0)                               { bin |= 0x0002; }
      if (instructions_vary_with_point_size)      { bin |= 0x0004; }
      if (use_integral_ppem)                      { bin |= 0x0008; }
      if (instructions_alter_advance_width)       { bin |= 0x0010; }
      if (lossless)                               { bin |= 0x0800; }
      if (converted)                              { bin |= 0x1000; }
      if (optimized_for_cleartype)                { bin |= 0x2000; }
      return bin;
    }

    public Attributes toXML () {
      org.xml.sax.helpers.AttributesImpl at;
      at = new org.xml.sax.helpers.AttributesImpl ();
      if (baseline_at_0) {
        at.addAttribute (&quot;head&quot;,
                         &quot;baseline_at_0&quot;,
                         &quot;baseline_at_0&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      if (lsb_at_0) {
        at.addAttribute (&quot;&quot;,
                         &quot;lsb_at_0&quot;,
                         &quot;lsb_at_0&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      if (instructions_vary_with_point_size) {
        at.addAttribute (&quot;&quot;,
                         &quot;instructions_vary_with_point_size&quot;,
                         &quot;instructions_vary_with_point_size&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      if (use_integral_ppem) {
        at.addAttribute (&quot;&quot;,
                         &quot;use_integral_ppem&quot;,
                         &quot;use_integral_ppem&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      if (instructions_alter_advance_width) {
        at.addAttribute (&quot;&quot;,
                         &quot;instructions_alter_advance_width&quot;,
                         &quot;instructions_alter_advance_width&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      if (lossless) {
        at.addAttribute (&quot;&quot;,
                         &quot;lossless&quot;,
                         &quot;lossless&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      if (converted) {
        at.addAttribute (&quot;&quot;,
                         &quot;converted&quot;,
                         &quot;converted&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      if (optimized_for_cleartype) {
        at.addAttribute (&quot;&quot;,
                         &quot;optimized_for_cleartype&quot;,
                         &quot;optimized_for_cleartype&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      return at;
    }
  }

  public class MacStyle {
    boolean bold;
    boolean italic;

    public void fromBinary (int n) {
      bold                        = ((n &amp; 0x0001) != 0);
      italic                      = ((n &amp; 0x0002) != 0);
    }

    public int toBinary () {
      int bin = 0;
      if (bold)                           { bin |= 0x0001; }
      if (italic)                         { bin |= 0x0002; }
      return bin;
    }

    public Attributes toXML () {
      org.xml.sax.helpers.AttributesImpl at;
      at = new org.xml.sax.helpers.AttributesImpl ();
      if (bold) {
        at.addAttribute (&quot;&quot;,
                         &quot;bold&quot;,
                         &quot;bold&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      if (italic) {
        at.addAttribute (&quot;&quot;,
                         &quot;italic&quot;,
                         &quot;italic&quot;,
                         &quot;CDATA&quot;, &quot;yes&quot;); }
      return at;
    }
  }

  <code-include linkend="head.methods"/>

  public int[] getTableVersion () {
    return getFixed (0);
  }

  public void setTableVersion (int major, int minor) {
    setFixed (0, major, minor);
  }

  public int[] getFontRevision () {
    return getFixed (4);
  }

  public void setFontRevision (int major, int minor) {
    setFixed (4, major, minor);
  }

  public void clearChecksumAdjust () {
    setuint32 (8, 0);
  }

  public void setChecksumAdjust (long l) {
    setuint32 (8, (int)l);
  }

  public Flags getFlags () {
    Flags result = new Flags ();
    result.fromBinary (getuint16 (16));
    return result;
  }

  public void setFlags (Flags flags) {
    setuint16 (16, flags.toBinary ());
  }

  public int getUnitsPerEm () {
    return getuint16 (18);
  }

  public void setUnitsPerEm (int u) {
    setuint16 (18, u);
  }

  static final java.util.GregorianCalendar baseForDates
       = new java.util.GregorianCalendar (1904, 0, 1, 0, 0, 0);

  public java.util.Date getCreated () {
    return new java.util.Date (baseForDates.getTime ().getTime ()
                               +  getLONGDATETIME (20) * 1000);
  }

  public void setCreated (java.util.Date d) {
   setLONGDATETIME (20, (d.getTime () - baseForDates.getTime ().getTime ()) / 1000);
  }

  public java.util.Date getModified () {
    return new java.util.Date (baseForDates.getTime ().getTime ()
                               +  getLONGDATETIME (28) * 1000);
  }

  public void setModified (java.util.Date d) {
    setLONGDATETIME (28, (d.getTime () - baseForDates.getTime ().getTime ()) / 1000);
  }

  static public class Bbox {
    public int xMin;
    public int yMin;
    public int xMax;
    public int yMax; };

  public Bbox getBbox () {
    Bbox b = new Bbox ();
    b.xMin = getint16 (36);
    b.yMin = getint16 (38);
    b.xMax = getint16 (40);
    b.yMax = getint16 (42);
    return b;
  }

  public void setBbox (Bbox b) {
    setint16 (36, b.xMin);
    setint16 (38, b.yMin);
    setint16 (40, b.xMax);
    setint16 (42, b.yMax);
  }

  public MacStyle getMacStyle () {
    MacStyle result = new MacStyle ();
    result.fromBinary (getuint16 (44));
    return result;
  }

  public void setMacStyle (MacStyle flags) {
    setuint16 (44, flags.toBinary ());
  }

  public int getLowestRecPPEM () {
    return getuint16 (46);
  }

  public void setLowestRecPPEM (int n) {
    setuint16 (46, n);
  }

  public int getFontDirectionHint () {
    return getint16 (48);
  }

  public void setFontDirectionHint (int n) {
    setint16 (48, n);
  }

  public int getIndexToLocFormat () {
    return getint16 (50);
  }

  public void setIndexToLocFormat (int n) {
    setint16 (50, n);
  }

  public int getGlyphDataFormat () {
    return getint16 (52);
  }

  public void setGlyphDataFormat (int n) {
    setint16 (52, n);
  }
}
</code-fragment>
      </section>
    </section>
  </section>
