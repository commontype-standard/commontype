<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section id="chapter.hmtx">
  <title>hmtx - Horizontal Metrics</title>
  <section role="fragment">
    <title>Introduction</title>
    <!--________________________________________________________________-->
    <section role="specification">
      <title>Specification</title>
      <para>The type longHorMetric is defined as an array where each
          element has two parts: the advance width, which is of type
          USHORT, and the left side bearing, which is of type SHORT.
          Or, more formally:</para>
      <literallayout>
typedef struct  _longHorMetric {
     USHORT advanceWidth;
     SHORT  lsb;
}  longHorMetric;
</literallayout>
      <otformat>
        <otfield>
          <otfieldoffs>0</otfieldoffs>
          <otfieldtype>longHorMetric [numberOfHMetrics]</otfieldtype>
          <otfieldname>hMetrics</otfieldname>
          <otfielddesc>Paired advance width and left side bearing
              values for each glyph. The value numOfHMetrics comes
              from the <ottable>hhea</ottable> table. If the font is
              monospaced, only one entry need be in the array, but
              that entry is required. The last entry applies to all
              subsequent glyphs.</otfielddesc>
        </otfield>
        <otfield>
          <otfieldoffs>??</otfieldoffs>
          <otfieldtype>FWord [ ]</otfieldtype>
          <otfieldname>leftSideBearing</otfieldname>
          <otfielddesc>Here the advanceWidth is assumed to be the
              same as the advanceWidth for the last entry above. The
              number of entries in this array is derived from
              numGlyphs (from <ottable>maxp</ottable> table) minus
              numberOfHMetrics. This generally is used with a run of
              monospaced glyphs (e.g., Kanji fonts or Courier fonts).
              Only one run is allowed and it must be at the end. This
              allows a monospaced font to vary the left side bearing
              values for each glyph.</otfielddesc>
        </otfield>
      </otformat>
      <para>In CFF CommonType fonts, every glyph's advanceWidth as
          recorded in the <ottable>hmtx</ottable> table must be identical to its x
          width in the <ottable>CFF</ottable> table.</para>
      <para>For any glyph, xmax and xmin are given in
          <ottable>glyf</ottable> table, lsb and aw are given in
          <ottable>hmtx</ottable> table. rsb is calculated as
          follows:</para>
      <literallayout>
rsb = aw - (lsb + xmax - xmin)
</literallayout>
      <para>If pp1 and pp2 are phantom points used to control lsb
          and rsb, their initial position in x is calculated as
          follows:</para>
      <literallayout>
pp1 = xmin - lsb
pp2 = pp1 + aw
</literallayout>
    </section>
    <!--________________________________________________________________-->
    <section role="xml-representation">
      <title>XML Representation</title>
      <para>In the XML representation, the various entries can occur in any order, and the long and short metrics can even be interleaved. However, the entries must have distinct gid attribute values, and collectively cover exactly the range [0, n-1]. In a fully valid font, n must of course be equal to the maxp.numGlyphs.</para>
      <code-fragment id="schema"><code-title>??</code-title>
hmtx =
  element hmtx {
    element hMetric {
      attribute gid { text },
      attribute lsb { text },
      attribute adv { text }
    }*,
    element lsb {
      attribute gid { text },
      attribute lsb { text }
    }*
  }
</code-fragment>
    </section>
    <!--____________________________________________________________________-->
    <section role="compiler">
      <title>Compiler</title>
      <code-fragment id="hmtx.methods">
  private class HMetric {
    int lsb;
    int adv;
    boolean hasAdvance;

    public HMetric (int adv, int lsb) {
      this.adv = adv;
      this.lsb = lsb;
      this.hasAdvance = true;
    }

    public HMetric (int lsb) {
      this.lsb = lsb;
      this.hasAdvance = false;
    }
  }

  public void fromXML (Element hmtx)
    throws InvalidFontException, UnsupportedFontException {

    NodeList metrics = hmtx.getChildNodes ();

    HMetric m [] = new HMetric [metrics.getLength ()];

    int hmetrics = 0;
    int lsbs = 0;

    for (int i = 0; i &lt; m.length; i++) {
      Element metric = (Element) metrics.item (i);

      int gid = Integer.decode (metric.getAttribute ("gid"));

      if (m.length &lt;= gid) {
         throw new InvalidFontException ("htmx: gid " + gid + " is too large"); }

      if (m [gid] != null) {
        throw new InvalidFontException ("duplicate gid " + gid + " in hmtx"); }

      if ("hMetric".equals (metric.getTagName ())) {
        m [gid] = new HMetric (Integer.decode (metric.getAttribute ("adv")).intValue (),
                               Integer.decode (metric.getAttribute ("lsb")).intValue ());
        hmetrics++; }

      else if ("lsb".equals (metric.getTagName ())) {
        m [gid] = new HMetric (Integer.decode (metric.getAttribute ("lsb")).intValue ());
        lsbs++; }}

    // verify that all lsbs are after all hmetric
    for (int gid = hmetrics; gid &lt; hmetrics + lsbs; gid++) {
      if (m [gid].hasAdvance) {
        throw new InvalidFontException ("htmx: gid " + gid + " has advance and is larger that first gid without advance " + hmetrics); }}

    Block me = new Block (hmetrics*4 + lsbs*2, 0);

    int offset = 0;

    for (int gid = 0; gid &lt; hmetrics; gid++) {
      me.setuint16 (offset, m [gid].adv);
      me.setuint16 (offset + 2, m [gid].lsb);
      offset += 4; }

    for (int gid = hmetrics; gid &lt; hmetrics + lsbs; gid++) {
      me.setuint16 (offset, m [gid].lsb);
      offset += 2; }

    data = me.serialize ();
  }
</code-fragment>
    </section>
    <!--____________________________________________________________________-->
    <section role="decompiler">
      <title>Decompiler</title>
      <code-fragment id="hmtx.methods">
  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException {

    AttributesImpl at;

    conf.ch.startElement ("hmtx"); {
      int offset = 0;
      int gid = 0;
      int numberOfHMetrics = font.hhea.getNumberOfHMetrics ();
      int numLsb = font.maxp.getNumGlyphs () - numberOfHMetrics;

      for (int i = 0; i &lt; numberOfHMetrics; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);
        gid++;
        at.addAttribute ("", "adv", "adv", "CDATA", "" + getint16 (offset));
        offset += 2;
        at.addAttribute ("", "lsb", "lsb", "CDATA", "" + getint16 (offset));
        offset += 2;
        conf.ch.element ("hMetric", at); }

      for (int i = 0; i &lt; numLsb; i++) {
        at = new AttributesImpl ();
        at.addAttribute ("", "gid", "gid", "CDATA", "" + gid);
        gid++;
        at.addAttribute ("", "lsb", "lsb", "CDATA", "" + getint16 (offset));
        offset += 2;
        conf.ch.element ("lsb", at); }

      conf.ch.endElement ("hmtx"); }
  }
</code-fragment>
    </section>
    <!--________________________________________________________________-->
    <section role="implementation">
      <title>Implementation</title>
      <code-fragment package="com.adobe.aots.CommonType" class="Hmtx"><code-title>Hmtx class</code-title>
package com.adobe.aots.CommonType;

import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Hmtx extends Table {

  public Hmtx () {
    super (Tag.hmtx, null);
  }

  public Hmtx (Font font) {
    super (Tag.hmtx, font);
  }

  public int getLeftSideBearing (int glyphID) {
    int numberOfHMetrics = font.hhea.getNumberOfHMetrics ();
    if (glyphID &lt; numberOfHMetrics) {
      return getFWord (4*glyphID + 2); }
    else {
      return getFWord (4*numberOfHMetrics + 2*(glyphID - numberOfHMetrics)); }
  }

  public int getHorizontalAdvance (int glyphID) {
    int numberOfHMetrics = font.hhea.getNumberOfHMetrics ();
    if (glyphID &lt; numberOfHMetrics) {
      return getuFWord (4*glyphID); }
    else {
      return getuFWord (4*(numberOfHMetrics - 1)); }
  }

  <code-include linkend="hmtx.methods"/>
}
</code-fragment>
    </section>
  </section>
</section>
