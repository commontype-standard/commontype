<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<section id="chapter.misc">
  <title>Misc</title>
  <!--======================================================================-->
  <section role="fragment">
    <title>Code to sort out</title>
    <!--____________________________________________________________________-->
    <section role="implementation">
      <title>Implementation</title>
      <para>The SAX2 <varname>ContentHandler</varname> class provides
        a minimal interface  between SAX players. This makes it
        possible to connect minimal implementations. The downside is
        that applications that generate events out of the blue (by
        opposition to parsers) have a fair amount of work.</para>
      <para>The <varname>ContentHandlerPlus</varname> class makes
        this situation more tolerable by extending the
        <varname>ContentHandler</varname> interface. For example, the
        <varname>element</varname> method is a shorthand for the
        combination of <varname>startElement</varname> and
        <varname>endElement</varname>.</para>
      <para>Since this class is fairly straightforward, we are just
        going to give it in bulk:</para>
      <code-fragment package="com.adobe.aots.util" class="ContentHandlerPlus"><code-title>StyleSheet</code-title>
package com.adobe.aots.util;

import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;

import org.xml.sax.SAXException;
import org.xml.sax.Attributes;


public class ContentHandlerPlus implements org.xml.sax.ContentHandler {

  protected ContentHandler base;

  protected Attributes nullAtts = new org.xml.sax.helpers.AttributesImpl ();

  public ContentHandlerPlus (ContentHandler base) {
    this.base = base;
  }

  public void setDocumentLocator (Locator locator) {
    base.setDocumentLocator (locator);
  }

  public void startDocument ()
      throws SAXException {
    base.startDocument ();
  }

  public void endDocument()
      throws SAXException {
    base.endDocument ();
  }

  public void startPrefixMapping (String prefix, String uri)
      throws SAXException {
    base.startPrefixMapping (prefix, uri);
  }

  public void endPrefixMapping (String prefix)
      throws SAXException {
    base.endPrefixMapping (prefix);
  }

  public void startElement (String namespaceURI, String localName,
                            String qName, Attributes atts)
      throws SAXException {
    base.startElement (namespaceURI, localName, qName, atts);
  }

  public void startElement (String namespaceURI, String localName,
                            String qName)
      throws SAXException {
    base.startElement (namespaceURI, localName, qName, nullAtts);
  }

  public void startElement (String localName, Attributes atts)
      throws SAXException {
    base.startElement ("", localName, localName, atts);
  }

  public void startElement (String localName)
      throws SAXException {
    base.startElement ("", localName, localName, nullAtts);
  }

  public void endElement (String namespaceURI, String localName,
                          String qName)
      throws SAXException {
    base.endElement (namespaceURI, localName, qName);
  }

  public void endElement (String localName)
      throws SAXException {
    base.endElement ("", localName, localName);
  }

  public void element (String namespaceURI, String localName,
                       String qName, Attributes atts)
      throws SAXException {
    base.startElement (namespaceURI, localName, qName, atts);
    base.endElement (namespaceURI, localName, qName);
  }

  public void element (String namespaceURI, String localName,
                       String qName)
      throws SAXException {
    base.startElement (namespaceURI, localName, qName, nullAtts);
    base.endElement (namespaceURI, localName, qName);
  }

  public void element (String localName, Attributes atts)
      throws SAXException {
    startElement (localName, atts);
    endElement (localName);
  }

  public void element (String localName)
      throws SAXException {
    startElement (localName);
    endElement (localName);
  }

  public void element (String localName, String content)
      throws SAXException {
    startElement (localName);
    characters (content);
    endElement (localName);
  }

  public void characters (char ch[], int start, int length)
      throws SAXException {
    base.characters (ch, start, length);
  }

  public void characters (String s)
      throws SAXException {
    char[] ch = s.toCharArray ();
    base.characters (ch, 0, ch.length);
  }

  public void ignorableWhitespace (char ch[], int start, int length)
      throws SAXException {
    base.ignorableWhitespace (ch, start, length);
  }

  public void processingInstruction (String target, String data)
      throws SAXException {
    base.processingInstruction (target, data);
  }

  public void skippedEntity (String name)
      throws SAXException {
    base.skippedEntity (name);
  }
}
</code-fragment>
      <code-fragment id="test_imports"><code-title>Imports for test methods</code-title>

  import java.io.File;
  import java.net.URL;
  import java.text.BreakIterator;
</code-fragment>
      <code-fragment id="test_methods"><code-title>Methods for testing</code-title>
  static int[] parseIntList (String s) {
    int i;
    int len = s.length ();
    int count = 0;

    i = 0;
    while (i &lt; len) {
      while (i &lt; len &amp;&amp; (s.charAt (i) == ' ' || s.charAt (i) == ',')) {
        i++; }
      if (i == len) {
        break; }
      while (i &lt; len &amp;&amp; s.charAt (i) != ' ' &amp;&amp; s.charAt (i) != ',') {
        i++; }
      count++; }

    int[] list = new int [count];

    i = 0;
    count = 0;
    while (i &lt; len) {
      while (i &lt; len &amp;&amp; (s.charAt (i) == ' ' || s.charAt (i) == ',')) {
        i++; }
      if (i == len) {
        break; }
      int start = i;
      while (i &lt; len &amp;&amp; s.charAt (i) != ' ' &amp;&amp; s.charAt (i) != ',') {
        i++; }
      int radix = 10;
      if (   i - start &gt;= 2
          &amp;&amp; s.charAt (start) == '0'
          &amp;&amp; s.charAt (start+1) == 'x') {
        start += 2;
        radix = 16; }
      list [count] = Integer.parseInt (s.substring (start, i), radix);
      count++; }

    return list;
  }

  static void printIntList (int [] ints) {
    for (int i = 0; i &lt; ints.length; i++) {
      System.out.print (" " + ints [i]); }
    System.out.println ("");
  }

  static boolean compareIntLists (int[] expected, int[] outputs) {
    return compareIntLists (expected, outputs, outputs.length);
  }

  static boolean compareIntLists (int[] expected, int[] outputs,
                                  int outputLength ) {
    boolean pass = true;

    if (outputLength != expected.length) {
      pass = false; }
    else {
      for (int i = 0; i &lt; expected.length; i++) {
        if (outputs [i] != expected [i]) {
          pass = false;
          break; }}}

    return pass;
  }

  static void reportStatus (String test, boolean pass) {
    if (pass) {
      System.out.println ("----- TEST " + test + " PASS"); }
    else {
      System.out.println ("***** TEST " + test + " FAIL"); }
  }
</code-fragment>
      <code-fragment package="com.adobe.aots.CommonType" class="InvalidFontException"><code-title>Invalid Font Exception</code-title>
  package com.adobe.aots.CommonType;

  public class InvalidFontException extends Exception {

    static final long serialVersionUID = 44839L;

    public InvalidFontException () {
      super ();
    }

    public InvalidFontException (String s) {
      super (s);
    }
  }
</code-fragment>
      <code-fragment package="com.adobe.aots.CommonType" class="UnsupportedFontException"><code-title>Unsupported Font Exception</code-title>
  package com.adobe.aots.CommonType;

  public class UnsupportedFontException extends Exception {

    static final long serialVersionUID = 44888L;

    public UnsupportedFontException () {
      super ();
    }

    public UnsupportedFontException (String s) {
      super (s);
    }
  }
</code-fragment>
      <code-fragment package="com.adobe.aots.CommonType" class="Font"><code-title>Font class</code-title>
package com.adobe.aots.CommonType;

import java.util.Iterator;

import java.io.File;
import java.io.InputStream;
import java.io.IOException;
import java.net.URL;


import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Element;
import org.xml.sax.helpers.AttributesImpl;

import com.adobe.aots.util.ContentHandlerPlus;

public class Font {
  public Header header = null;
  public Head head = null;
  public Name name = null;
  public Cmap cmap = null;
  public Hhea hhea = null;
  public Hdmx hdmx = null;
  public Hmtx hmtx = null;
  public Vhea vhea = null;
  public Vmtx vmtx = null;
  public Base base = null;
  public Gdef gdef = null;
  public Gsub gsub = null;
  public Gpos gpos = null;
  public OS2  os2  = null;
  public Post post = null;
  public Maxp maxp = null;
  public CFF  cff  = null;
  public Dsig dsig = null;
  public Glyf glyf = null;
  public Loca loca = null;
  public Table cvt = null;
  public Table prep = null;
  public Table fpgm = null;
  public Vorg vorg = null;
  public Vdmx vdmx = null;

  public java.util.SortedMap&lt;Long, Table&gt; tables
  = new java.util.TreeMap&lt;Long, Table&gt; ();

  <code-include linkend="font.methods"/>

  public void fromBinary (URL src)
    throws IOException, InvalidFontException {

    fromBinary (src.openStream ());
  }

  public void fromBinary (URL src, int ttcIndex)
    throws IOException, InvalidFontException {

    fromBinary (src.openStream (), ttcIndex);
  }

  public void fromBinary (InputStream in)
      throws IOException, InvalidFontException {

    fromBinary (in, -1);
  }

  public void fromBinary (InputStream in, int ttcIndex)
      throws IOException, InvalidFontException {

    try {
      int curOffset = 0;

      Header header = new Header (this);

      if (ttcIndex == -1) {
        curOffset += header.fromBinary (in); }
      else {
        curOffset += header.fromTTCBinary (in, ttcIndex); }

      for (Iterator it = header.tablesByOffset (); it.hasNext ();) {
        Header.TableDesc td = (Header.TableDesc) it.next ();

        while (curOffset != td.offset) {
          curOffset += in.skip (td.offset - curOffset); }

        Table t = null;

             if (td.tag == Tag.name) { t = name = new Name (this); }
        else if (td.tag == Tag.cmap) { t = cmap = new Cmap (this); }
        else if (td.tag == Tag.head) { t = head = new Head (this); }
        else if (td.tag == Tag.hhea) { t = hhea = new Hhea (this); }
        else if (td.tag == Tag.hdmx) { t = hdmx = new Hdmx (this); }
        else if (td.tag == Tag.hmtx) { t = hmtx = new Hmtx (this); }
        else if (td.tag == Tag.vhea) { t = vhea = new Vhea (this); }
        else if (td.tag == Tag.vmtx) { t = vmtx = new Vmtx (this); }
        else if (td.tag == Tag.os2 ) { t = os2  = new OS2  (this); }
        else if (td.tag == Tag.post) { t = post = new Post (this); }
        else if (td.tag == Tag.maxp) { t = maxp = new Maxp (this); }
        else if (td.tag == Tag.loca) { t = loca = new Loca (this); }
        else if (td.tag == Tag.glyf) { t = glyf = new Glyf (this); }
        else if (td.tag == Tag.CFF ) { t = cff  = new CFF  (this); }
        else if (td.tag == Tag.BASE) { t = base = new Base (this); }
        else if (td.tag == Tag.GPOS) { t = gpos = new Gpos (this); }
        else if (td.tag == Tag.GSUB) { t = gsub = new Gsub (this); }
        else if (td.tag == Tag.GDEF) { t = gdef = new Gdef (this); }
        else if (td.tag == Tag.DSIG) { t = dsig = new Dsig (this); }
        else if (td.tag == Tag.VORG) { t = vorg = new Vorg (this); }
        else if (td.tag == Tag.VDMX) { t = vdmx = new Vdmx (this); }
        else if (td.tag == Tag.cvt)  { t = cvt  = new UnknownTable (td.tag, this); }
        else if (td.tag == Tag.prep) { t = prep = new UnknownTable (td.tag, this); }
        else if (td.tag == Tag.fpgm) { t = fpgm = new UnknownTable (td.tag, this); }
        else                         { t = new UnknownTable (td.tag, this); }

        tables.put (td.tag, t);
        curOffset += t.fromBinary (in, td.length); }}

    finally {
      in.close (); }
  }

  public void fromXML (URL context, Element font)
      throws IOException, InvalidFontException, UnsupportedFontException {
    NodeList tableNodes = font.getChildNodes ();

    for (int i = 0; i &lt; tableNodes.getLength (); i++) {
      Element tableElem = (Element) tableNodes.item (i);

      if ("base-font".equals (tableElem.getTagName ())) {
        fromBinary (new URL (context, tableElem.getAttribute ("name"))); }

      else {
        String tags = tableElem.getTagName ();
        if ("OS2".equals (tags)) {
          tags = "OS/2"; }
        long tag = Tag.string2tag (tags);
        Table t = null;

             if (tag == Tag.name) { t = name = new Name (this); }
        else if (tag == Tag.cmap) { t = cmap = new Cmap (this); }
        else if (tag == Tag.head) { t = head = new Head (this); }
        else if (tag == Tag.hhea) { t = hhea = new Hhea (this); }
        else if (tag == Tag.hdmx) { t = hdmx = new Hdmx (this); }
        else if (tag == Tag.hmtx) { t = hmtx = new Hmtx (this); }
        else if (tag == Tag.vhea) { t = vhea = new Vhea (this); }
        else if (tag == Tag.vmtx) { t = vmtx = new Vmtx (this); }
        else if (tag == Tag.os2 ) { t = os2  = new OS2  (this); }
        else if (tag == Tag.post) { t = post = new Post (this); }
        else if (tag == Tag.maxp) { t = maxp = new Maxp (this); }
        else if (tag == Tag.glyf) { t = glyf = new Glyf (this); }
        else if (tag == Tag.CFF ) { t = cff  = new CFF  (this); }
        else if (tag == Tag.BASE) { t = base = new Base (this); }
        else if (tag == Tag.GPOS) { t = gpos = new Gpos (this); }
        else if (tag == Tag.GSUB) { t = gsub = new Gsub (this); }
        else if (tag == Tag.GDEF) { t = gdef = new Gdef (this); }
        else if (tag == Tag.DSIG) { t = dsig = new Dsig (this); }
        else if (tag == Tag.VORG) { t = vorg = new Vorg (this); }
        else if (tag == Tag.VDMX) { t = vdmx = new Vdmx (this); }
        else if (tag == Tag.cvt)  { t = cvt  = new UnknownTable (tag, this); }
        else if (tag == Tag.prep) { t = prep = new UnknownTable (tag, this); }
        else if (tag == Tag.fpgm) { t = fpgm = new UnknownTable (tag, this); }
        else                      { t = new UnknownTable (tag, this); }

        t.fromXML (tableElem);
        tables.put (tag, t); }}
  }

  public void toXML (DecompilerConfig conf)
      throws org.xml.sax.SAXException,
             InvalidFontException,
             UnsupportedFontException {
    toXML (conf, null, null);
  }

  public void toXML (DecompilerConfig conf, long[] tags, URL base)
      throws org.xml.sax.SAXException,
             InvalidFontException,
             UnsupportedFontException {
    conf.ch.startElement ("font"); {
      if (base != null) {
        AttributesImpl at = new AttributesImpl ();
	at.addAttribute ("", "name", "name", "CDATA", base.toString ());
	conf.ch.element ("base-font", at); }

      if (conf.gid == DecompilerConfig.Gid.byName) {
        conf.glyphNames = getGlyphNames ();
        conf.incorporateUserGlyphNames (maxp.getNumGlyphs ());
	if (conf.glyphNames == null) {
	  conf.gid = DecompilerConfig.Gid.byNumber; }}

      for (Table t : tables.values ()) {
	boolean dumpIt = false;
	if (tags == null) {
          dumpIt = true; }
        else {
          for (int i = 0; i &lt; tags.length; i++) {
            if (tags [i] == Tag.size &amp;&amp; t instanceof Gpos) {
              ((Gpos)t).opticalSizeToXML (conf); }
            if (tags [i] == t.tag) {
              dumpIt = true; }}}
	if (dumpIt) {
          t.toXML (conf); }}
      conf.ch.endElement ("font"); }
  }

  public String[] getGlyphNames () {
    if (cff != null) {
      return cff.getGlyphNames (); }
    else {
      return post.getGlyphNames (); }
  }

  public void toBinary (String outfile)
      throws java.io.IOException, java.io.FileNotFoundException {

    toBinary (new java.io.FileOutputStream (outfile));
  }


  public void toBinary (java.io.OutputStream out)
      throws java.io.IOException {

    int headerSize = 12 + 16 * tables.size ();
    int searchRange = 1;
    int entrySelector = 0;
    while (searchRange &lt;= tables.size ()) {
      searchRange *= 2;
      entrySelector++; }
    searchRange *= 8;
    entrySelector--;
    int rangeShift = tables.size () * 16 - searchRange;

    Block header = new Block (headerSize, 0);

    if (tables.get (new Long (Tag.CFF)) != null) {
      header.setTag (0, "OTTO"); }
    else {
      header.setFixed (0, 1, 0); }
    header.setuint16 (4, tables.size ());
    header.setuint16 (6, searchRange);
    header.setuint16 (8, entrySelector);
    header.setuint16 (10, rangeShift);

    long offset = headerSize;
    int headerOffset = 12;
    long fileChecksum = 0;

    head.clearChecksumAdjust ();

    java.util.Map&lt;Long, byte[]&gt; tablesData
         = new java.util.TreeMap&lt;Long, byte[]&gt; ();
    for (Table t : tables.values ()) {
      byte[] data = t.toBinary ();
      tablesData.put (t.getTag (), data);
      long tableChecksum = checksum (data);

      fileChecksum = (fileChecksum + tableChecksum) &amp; 0xffffffffL;

      header.setuint32 (headerOffset,      (int)t.getTag ());
      header.setuint32 (headerOffset + 4,  (int)tableChecksum);
      header.setuint32 (headerOffset + 8,  (int)offset);
      header.setuint32 (headerOffset + 12, data.length);
      headerOffset += 16;

      offset += data.length;
      if (data.length % 4 != 0) {
        offset += 4 - (data.length % 4); }}

    fileChecksum = (fileChecksum + checksum (header.content)) &amp; 0xffffffffL;

    long checksumAdjust = (0xb1b0afbaL - fileChecksum) &amp; 0xffffffffL;
    head.setChecksumAdjust (checksumAdjust);
    tablesData.put (Tag.head, head.toBinary ());

    out.write (header.content);

    for (Iterator it = tables.keySet ().iterator (); it.hasNext ();) {
      byte[] data = tablesData.get (it.next ());
      out.write (data);

      if (data.length % 4 != 0) {
        int pad = ((data.length / 4) + 1) * 4 - data.length;
        for (int k = 0; k &lt; pad; k++) {
          out.write (0); }}}

    out.close ();
  }

  public void applyGsubFeatures (long scriptTag, long langSysTag,
                                 long[] featureTags, GlyphRun gr)
      throws InvalidFontException {

    if (gsub != null) {
      gsub.applyFeatures (scriptTag, langSysTag, featureTags, gr); }
  }

  public void applyGposFeatures (long scriptTag, long langSysTag,
                                 long[] featureTags, GlyphRun gr)
      throws InvalidFontException {

    if (gpos != null) {
      gpos.applyFeatures (scriptTag, langSysTag, featureTags, gr); }
  }

  public BoundingBox getContoursBoundingBox (int gid) {
    if (cff != null) {
      return cff.getContoursBoundingBox (gid); }
    else {
      return glyf.getContoursBoundingBox (gid); }
  }
}
</code-fragment>
    </section>
  </section>
  <!--======================================================================-->
  <section role="fragment">
    <title>Test Font Fragments</title>
    <!--____________________________________________________________________-->
    <section role="test-suite">
      <title>Test Suite</title>
      <para>Here are some useful font fragments to build test
	fonts.</para>
      <para>The first fragment is a piece of layout table. It declares
	the 'latn' script, a default language for it, and a feature list
	for it which references the lookup with id 'lookup.test'.</para>
      <code-fragment id="testfonts.gsub.scripts_features">
        <code-title>ScriptList latn/default; Feature list: 'test'-&gt;lookup.test</code-title>
        <scriptList>
          <script tag="latn">
            <defaultLangSys>
              <featureIndex name="feature.test"/>
            </defaultLangSys>
          </script>
        </scriptList>
        <featureList>
          <feature id="feature.test" tag="test">
            <lookupIndex name="lookup.test"/>
          </feature>
        </featureList>
      </code-fragment>
      <code-fragment id="testfonts.gpos.scripts_features">
        <code-title>ScriptList latn/default; Feature list: 'test'-&gt;lookup.test</code-title>
        <scriptList>
          <script tag="latn">
            <defaultLangSys>
              <featureIndex name="feature.test"/>
            </defaultLangSys>
          </script>
        </scriptList>
        <featureList>
          <feature id="feature.test" tag="test">
            <lookupIndex name="lookup.test"/>
          </feature>
        </featureList>
      </code-fragment>
      <para>For contextual and chaining contextual lookups, we have a
	 bit more infrastructure. Here are GSUB lookups that are going
	 to be invoked from contextual lookups:</para>
      <code-fragment id="testfonts.context.gsub.lookups">
        <lookup id="lookup.single" type="1">
          <singleSubst format="1">
            <coverage format="1" glyphs="20 21 22 23 24 25 26 27 28 29"/>
            <delta v="40"/>
          </singleSubst>
        </lookup>
        <lookup id="lookup.double" type="4">
          <ligatureSubst format="1">
            <subst in="21 22" out="61"/>
          </ligatureSubst>
        </lookup>
        <lookup id="lookup.double.nomarks" type="4" ignoreMarks="yes">
          <ligatureSubst format="1">
            <subst in="21 22" out="61"/>
          </ligatureSubst>
        </lookup>
        <lookup id="lookup.multiple" type="2">
          <multipleSubst format="1">
            <subst in="21" out="61 62 63"/>
          </multipleSubst>
        </lookup>
      </code-fragment>
      <para>Here is the similar set of GPOS lookups:</para>
      <code-fragment id="testfonts.context.gpos.lookups">
        <lookup id="lookup.single" type="1">
          <singlePos format="1">
            <coverage format="any" glyphs="20 21 22 23 24 25 26 27 28 29"/>
            <value xPlacement="20"/>
          </singlePos>
        </lookup>
        <lookup id="lookup.double" type="2">
          <pairPos format="1">
            <pairSet in="21">
              <pos2 in="22">
                <value1 xPlacement="20"/>
              </pos2>
            </pairSet>
          </pairPos>
        </lookup>
        <lookup id="lookup.double.nomarks" type="2" ignoreMarks="yes">
          <pairPos format="1">
            <pairSet in="21">
              <pos2 in="22">
                <value1 xPlacement="20"/>
              </pos2>
            </pairSet>
          </pairPos>
        </lookup>
        <lookup id="lookup.multiple" type="1"/>
        <!-- there is nothing equivalent to multiple in GPOS-->
      </code-fragment>
      <para>The GDEF table that goes with them:</para>
      <code-fragment id="testfonts.context.gdef">
        <GDEF major="1" minor="0">
          <glyphClassDef format="any">
            <class classID="1" glyphs="80 81 82 83 84"/>
            <!-- base -->
            <class classID="2" glyphs="85 86 87 88 89"/>
            <!-- ligature -->
            <class classID="3" glyphs="90 91 92 93 94"/>
            <!-- mark -->
            <class classID="4" glyphs="95 96 97 98 99"/>
            <!-- component -->
          </glyphClassDef>
        </GDEF>
      </code-fragment>
    </section>
  </section>
</section>
